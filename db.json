{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/fold.png","path":"img/fold.png","modified":0,"renderable":0},{"_id":"source/img/next.png","path":"img/next.png","modified":0,"renderable":0},{"_id":"source/img/header.jpg","path":"img/header.jpg","modified":0,"renderable":0},{"_id":"source/img/test.png","path":"img/test.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.266c1c.css","path":"main.266c1c.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.096dc6.js","path":"slider.096dc6.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.js","path":"main.266c1c.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.906508.js","path":"mobile.906508.js","modified":0,"renderable":1},{"_id":"source/img/back.jpg","path":"img/back.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"source/img/yaofan.png","path":"img/yaofan.png","modified":0,"renderable":0},{"_id":"source/img/yaofan2.png","path":"img/yaofan2.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"eba9580a5de06172aa3fce650d97d2097b34b340","modified":1526033632204},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1526033632382},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1526033632382},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1526033632382},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1526033632382},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1526033632382},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1526033632383},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1526033632383},{"_id":"themes/yilia/_config.yml","hash":"45e33526f98fc3aedfc90a86ee589289fd689515","modified":1526033632383},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1526033632392},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1526033632413},{"_id":"source/_drafts/new-draft.md","hash":"61d3c3c29154475c1733f3aa71f3d785115c55f4","modified":1526033632205},{"_id":"source/_posts/.DS_Store","hash":"5b8169987ba6639b155f61bc42b528304a852c58","modified":1526033632205},{"_id":"source/_posts/CppReview.md","hash":"cfca31cfe2afdeee19f0e27e70248003f11c7432","modified":1526033632205},{"_id":"source/_posts/kupao.md","hash":"cf0e4b7ba3dd03d190a503f09676b75e6edcd648","modified":1526033632205},{"_id":"source/_posts/picture-texture.md","hash":"5dc35cab36ee32f10fe55dcef5afa19d99b1ad77","modified":1526033632315},{"_id":"source/_posts/temp.md","hash":"772b48e258f48aa240ef9dd1fa5bdf5d3051f6e2","modified":1526033632318},{"_id":"source/_posts/unityAdsAdapter.md","hash":"1d9f1e8dee04a828c3fe7c1accbcc5cdd5afafbb","modified":1526041014812},{"_id":"source/_posts/unity_study.md","hash":"899a6b7b725d878784c0dc4e5b45419a803a6772","modified":1526033632320},{"_id":"source/_posts/首次使用gitpage.md","hash":"80d36d9f51a27b303ef80ccc1c99be1411cf0cab","modified":1526033632359},{"_id":"source/_posts/unity镜头控制脚本.md","hash":"34b3028cde97272e516d72901cb67712d0d22292","modified":1526033632357},{"_id":"source/img/fold.png","hash":"09e81d048d413dcb09d5eb9351552a4aad8bbffe","modified":1526033632360},{"_id":"source/img/next.png","hash":"f90547f08f0fec44e943fa2f69c63bd4ececbba9","modified":1526033632360},{"_id":"source/img/header.jpg","hash":"725778ad8f70490d0a03c8f57b6ce8252daa7c31","modified":1526033632360},{"_id":"source/img/test.png","hash":"a10ea87ffe7d1cd391330adf2c9d7ac7e6f1ffbc","modified":1526033632361},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1526033632390},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1526033632391},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1526033632391},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1526033632391},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526033632391},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526033632391},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1526033632391},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1526033632383},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1526033632383},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1526033632384},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1526033632384},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1526033632384},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1526033632384},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1526033632384},{"_id":"themes/yilia/source/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1526033632411},{"_id":"themes/yilia/source/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1526033632413},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1526033632392},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1526033632408},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526033632390},{"_id":"themes/yilia/source/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1526033632412},{"_id":"themes/yilia/source/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1526033632413},{"_id":"source/_posts/kupao/1502367185977.png","hash":"7219b64878a032c60112268f280e31689758c812","modified":1526033632206},{"_id":"source/_posts/kupao/1502419665363.png","hash":"ff0e89025d7465430abdbc0577bf12c258829f76","modified":1526033632206},{"_id":"source/_posts/kupao/1502421000610.png","hash":"c9db7ce8d3e5fb2152d1daa032272e7b95778c30","modified":1526033632207},{"_id":"source/_posts/kupao/1502587224424.png","hash":"4e1128df3d2ddfaaa9c6ed220a1fb6dc02327e3a","modified":1526033632207},{"_id":"source/_posts/kupao/1502589425321.png","hash":"e24b70833f9f43ffad07a98c2c6398b57f47843b","modified":1526033632207},{"_id":"source/_posts/kupao/1502589610210.png","hash":"b03cfdc24cf9ce0a4099ff825ea195a00f3e9023","modified":1526033632207},{"_id":"source/_posts/kupao/1502589637210.png","hash":"e136b83f0365d0c0b171bed45ea31e7d1d3c3d79","modified":1526033632208},{"_id":"source/_posts/kupao/1502592120847.png","hash":"003f30ea967383c58271dede0280144e9cd42f0a","modified":1526033632208},{"_id":"source/_posts/kupao/1502592598574.png","hash":"d8731c5d7fa75fd3365cb1792bf0d9fff4d18a2a","modified":1526033632208},{"_id":"source/_posts/kupao/1502592616992.png","hash":"fa9d53bd19dcc680c1c7bbe6156d524c75896beb","modified":1526033632209},{"_id":"source/_posts/kupao/1502593455464.png","hash":"65210bb8b794239003fcf56c98b879e63fe9eec6","modified":1526033632209},{"_id":"source/_posts/kupao/1502593542093.png","hash":"8bc74c91137f0f589da627b825ab93626c019de5","modified":1526033632209},{"_id":"source/_posts/kupao/1502593562614.png","hash":"a93c41d55825fe5779207d4a5949ed16c722ad2c","modified":1526033632210},{"_id":"source/_posts/kupao/1502597632750.png","hash":"6ab49de2745718c1bde7aaf9d77ed8aea22948e3","modified":1526033632210},{"_id":"source/_posts/picture-texture/1504488376717.png","hash":"4904e55ca8465bd71f8f562c4f21515750589dc2","modified":1526033632315},{"_id":"source/_posts/picture-texture/1504488394913.png","hash":"283ede849fdb2208dc90a9a108b1ea6edfa162e1","modified":1526033632315},{"_id":"source/_posts/picture-texture/1504488756715.png","hash":"c55095d8231698ce6d800768149dfc2bf4751733","modified":1526033632315},{"_id":"source/_posts/picture-texture/1504488781878.png","hash":"bd3df4bc929b0a53cc72dd447b67f7d4b91f2965","modified":1526033632315},{"_id":"source/_posts/picture-texture/1504489517922.png","hash":"e8956db8b4fad4b23148a578d1c42a9d7bf6bb29","modified":1526033632316},{"_id":"source/_posts/picture-texture/1504491196164.png","hash":"2719b51c21a398c0595f3dd513e26b95a1abca12","modified":1526033632316},{"_id":"source/_posts/picture-texture/1504492132538.png","hash":"e706321f4566b8e978fa9fa682a8a38bda725bc5","modified":1526033632316},{"_id":"source/_posts/picture-texture/1504492579311.png","hash":"067634308921e6d313dd2168a32f2d296d20d5c9","modified":1526033632316},{"_id":"source/_posts/picture-texture/1504492407923.png","hash":"29dffe76bc6410d87a5270a1422c2b02457fe84b","modified":1526033632316},{"_id":"source/_posts/picture-texture/1504511314399.png","hash":"1146a83354b6654868483a14e339d5369140888d","modified":1526033632317},{"_id":"source/_posts/picture-texture/1504516848865.png","hash":"6ed190fef6e15af931fdca0b8a2cb2fdb378ffe8","modified":1526033632318},{"_id":"source/_posts/picture-texture/1504516795002.png","hash":"f91d7fb25756ac8336779743e45f8c58f2dbf11f","modified":1526033632317},{"_id":"source/_posts/unityAdsAdapter/1525597015723.png","hash":"88d1fb4afdebe48863135f8e1ec700d1153d8b18","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525598195085.png","hash":"a9d137102c7af7f82040cc293fe39168c0c3c8be","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525598487988.png","hash":"64806f7c74f06ff75aa8106538c56de70cfca68b","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525598656780.png","hash":"cd34aab46aa610367ee1cd9b4bb4d58dbf825945","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525598533911.png","hash":"f9529d8db98a2a55c19673a8fa9a05f427eab5cb","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525599029998.png","hash":"47545c6ee5e8dd3ba37d722ab1120579f1b1bfce","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525599459607.png","hash":"308fb24f3684e39eaa06f9bbed9cdc3a7ef73330","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/广告图适配方案.md","hash":"1b4425fe7030888e5a53404bb7daddebb647aa6c","modified":1526040472000},{"_id":"source/_posts/unity_study/1491550201008.png","hash":"de04f2d42d39d8c29a36cc25fa66b4e467ead049","modified":1526033632324},{"_id":"source/_posts/unity_study/1491552037983.png","hash":"b000ca20cec48143cb7f065413baadb3a69720f3","modified":1526033632325},{"_id":"source/_posts/unity_study/1491552515808.png","hash":"cd17c2563d5a430475635de215ccdce2cb0badad","modified":1526033632325},{"_id":"source/_posts/unity_study/1491550243585.png","hash":"eba2b07cb50147099076660e6312ee53e6218ada","modified":1526033632325},{"_id":"source/_posts/unity_study/1491553048549.png","hash":"8ab24121ddb6e234a664d8646116211840073018","modified":1526033632326},{"_id":"source/_posts/unity_study/1491553537327.png","hash":"26c8946af6c7caee01c26b8348246f76a48354a7","modified":1526033632327},{"_id":"source/_posts/unity_study/1491553548688.png","hash":"89141888fb968ef221c02d7b09d5acb66fbabb72","modified":1526033632328},{"_id":"source/_posts/unity_study/1491553612376.png","hash":"1dba5a9ff6a3d44f613530513f092a2353447c80","modified":1526033632328},{"_id":"source/_posts/unity_study/1495002356532.png","hash":"7adff9063c0df99372a9bfa5a65a10de3e31252b","modified":1526033632337},{"_id":"source/_posts/unity_study/1495002389507.png","hash":"21b798c09a7105151fa4b5d2f13af0955bda3c62","modified":1526033632338},{"_id":"source/_posts/unity_study/1496577678948.png","hash":"25c098eb6a65483f1a8d513f3377137b7b883766","modified":1526033632339},{"_id":"source/_posts/unity_study/1496577433020.png","hash":"bb751902df9bc6baafa9749c710893fa20736550","modified":1526033632338},{"_id":"source/_posts/unity_study/1496655674282.png","hash":"4aa71687940d3e6d090689f22c301a40a8f4f80b","modified":1526033632341},{"_id":"source/_posts/unity_study/1496663193818.png","hash":"60a45292a7c339b7760e4d311adb9fee2b2810eb","modified":1526033632341},{"_id":"source/_posts/unity_study/1496664667730.png","hash":"70942bf3326e16c1afe0846b4c28821e1b1f2338","modified":1526033632342},{"_id":"source/_posts/unity_study/1496663793026.png","hash":"2f0fff83c10a5f3092aaca10f14863c2a93da18a","modified":1526033632342},{"_id":"source/_posts/unity_study/1496665501144.png","hash":"110334a1800323c3a0ac551f7ff26355955e79fb","modified":1526033632342},{"_id":"source/_posts/unity_study/1497515757683.png","hash":"a53ab7f9d4be3c8bf0611305ca6a382637e4e063","modified":1526033632343},{"_id":"source/_posts/unity_study/1496664752184.png","hash":"5263b922e73c658e616f0dc1c7634ad1b956921e","modified":1526033632342},{"_id":"source/_posts/unity_study/1497515795595.png","hash":"512ecbd6bec076e0e3bf21bd2eebaaaf5ce3e2d9","modified":1526033632343},{"_id":"source/_posts/unity_study/1497516506138.png","hash":"891df67f19ffba5ea41d56379b6bad212a06e56f","modified":1526033632343},{"_id":"source/_posts/unity_study/1497516724024.png","hash":"fea19f55697cbfe9609ae395b93ba1d77edb2f31","modified":1526033632343},{"_id":"source/_posts/unity_study/1497516894694.png","hash":"4b6fa70eeb01fdee991a67b71c6d95ed22f574e6","modified":1526033632344},{"_id":"source/_posts/unity_study/1497531965474.png","hash":"4feaabb97e749b55583def42152a1810922d77b0","modified":1526033632344},{"_id":"source/_posts/unity_study/1497532344804.png","hash":"477306202bf0ee1c2a59203add8818f4991e85e9","modified":1526033632344},{"_id":"source/_posts/unity_study/1497533865288.png","hash":"b4c4117b4d81e703129bc2400c51ee8be094ac6c","modified":1526033632344},{"_id":"source/img/back.jpg","hash":"5eff766f1477d87fd09a4be026a726f044aa631c","modified":1526033632360},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1526033632384},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"b75e8fff732292fa26b5a0b47cd253d4281e321a","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"9bfcbd9e71401b6da6b2bbbe61e97625ca247b7a","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1526033632385},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1526033632386},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1526033632386},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1526033632386},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1526033632386},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1526033632386},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1526033632387},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1526033632390},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1526033632390},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1526033632408},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1526033632408},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1526033632409},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1526033632409},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1526033632410},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1526033632410},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1526033632410},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1526033632411},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1526033632411},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1526033632392},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1526033632393},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1526033632393},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1526033632393},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1526033632393},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1526033632394},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1526033632394},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1526033632394},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1526033632395},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1526033632398},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1526033632396},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1526033632398},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1526033632398},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1526033632399},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1526033632400},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1526033632400},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1526033632401},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1526033632401},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1526033632401},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1526033632401},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1526033632402},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1526033632402},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1526033632402},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1526033632402},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1526033632403},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1526033632403},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1526033632403},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1526033632404},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1526033632405},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1526033632404},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1526033632405},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9bb1a4918c1b1ee62ce0a71381990a1978c51b2a","modified":1526033632405},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1526033632406},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1526033632406},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1526033632406},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1526033632406},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1526033632407},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1526033632407},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1526033632407},{"_id":"source/_posts/picture-texture/1504509740940.png","hash":"605b18695858a269241f92ec87584e6509dcaa21","modified":1526033632317},{"_id":"source/_posts/unityAdsAdapter/1525588861883.png","hash":"f744f1d6f18b2974bfd5d37f95ec0c4e6c2936af","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525595273245.png","hash":"8fb2d542986059fcb97fdeeb64a6d0bd61f6d436","modified":1526040472000},{"_id":"source/_posts/unityAdsAdapter/1525599300970.png","hash":"fbc570a62eec0139d733f051196cb940b03cfce7","modified":1526040472000},{"_id":"source/_posts/unity_study/1491553152505.png","hash":"5b2f77e1fbcb53ac8734f0b981000ddeb1299d7f","modified":1526033632327},{"_id":"source/_posts/unity_study/1491555581945.png","hash":"95ff2754637305e94d8d66dc17dd8fc21d6192cd","modified":1526033632333},{"_id":"source/_posts/unity_study/1491877171720.png","hash":"1609d4f23d67381f36967c8e8a9d3366dd5b73b2","modified":1526033632335},{"_id":"source/_posts/unity_study/ply1.gif","hash":"b324f3b0968d9caee42b1015bd14abf384448f46","modified":1526033632345},{"_id":"source/_posts/unity_study/ply2.gif","hash":"a62e4864165d95f5ca463da870479db82751bea5","modified":1526033632346},{"_id":"source/img/yaofan.png","hash":"4d8c39a456490e915e739de7ca73fb8d368ffbf7","modified":1526033632362},{"_id":"source/img/yaofan2.png","hash":"324b024764a0037465f8ba6e5db7687eafa08baf","modified":1526033632363},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"171b130d25c36f496e4b43e3808707a8f1897729","modified":1526033632389},{"_id":"source/_posts/unity_study/1491555622726.png","hash":"8bc6c9aa5f7b587fd13c9509754c4b1652b38883","modified":1526033632334},{"_id":"source/_posts/unity_study/1491555636221.png","hash":"02684c52e081ce4d2d0a71aa9ef92145fec059b8","modified":1526033632334},{"_id":"source/_posts/unity_study/ply3.gif","hash":"aad561e8698c6c3bc21890ef0290d1a282afc6c8","modified":1526033632347},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1526033632387},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1526033632387},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1526033632387},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1526033632387},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1526033632388},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1526033632388},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1526033632388},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1526033632388},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1526033632389},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1526033632395},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1526033632395},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1526033632395},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1526033632396},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1526033632396},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1526033632397},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1526033632397},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1526033632397},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1526033632398},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1526033632399},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1526033632399},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1526033632400},{"_id":"source/_posts/unity_study/1496583208861.png","hash":"aaede8f8f2b09c999ece09a7163186e3383c0da5","modified":1526033632341},{"_id":"source/_posts/unity_study/1491555497064.png","hash":"db447e3e9024b70b68a362d100a74b13dfce1c57","modified":1526033632332},{"_id":"source/_posts/unity_study/1491555396564.png","hash":"c04612f63512845db6c5bde868074885d12b3f94","modified":1526033632331},{"_id":"source/_posts/unity_study/shader2.gif","hash":"d8842da67740bf52906b1a3c864232e7c9e41296","modified":1526033632356},{"_id":"source/_posts/unity_study/1490002240157.png","hash":"8b890276be767586aad06f8e565e1c769beb0e93","modified":1526033632324},{"_id":"source/_posts/unity_study/1491877201762.png","hash":"ab22382c36a5c2fd5aabf4611f88dab5e974fb39","modified":1526033632337},{"_id":"source/_posts/temp/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526033632320},{"_id":"source/_posts/unity_study/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526033632322},{"_id":"source/_posts/unity镜头控制脚本/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526033632359},{"_id":"source/_posts/unity_study/rpg.gif","hash":"8185d0ed3bdaab8c7acb243dae224315f2677ed4","modified":1526033632353},{"_id":"source/_posts/kupao/demo.gif","hash":"9376907938964696409a71de225e1886fe88f765","modified":1526033632307},{"_id":"public/2018/05/11/CppReview/index.html","hash":"d84a99c1c80e6e859a13d8493c2fa5f6857645dd","modified":1526040869728},{"_id":"public/2017/09/10/picture-texture/index.html","hash":"ae19491340efca634d386028f5e5297ed8340688","modified":1526040670689},{"_id":"public/2017/08/16/kupao/index.html","hash":"98ea1594bee3a66d570abecba3bd7dbef4cd2283","modified":1526040670690},{"_id":"public/2017/08/10/unity镜头控制脚本/index.html","hash":"ec749df1cf0617547247da40cc23c957ba867f59","modified":1526040670690},{"_id":"public/2017/08/01/temp/index.html","hash":"364c606339b2165cbf5aa53689f3cddb2d3e6756","modified":1526040670690},{"_id":"public/2017/07/30/unity_study/index.html","hash":"0390b92d0bf1b8578bf58e8e8d92185dbe4f5bb9","modified":1526040670691},{"_id":"public/2016/08/09/首次使用gitpage/index.html","hash":"ff5c277af733fd9692d271a4a8ac23430996d6c2","modified":1526040670691},{"_id":"public/archives/index.html","hash":"e0da9ac4a8c41ab23a187e0f42b58ca726a583ed","modified":1526040869729},{"_id":"public/archives/2016/index.html","hash":"892840a84ce8490a886c528f8f5e6a85ae960d99","modified":1526040670691},{"_id":"public/archives/2016/08/index.html","hash":"878bb86dca48a8ba944ce4fcffb98ad95eed0d05","modified":1526040670691},{"_id":"public/archives/2017/index.html","hash":"9a03f815573321c48b14dd86b1ff874647aeeafe","modified":1526040670691},{"_id":"public/archives/2017/07/index.html","hash":"d4106c1c2abfea25b924b73092f0a9f2cb4475a4","modified":1526040670692},{"_id":"public/archives/2017/08/index.html","hash":"bd73dcd1b35bd5baca5b5a1bbc0385d158d8a4aa","modified":1526040670692},{"_id":"public/archives/2017/09/index.html","hash":"72313adae64fc299f05f52e187de65813e40f78b","modified":1526040670692},{"_id":"public/archives/2018/index.html","hash":"4778f2c7b53e8bfd9c75502d94712d3fb1800c17","modified":1526040869729},{"_id":"public/archives/2018/05/index.html","hash":"28014c850e3e2734bef84a893230365fc2c8f469","modified":1526040869729},{"_id":"public/tags/unity/index.html","hash":"d391d73d531a230e2f077f09dd96dd16b81742f2","modified":1526040670693},{"_id":"public/tags/纹理格式-手游开发/index.html","hash":"5e5a0c7bfe86e1b762fe4971653383095dd9a237","modified":1526040670693},{"_id":"public/tags/随笔/index.html","hash":"aa41d8239e127d750854a664c8ad5ae445a97725","modified":1526040670693},{"_id":"public/index.html","hash":"5831ce6c67b9b1d90b5484ad7d5056235ba3cc15","modified":1526040869730},{"_id":"public/2018/05/11/unityAdsAdapter/广告图适配方案/index.html","hash":"a94bbb47f14adeb014e5780b65b77b80af08acfa","modified":1526040869720},{"_id":"public/img/fold.png","hash":"09e81d048d413dcb09d5eb9351552a4aad8bbffe","modified":1526040670721},{"_id":"public/img/next.png","hash":"f90547f08f0fec44e943fa2f69c63bd4ececbba9","modified":1526040670722},{"_id":"public/img/header.jpg","hash":"725778ad8f70490d0a03c8f57b6ce8252daa7c31","modified":1526040670722},{"_id":"public/img/test.png","hash":"a10ea87ffe7d1cd391330adf2c9d7ac7e6f1ffbc","modified":1526040670722},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1526040670722},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1526040670722},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1526040670722},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1526040670722},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1526040670722},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1526040670722},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1526040670722},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1526040670722},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1526040670722},{"_id":"public/2017/09/10/picture-texture/1504488394913.png","hash":"283ede849fdb2208dc90a9a108b1ea6edfa162e1","modified":1526040670722},{"_id":"public/2017/09/10/picture-texture/1504488376717.png","hash":"4904e55ca8465bd71f8f562c4f21515750589dc2","modified":1526040670722},{"_id":"public/2017/09/10/picture-texture/1504488756715.png","hash":"c55095d8231698ce6d800768149dfc2bf4751733","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504488781878.png","hash":"bd3df4bc929b0a53cc72dd447b67f7d4b91f2965","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504489517922.png","hash":"e8956db8b4fad4b23148a578d1c42a9d7bf6bb29","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504491196164.png","hash":"2719b51c21a398c0595f3dd513e26b95a1abca12","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504492132538.png","hash":"e706321f4566b8e978fa9fa682a8a38bda725bc5","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504492407923.png","hash":"29dffe76bc6410d87a5270a1422c2b02457fe84b","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504492579311.png","hash":"067634308921e6d313dd2168a32f2d296d20d5c9","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504511314399.png","hash":"1146a83354b6654868483a14e339d5369140888d","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504516795002.png","hash":"f91d7fb25756ac8336779743e45f8c58f2dbf11f","modified":1526040670723},{"_id":"public/2017/09/10/picture-texture/1504516848865.png","hash":"6ed190fef6e15af931fdca0b8a2cb2fdb378ffe8","modified":1526040670723},{"_id":"public/2017/08/16/kupao/1502367185977.png","hash":"7219b64878a032c60112268f280e31689758c812","modified":1526040670723},{"_id":"public/2017/08/16/kupao/1502419665363.png","hash":"ff0e89025d7465430abdbc0577bf12c258829f76","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502421000610.png","hash":"c9db7ce8d3e5fb2152d1daa032272e7b95778c30","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502587224424.png","hash":"4e1128df3d2ddfaaa9c6ed220a1fb6dc02327e3a","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502589425321.png","hash":"e24b70833f9f43ffad07a98c2c6398b57f47843b","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502589610210.png","hash":"b03cfdc24cf9ce0a4099ff825ea195a00f3e9023","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502589637210.png","hash":"e136b83f0365d0c0b171bed45ea31e7d1d3c3d79","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502592120847.png","hash":"003f30ea967383c58271dede0280144e9cd42f0a","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502592598574.png","hash":"d8731c5d7fa75fd3365cb1792bf0d9fff4d18a2a","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502592616992.png","hash":"fa9d53bd19dcc680c1c7bbe6156d524c75896beb","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502593455464.png","hash":"65210bb8b794239003fcf56c98b879e63fe9eec6","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502593542093.png","hash":"8bc74c91137f0f589da627b825ab93626c019de5","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502593562614.png","hash":"a93c41d55825fe5779207d4a5949ed16c722ad2c","modified":1526040670724},{"_id":"public/2017/08/16/kupao/1502597632750.png","hash":"6ab49de2745718c1bde7aaf9d77ed8aea22948e3","modified":1526040670724},{"_id":"public/2017/07/30/unity_study/1491550201008.png","hash":"de04f2d42d39d8c29a36cc25fa66b4e467ead049","modified":1526040670724},{"_id":"public/2017/07/30/unity_study/1491550243585.png","hash":"eba2b07cb50147099076660e6312ee53e6218ada","modified":1526040670724},{"_id":"public/2017/07/30/unity_study/1491552037983.png","hash":"b000ca20cec48143cb7f065413baadb3a69720f3","modified":1526040670724},{"_id":"public/2017/07/30/unity_study/1491552515808.png","hash":"cd17c2563d5a430475635de215ccdce2cb0badad","modified":1526040670724},{"_id":"public/2017/07/30/unity_study/1491553548688.png","hash":"89141888fb968ef221c02d7b09d5acb66fbabb72","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1491553048549.png","hash":"8ab24121ddb6e234a664d8646116211840073018","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1491553537327.png","hash":"26c8946af6c7caee01c26b8348246f76a48354a7","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1491553612376.png","hash":"1dba5a9ff6a3d44f613530513f092a2353447c80","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1495002356532.png","hash":"7adff9063c0df99372a9bfa5a65a10de3e31252b","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1495002389507.png","hash":"21b798c09a7105151fa4b5d2f13af0955bda3c62","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496577433020.png","hash":"bb751902df9bc6baafa9749c710893fa20736550","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496577678948.png","hash":"25c098eb6a65483f1a8d513f3377137b7b883766","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496655674282.png","hash":"4aa71687940d3e6d090689f22c301a40a8f4f80b","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496663193818.png","hash":"60a45292a7c339b7760e4d311adb9fee2b2810eb","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496663793026.png","hash":"2f0fff83c10a5f3092aaca10f14863c2a93da18a","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496664667730.png","hash":"70942bf3326e16c1afe0846b4c28821e1b1f2338","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496665501144.png","hash":"110334a1800323c3a0ac551f7ff26355955e79fb","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497515757683.png","hash":"a53ab7f9d4be3c8bf0611305ca6a382637e4e063","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497515795595.png","hash":"512ecbd6bec076e0e3bf21bd2eebaaaf5ce3e2d9","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1496664752184.png","hash":"5263b922e73c658e616f0dc1c7634ad1b956921e","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497516506138.png","hash":"891df67f19ffba5ea41d56379b6bad212a06e56f","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497516894694.png","hash":"4b6fa70eeb01fdee991a67b71c6d95ed22f574e6","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497516724024.png","hash":"fea19f55697cbfe9609ae395b93ba1d77edb2f31","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497531965474.png","hash":"4feaabb97e749b55583def42152a1810922d77b0","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497532344804.png","hash":"477306202bf0ee1c2a59203add8818f4991e85e9","modified":1526040670725},{"_id":"public/2017/07/30/unity_study/1497533865288.png","hash":"b4c4117b4d81e703129bc2400c51ee8be094ac6c","modified":1526040670725},{"_id":"public/2017/09/10/picture-texture/1504509740940.png","hash":"605b18695858a269241f92ec87584e6509dcaa21","modified":1526040670730},{"_id":"public/2017/07/30/unity_study/1491553152505.png","hash":"5b2f77e1fbcb53ac8734f0b981000ddeb1299d7f","modified":1526040670732},{"_id":"public/2017/07/30/unity_study/1491555581945.png","hash":"95ff2754637305e94d8d66dc17dd8fc21d6192cd","modified":1526040670732},{"_id":"public/2017/07/30/unity_study/1491877171720.png","hash":"1609d4f23d67381f36967c8e8a9d3366dd5b73b2","modified":1526040670732},{"_id":"public/2017/07/30/unity_study/ply1.gif","hash":"b324f3b0968d9caee42b1015bd14abf384448f46","modified":1526040670732},{"_id":"public/2017/07/30/unity_study/ply2.gif","hash":"a62e4864165d95f5ca463da870479db82751bea5","modified":1526040670732},{"_id":"public/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1526040670737},{"_id":"public/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1526040670737},{"_id":"public/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1526040670737},{"_id":"public/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1526040670737},{"_id":"public/img/back.jpg","hash":"5eff766f1477d87fd09a4be026a726f044aa631c","modified":1526040670737},{"_id":"public/2017/07/30/unity_study/1491555622726.png","hash":"8bc6c9aa5f7b587fd13c9509754c4b1652b38883","modified":1526040670737},{"_id":"public/2017/07/30/unity_study/1491555636221.png","hash":"02684c52e081ce4d2d0a71aa9ef92145fec059b8","modified":1526040670738},{"_id":"public/2017/07/30/unity_study/ply3.gif","hash":"aad561e8698c6c3bc21890ef0290d1a282afc6c8","modified":1526040670738},{"_id":"public/img/yaofan.png","hash":"4d8c39a456490e915e739de7ca73fb8d368ffbf7","modified":1526040670746},{"_id":"public/img/yaofan2.png","hash":"324b024764a0037465f8ba6e5db7687eafa08baf","modified":1526040670746},{"_id":"public/2017/07/30/unity_study/1496583208861.png","hash":"aaede8f8f2b09c999ece09a7163186e3383c0da5","modified":1526040670746},{"_id":"public/2017/07/30/unity_study/1491555497064.png","hash":"db447e3e9024b70b68a362d100a74b13dfce1c57","modified":1526040670751},{"_id":"public/2017/07/30/unity_study/1491555396564.png","hash":"c04612f63512845db6c5bde868074885d12b3f94","modified":1526040670755},{"_id":"public/2017/07/30/unity_study/shader2.gif","hash":"d8842da67740bf52906b1a3c864232e7c9e41296","modified":1526040670763},{"_id":"public/2017/07/30/unity_study/1490002240157.png","hash":"8b890276be767586aad06f8e565e1c769beb0e93","modified":1526040670766},{"_id":"public/2017/07/30/unity_study/1491877201762.png","hash":"ab22382c36a5c2fd5aabf4611f88dab5e974fb39","modified":1526040670766},{"_id":"public/2017/08/01/temp/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526040670767},{"_id":"public/2017/08/10/unity镜头控制脚本/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526040670767},{"_id":"public/2017/07/30/unity_study/1490002232972.png","hash":"f49fefa703ba118fd3c4a764201824352d1653e9","modified":1526040670767},{"_id":"public/2017/07/30/unity_study/rpg.gif","hash":"8185d0ed3bdaab8c7acb243dae224315f2677ed4","modified":1526040670769},{"_id":"public/2017/08/16/kupao/demo.gif","hash":"9376907938964696409a71de225e1886fe88f765","modified":1526040670799},{"_id":"public/2018/05/11/unityAdsAdapter/index.html","hash":"6444f0ecffb90854a6acaf1efcdcc73dd944a66e","modified":1526041022738},{"_id":"public/2018/05/11/unityAdsAdapter/1525598195085.png","hash":"a9d137102c7af7f82040cc293fe39168c0c3c8be","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525597015723.png","hash":"88d1fb4afdebe48863135f8e1ec700d1153d8b18","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525598487988.png","hash":"64806f7c74f06ff75aa8106538c56de70cfca68b","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525598533911.png","hash":"f9529d8db98a2a55c19673a8fa9a05f427eab5cb","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525598656780.png","hash":"cd34aab46aa610367ee1cd9b4bb4d58dbf825945","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525599029998.png","hash":"47545c6ee5e8dd3ba37d722ab1120579f1b1bfce","modified":1526040869734},{"_id":"public/2018/05/11/unityAdsAdapter/1525599459607.png","hash":"308fb24f3684e39eaa06f9bbed9cdc3a7ef73330","modified":1526040869735},{"_id":"public/2018/05/11/unityAdsAdapter/1525588861883.png","hash":"f744f1d6f18b2974bfd5d37f95ec0c4e6c2936af","modified":1526040869737},{"_id":"public/2018/05/11/unityAdsAdapter/1525595273245.png","hash":"8fb2d542986059fcb97fdeeb64a6d0bd61f6d436","modified":1526040869737},{"_id":"public/2018/05/11/unityAdsAdapter/1525599300970.png","hash":"fbc570a62eec0139d733f051196cb940b03cfce7","modified":1526040869738},{"_id":"public/2018/05/11/unityAdsAdapter/广告图适配方案.html","hash":"5482fb8341d51d67ecadb0dd862d937c65986c56","modified":1526040869740}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"new draft","_content":"私密","source":"_drafts/new-draft.md","raw":"---\ntitle: new draft\ntags:\n---\n私密","slug":"new-draft","published":0,"date":"2018-05-11T10:13:52.205Z","updated":"2018-05-11T10:13:52.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o4m0000znmjni52l31j","content":"<p>私密</p>\n","excerpt":"","more":"<p>私密</p>\n"},{"title":"CppReview","date":"2018-05-11T10:13:52.205Z","published":1,"_content":"\n# 复习C++ \n\n回顾复习下C++的一些知识~\n重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：http://blog.csdn.net/linyanhou/article/details/40153521\n\n<!-- more -->\n\n\n### 1、虚函数实现机制\nClass A(){\n\tvirtual void Ax(){};\n    virtual void Ay(){};\n};\nClass D:A{\n\tvirtual void Ax(){};\n\tvirtual void Ax1(){};\n    virtual void Ay1(){};\n};\n\nA a;\nD d;\n\na对象包含一个虚函数表的指针\nvptrA:存了Ax、Ay函数的函数地址 \nd对象包含一个虚函数表的指针\nvptrD:存了Ax、Ay、Ax1、Ay1函数的函数地址 \nAx是指的是继承类里面的 Ax\n\n多重集成 A、B（两个都包含虚函数的类） 那么则会有两个虚表 \n\n\n用下面代码看下虚表存在哪里：\nclass A\n{\npublic :\n       virtual void test(){};\n};\nint main()\n{\n       A a1;\n       A a2;\n      cout<<&a1<<endl;\n      cout<< sizeof (a1)<<endl;\n      cout<<&a2<<endl;\n      cout<< sizeof (a2)<<endl;\n}\n\n\n输出结果跟 &a1 a1._vfptr 比较发现是一样的，sizeof(a1)是4字节\n\n见大学写的博客：http://blog.csdn.net/linyanhou/article/details/40153521\n\n### 2、构造函数调用顺序\n基类构造函数  之后成员对象的构造函数 之后派生类的构造函数\n下面实验是说明成员对象在初始化列表初始化的话是先于本身的构造函数的：\nclass C\n{\npublic :\n      C()\n      {\n            printf( \"C constructor\\n\" );\n      }\n      C( int i)\n      {\n            printf( \"have num %d constructor\\n\" ,i );\n      }\n};\nclass A\n{\npublic :\n       C c;\n      A():c(123){printf( \"A constructor\\n\" );c = C ();};\n       virtual void foo(){\n            printf( \"Base Class Constructor.\" );\n      }\n};\nint main()\n{\n       A a;\n}\n输出是：\n第一先是这句：A():c(123) 调用了 C 的参数构造函数 输出have num 123 constructor\n第二是这句：printf( \"A constructor\\n\" );  输出A constructor\n第三句是这句：c = C (); 调用 C 的默认构造函数C constructor\n\n### 3、union  还有大端小端的问题\n利用 union 来看是否是大小端\nunion T\n{\n\tchar s[2];\n    int a;\n};\n\nint main()\n{\n\tT t;\n    (1)\n\t打印 t.s[0]  t.s[1] t.a 的地址得知\n    &t.s[0] = &（t.a）\n    结论：char数组的0位地址是int的地址向左对齐\n    (2)\n      t.a=0;\n      t.s[0]=10;\n      t.s[1]=1;\n      printf( \"%d\\n\" ,t.a);\n      \n      **（1）定义分析：**\n      大端 高位存在低地址 例如：\n      int 4字节  byte[0] byte[1] byte[2] byte[3] \n      假设这个 int的16进制是 0x12 34 56 78\n      地址递增 int 0x12 34 56 78 \n      那么 低地址byte[0]存整数的最高位0x12 byte[1]=0x34 byte[2]=0x56 byte[3]=0x78\n      \n      **（2）输出分析：**\n      输出是266，所以这个 int a 的16进制：0x00 00 01 0A \n      0A是整数低位，t.s[0]是低地址 高位存在高地址\n      \n      【注】：修正原来的文章  我当时实验的电脑是小端  高位存在高地址\n      \n      \n      \n}\n\n\n### 4、verctor 的内存分配：\n回顾下自己大学的博客 久不用就容易忘记 还是需要不断的学习\nhttp://blog.csdn.net/linyanhou/article/details/40067727\n1. 不断 push vectro 内存分配 capacity\nfor( int i=0;i<200;i++){\n    v.push_back(a1);\n}\n不断 push 然后查看 capacity:\n1 \n2\n3\n4\n6\n9\n13\n源码：\nif (_Capacity < size() + _Count)//当前空间不足，需要扩容  \n            {   // not enough room, reallocate  \n            _Capacity = max_size() - _Capacity / 2 < _Capacity  \n                ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%，扩容50%  \n            if (_Capacity < size() + _Count)//扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数\n   \n2. 构造函数的调用过程：\n详细看我之前写的博客：\nhttp://blog.csdn.net/linyanhou/article/details/40067727\n   \n3. 如何使用提高性能：\n为了比较，我们用了三种方式来把100个数据存入vector中，分别是：1、直接每次push_back();2、使用resize()提前分配100个空间，然后push_back;3、使用reserve提前分配100个存储空间。\n\n速度（快到慢）：3>2>1\n\n【注】：reserve分配空间  resize()会调用构造函数","source":"_posts/CppReview.md","raw":"---\ntitle: CppReview\ndate: {}\ntags: null\npublished: true\n---\n\n# 复习C++ \n\n回顾复习下C++的一些知识~\n重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：http://blog.csdn.net/linyanhou/article/details/40153521\n\n<!-- more -->\n\n\n### 1、虚函数实现机制\nClass A(){\n\tvirtual void Ax(){};\n    virtual void Ay(){};\n};\nClass D:A{\n\tvirtual void Ax(){};\n\tvirtual void Ax1(){};\n    virtual void Ay1(){};\n};\n\nA a;\nD d;\n\na对象包含一个虚函数表的指针\nvptrA:存了Ax、Ay函数的函数地址 \nd对象包含一个虚函数表的指针\nvptrD:存了Ax、Ay、Ax1、Ay1函数的函数地址 \nAx是指的是继承类里面的 Ax\n\n多重集成 A、B（两个都包含虚函数的类） 那么则会有两个虚表 \n\n\n用下面代码看下虚表存在哪里：\nclass A\n{\npublic :\n       virtual void test(){};\n};\nint main()\n{\n       A a1;\n       A a2;\n      cout<<&a1<<endl;\n      cout<< sizeof (a1)<<endl;\n      cout<<&a2<<endl;\n      cout<< sizeof (a2)<<endl;\n}\n\n\n输出结果跟 &a1 a1._vfptr 比较发现是一样的，sizeof(a1)是4字节\n\n见大学写的博客：http://blog.csdn.net/linyanhou/article/details/40153521\n\n### 2、构造函数调用顺序\n基类构造函数  之后成员对象的构造函数 之后派生类的构造函数\n下面实验是说明成员对象在初始化列表初始化的话是先于本身的构造函数的：\nclass C\n{\npublic :\n      C()\n      {\n            printf( \"C constructor\\n\" );\n      }\n      C( int i)\n      {\n            printf( \"have num %d constructor\\n\" ,i );\n      }\n};\nclass A\n{\npublic :\n       C c;\n      A():c(123){printf( \"A constructor\\n\" );c = C ();};\n       virtual void foo(){\n            printf( \"Base Class Constructor.\" );\n      }\n};\nint main()\n{\n       A a;\n}\n输出是：\n第一先是这句：A():c(123) 调用了 C 的参数构造函数 输出have num 123 constructor\n第二是这句：printf( \"A constructor\\n\" );  输出A constructor\n第三句是这句：c = C (); 调用 C 的默认构造函数C constructor\n\n### 3、union  还有大端小端的问题\n利用 union 来看是否是大小端\nunion T\n{\n\tchar s[2];\n    int a;\n};\n\nint main()\n{\n\tT t;\n    (1)\n\t打印 t.s[0]  t.s[1] t.a 的地址得知\n    &t.s[0] = &（t.a）\n    结论：char数组的0位地址是int的地址向左对齐\n    (2)\n      t.a=0;\n      t.s[0]=10;\n      t.s[1]=1;\n      printf( \"%d\\n\" ,t.a);\n      \n      **（1）定义分析：**\n      大端 高位存在低地址 例如：\n      int 4字节  byte[0] byte[1] byte[2] byte[3] \n      假设这个 int的16进制是 0x12 34 56 78\n      地址递增 int 0x12 34 56 78 \n      那么 低地址byte[0]存整数的最高位0x12 byte[1]=0x34 byte[2]=0x56 byte[3]=0x78\n      \n      **（2）输出分析：**\n      输出是266，所以这个 int a 的16进制：0x00 00 01 0A \n      0A是整数低位，t.s[0]是低地址 高位存在高地址\n      \n      【注】：修正原来的文章  我当时实验的电脑是小端  高位存在高地址\n      \n      \n      \n}\n\n\n### 4、verctor 的内存分配：\n回顾下自己大学的博客 久不用就容易忘记 还是需要不断的学习\nhttp://blog.csdn.net/linyanhou/article/details/40067727\n1. 不断 push vectro 内存分配 capacity\nfor( int i=0;i<200;i++){\n    v.push_back(a1);\n}\n不断 push 然后查看 capacity:\n1 \n2\n3\n4\n6\n9\n13\n源码：\nif (_Capacity < size() + _Count)//当前空间不足，需要扩容  \n            {   // not enough room, reallocate  \n            _Capacity = max_size() - _Capacity / 2 < _Capacity  \n                ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%，扩容50%  \n            if (_Capacity < size() + _Count)//扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数\n   \n2. 构造函数的调用过程：\n详细看我之前写的博客：\nhttp://blog.csdn.net/linyanhou/article/details/40067727\n   \n3. 如何使用提高性能：\n为了比较，我们用了三种方式来把100个数据存入vector中，分别是：1、直接每次push_back();2、使用resize()提前分配100个空间，然后push_back;3、使用reserve提前分配100个存储空间。\n\n速度（快到慢）：3>2>1\n\n【注】：reserve分配空间  resize()会调用构造函数","slug":"CppReview","updated":"2018-05-11T10:13:52.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o4u0001znmjyeoellip","content":"<h1 id=\"复习C\"><a href=\"#复习C\" class=\"headerlink\" title=\"复习C++\"></a>复习C++</h1><p>回顾复习下C++的一些知识~<br>重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：<a href=\"http://blog.csdn.net/linyanhou/article/details/40153521\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/linyanhou/article/details/40153521</a></p>\n<a id=\"more\"></a>\n<h3 id=\"1、虚函数实现机制\"><a href=\"#1、虚函数实现机制\" class=\"headerlink\" title=\"1、虚函数实现机制\"></a>1、虚函数实现机制</h3><p>Class A(){<br>    virtual void Ax(){};<br>    virtual void Ay(){};<br>};<br>Class D:A{<br>    virtual void Ax(){};<br>    virtual void Ax1(){};<br>    virtual void Ay1(){};<br>};</p>\n<p>A a;<br>D d;</p>\n<p>a对象包含一个虚函数表的指针<br>vptrA:存了Ax、Ay函数的函数地址<br>d对象包含一个虚函数表的指针<br>vptrD:存了Ax、Ay、Ax1、Ay1函数的函数地址<br>Ax是指的是继承类里面的 Ax</p>\n<p>多重集成 A、B（两个都包含虚函数的类） 那么则会有两个虚表 </p>\n<p>用下面代码看下虚表存在哪里：<br>class A<br>{<br>public :<br>       virtual void test(){};<br>};<br>int main()<br>{<br>       A a1;<br>       A a2;<br>      cout&lt;&lt;&amp;a1&lt;&lt;endl;<br>      cout&lt;&lt; sizeof (a1)&lt;&lt;endl;<br>      cout&lt;&lt;&amp;a2&lt;&lt;endl;<br>      cout&lt;&lt; sizeof (a2)&lt;&lt;endl;<br>}</p>\n<p>输出结果跟 &amp;a1 a1._vfptr 比较发现是一样的，sizeof(a1)是4字节</p>\n<p>见大学写的博客：<a href=\"http://blog.csdn.net/linyanhou/article/details/40153521\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/linyanhou/article/details/40153521</a></p>\n<h3 id=\"2、构造函数调用顺序\"><a href=\"#2、构造函数调用顺序\" class=\"headerlink\" title=\"2、构造函数调用顺序\"></a>2、构造函数调用顺序</h3><p>基类构造函数  之后成员对象的构造函数 之后派生类的构造函数<br>下面实验是说明成员对象在初始化列表初始化的话是先于本身的构造函数的：<br>class C<br>{<br>public :<br>      C()<br>      {<br>            printf( “C constructor\\n” );<br>      }<br>      C( int i)<br>      {<br>            printf( “have num %d constructor\\n” ,i );<br>      }<br>};<br>class A<br>{<br>public :<br>       C c;<br>      A():c(123){printf( “A constructor\\n” );c = C ();};<br>       virtual void foo(){<br>            printf( “Base Class Constructor.” );<br>      }<br>};<br>int main()<br>{<br>       A a;<br>}<br>输出是：<br>第一先是这句：A():c(123) 调用了 C 的参数构造函数 输出have num 123 constructor<br>第二是这句：printf( “A constructor\\n” );  输出A constructor<br>第三句是这句：c = C (); 调用 C 的默认构造函数C constructor</p>\n<h3 id=\"3、union-还有大端小端的问题\"><a href=\"#3、union-还有大端小端的问题\" class=\"headerlink\" title=\"3、union  还有大端小端的问题\"></a>3、union  还有大端小端的问题</h3><p>利用 union 来看是否是大小端<br>union T<br>{<br>    char s[2];<br>    int a;<br>};</p>\n<p>int main()<br>{<br>    T t;<br>    (1)<br>    打印 t.s[0]  t.s[1] t.a 的地址得知<br>    &amp;t.s[0] = &amp;（t.a）<br>    结论：char数组的0位地址是int的地址向左对齐<br>    (2)<br>      t.a=0;<br>      t.s[0]=10;<br>      t.s[1]=1;<br>      printf( “%d\\n” ,t.a);</p>\n<pre><code>**（1）定义分析：**\n大端 高位存在低地址 例如：\nint 4字节  byte[0] byte[1] byte[2] byte[3] \n假设这个 int的16进制是 0x12 34 56 78\n地址递增 int 0x12 34 56 78 \n那么 低地址byte[0]存整数的最高位0x12 byte[1]=0x34 byte[2]=0x56 byte[3]=0x78\n\n**（2）输出分析：**\n输出是266，所以这个 int a 的16进制：0x00 00 01 0A \n0A是整数低位，t.s[0]是低地址 高位存在高地址\n\n【注】：修正原来的文章  我当时实验的电脑是小端  高位存在高地址\n</code></pre><p>}</p>\n<h3 id=\"4、verctor-的内存分配：\"><a href=\"#4、verctor-的内存分配：\" class=\"headerlink\" title=\"4、verctor 的内存分配：\"></a>4、verctor 的内存分配：</h3><p>回顾下自己大学的博客 久不用就容易忘记 还是需要不断的学习<br><a href=\"http://blog.csdn.net/linyanhou/article/details/40067727\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/linyanhou/article/details/40067727</a></p>\n<ol>\n<li><p>不断 push vectro 内存分配 capacity<br>for( int i=0;i&lt;200;i++){<br> v.push_back(a1);<br>}<br>不断 push 然后查看 capacity:<br>1<br>2<br>3<br>4<br>6<br>9<br>13<br>源码：<br>if (_Capacity &lt; size() + _Count)//当前空间不足，需要扩容  </p>\n<pre><code>{   // not enough room, reallocate  \n_Capacity = max_size() - _Capacity / 2 &lt; _Capacity  \n    ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%，扩容50%  \nif (_Capacity &lt; size() + _Count)//扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数\n</code></pre></li>\n<li><p>构造函数的调用过程：<br>详细看我之前写的博客：<br><a href=\"http://blog.csdn.net/linyanhou/article/details/40067727\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/linyanhou/article/details/40067727</a></p>\n</li>\n<li><p>如何使用提高性能：<br>为了比较，我们用了三种方式来把100个数据存入vector中，分别是：1、直接每次push_back();2、使用resize()提前分配100个空间，然后push_back;3、使用reserve提前分配100个存储空间。</p>\n</li>\n</ol>\n<p>速度（快到慢）：3&gt;2&gt;1</p>\n<p>【注】：reserve分配空间  resize()会调用构造函数</p>\n","excerpt":"<h1 id=\"复习C\"><a href=\"#复习C\" class=\"headerlink\" title=\"复习C++\"></a>复习C++</h1><p>回顾复习下C++的一些知识~<br>重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：<a href=\"http://blog.csdn.net/linyanhou/article/details/40153521\">http://blog.csdn.net/linyanhou/article/details/40153521</a></p>","more":"<h3 id=\"1、虚函数实现机制\"><a href=\"#1、虚函数实现机制\" class=\"headerlink\" title=\"1、虚函数实现机制\"></a>1、虚函数实现机制</h3><p>Class A(){<br>    virtual void Ax(){};<br>    virtual void Ay(){};<br>};<br>Class D:A{<br>    virtual void Ax(){};<br>    virtual void Ax1(){};<br>    virtual void Ay1(){};<br>};</p>\n<p>A a;<br>D d;</p>\n<p>a对象包含一个虚函数表的指针<br>vptrA:存了Ax、Ay函数的函数地址<br>d对象包含一个虚函数表的指针<br>vptrD:存了Ax、Ay、Ax1、Ay1函数的函数地址<br>Ax是指的是继承类里面的 Ax</p>\n<p>多重集成 A、B（两个都包含虚函数的类） 那么则会有两个虚表 </p>\n<p>用下面代码看下虚表存在哪里：<br>class A<br>{<br>public :<br>       virtual void test(){};<br>};<br>int main()<br>{<br>       A a1;<br>       A a2;<br>      cout&lt;&lt;&amp;a1&lt;&lt;endl;<br>      cout&lt;&lt; sizeof (a1)&lt;&lt;endl;<br>      cout&lt;&lt;&amp;a2&lt;&lt;endl;<br>      cout&lt;&lt; sizeof (a2)&lt;&lt;endl;<br>}</p>\n<p>输出结果跟 &amp;a1 a1._vfptr 比较发现是一样的，sizeof(a1)是4字节</p>\n<p>见大学写的博客：<a href=\"http://blog.csdn.net/linyanhou/article/details/40153521\">http://blog.csdn.net/linyanhou/article/details/40153521</a></p>\n<h3 id=\"2、构造函数调用顺序\"><a href=\"#2、构造函数调用顺序\" class=\"headerlink\" title=\"2、构造函数调用顺序\"></a>2、构造函数调用顺序</h3><p>基类构造函数  之后成员对象的构造函数 之后派生类的构造函数<br>下面实验是说明成员对象在初始化列表初始化的话是先于本身的构造函数的：<br>class C<br>{<br>public :<br>      C()<br>      {<br>            printf( “C constructor\\n” );<br>      }<br>      C( int i)<br>      {<br>            printf( “have num %d constructor\\n” ,i );<br>      }<br>};<br>class A<br>{<br>public :<br>       C c;<br>      A():c(123){printf( “A constructor\\n” );c = C ();};<br>       virtual void foo(){<br>            printf( “Base Class Constructor.” );<br>      }<br>};<br>int main()<br>{<br>       A a;<br>}<br>输出是：<br>第一先是这句：A():c(123) 调用了 C 的参数构造函数 输出have num 123 constructor<br>第二是这句：printf( “A constructor\\n” );  输出A constructor<br>第三句是这句：c = C (); 调用 C 的默认构造函数C constructor</p>\n<h3 id=\"3、union-还有大端小端的问题\"><a href=\"#3、union-还有大端小端的问题\" class=\"headerlink\" title=\"3、union  还有大端小端的问题\"></a>3、union  还有大端小端的问题</h3><p>利用 union 来看是否是大小端<br>union T<br>{<br>    char s[2];<br>    int a;<br>};</p>\n<p>int main()<br>{<br>    T t;<br>    (1)<br>    打印 t.s[0]  t.s[1] t.a 的地址得知<br>    &amp;t.s[0] = &amp;（t.a）<br>    结论：char数组的0位地址是int的地址向左对齐<br>    (2)<br>      t.a=0;<br>      t.s[0]=10;<br>      t.s[1]=1;<br>      printf( “%d\\n” ,t.a);</p>\n<pre><code>**（1）定义分析：**\n大端 高位存在低地址 例如：\nint 4字节  byte[0] byte[1] byte[2] byte[3] \n假设这个 int的16进制是 0x12 34 56 78\n地址递增 int 0x12 34 56 78 \n那么 低地址byte[0]存整数的最高位0x12 byte[1]=0x34 byte[2]=0x56 byte[3]=0x78\n\n**（2）输出分析：**\n输出是266，所以这个 int a 的16进制：0x00 00 01 0A \n0A是整数低位，t.s[0]是低地址 高位存在高地址\n\n【注】：修正原来的文章  我当时实验的电脑是小端  高位存在高地址\n</code></pre><p>}</p>\n<h3 id=\"4、verctor-的内存分配：\"><a href=\"#4、verctor-的内存分配：\" class=\"headerlink\" title=\"4、verctor 的内存分配：\"></a>4、verctor 的内存分配：</h3><p>回顾下自己大学的博客 久不用就容易忘记 还是需要不断的学习<br><a href=\"http://blog.csdn.net/linyanhou/article/details/40067727\">http://blog.csdn.net/linyanhou/article/details/40067727</a></p>\n<ol>\n<li><p>不断 push vectro 内存分配 capacity<br>for( int i=0;i&lt;200;i++){<br> v.push_back(a1);<br>}<br>不断 push 然后查看 capacity:<br>1<br>2<br>3<br>4<br>6<br>9<br>13<br>源码：<br>if (_Capacity &lt; size() + _Count)//当前空间不足，需要扩容  </p>\n<pre><code>{   // not enough room, reallocate  \n_Capacity = max_size() - _Capacity / 2 &lt; _Capacity  \n    ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%，扩容50%  \nif (_Capacity &lt; size() + _Count)//扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数\n</code></pre></li>\n<li><p>构造函数的调用过程：<br>详细看我之前写的博客：<br><a href=\"http://blog.csdn.net/linyanhou/article/details/40067727\">http://blog.csdn.net/linyanhou/article/details/40067727</a></p>\n</li>\n<li><p>如何使用提高性能：<br>为了比较，我们用了三种方式来把100个数据存入vector中，分别是：1、直接每次push_back();2、使用resize()提前分配100个空间，然后push_back;3、使用reserve提前分配100个存储空间。</p>\n</li>\n</ol>\n<p>速度（快到慢）：3&gt;2&gt;1</p>\n<p>【注】：reserve分配空间  resize()会调用构造函数</p>"},{"title":"酷跑游戏","date":"2017-08-16T00:49:39.000Z","reward":true,"_content":"\n\n## 一、对这个项目的初步认识：\n### 1、游戏跑起来是怎么样的：\n![Alt text](./demo.gif)\n\n<!-- more -->\n\n\n\n### 2、怎么打开这个工程\n#### 2.1工程下载：\n【附】：项目下载资料为网络搜集所得，仅供学习研究，严谨用于商业行为，请下载后于24小时之内删除。\n\n链接: http://pan.baidu.com/s/1bp5yiSn 密码: 6t4e\n\n#### 2.2怎么打开这个工程\n##### 1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:\n安装教程见我的博客：\nhttps://wlxklyh.github.io/2017/07/30/unity_study/\n\n##### 2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可 \n\n\n### 3、工程代码的结构\n![Alt text](./1502367185977.png)\n\n\n### 4、工程代码的入口\n![Alt text](./1502419665363.png)\n看到Game这个object挂载了很多的脚本组件\n![Alt text](./1502421000610.png)\n我们接下来会看这些代码，从名字来看 重点看GameManager DataManager Mission Manager GUIManager\n\n### 5、第三方库\nUI用了NGUI\n![Alt text](./1502589425321.png)\n\n## 二、阅读代码\n\n### 1、先看GameManager\n这个是游戏管理的类，从这里开始阅读，\n\n\n### 2、AudioManager音效管理\n音效的配置都在Unity编辑器里面配置这些音乐  见图片\n（看MainScene里面Game这个对象 里面挂载一个脚本组件AudioManager）\n![Alt text](./1502587224424.png)\n这个类比较脚本 提供两个接口给外部调用\nplayBackgroundMusic 播放背景音乐\nplaySoundEffect\t播放音效 这里用枚举列出了几种音效\n\n### 3、CoinGUICollection硬币收集管理的类\n\n\n### 4、DataManager数据管理\nUnity提供PlayerPrefs存储玩家的数据  \n\n### 5、GUIClickEventReceiver 点击事件的接收\n首先我们先看下项目是怎么实现事件点击的 然后看下其他的方法 然后稍微知道NGUI怎么实现点击的\n#### 5.1. 项目中响应点击\n1.这里用到了一个脚本叫做 GUIClickEventReceiver  然后项目中的所有button都挂载了这个脚本.\n![Alt text](./1502589610210.png)![Alt text](./1502589637210.png)\n2.NGUI的Button被点击了会响应这个Button挂载的脚本的OnClick函数\n3.所以，所有的button都会响应GUIClickEventReceiver  的OnClick函数  看到这个函数里面做了分发这些响应事件\n ![Alt text](./1502592120847.png)\n\n#### 5.2 NGUI响应事件的方法：http://www.xuanyusong.com/archives/2390\n这个链接里面用的事件和委托的方法就可以像观察着模式那样处理\n如果是本项目这样的就会在一个地方处理 不够解耦 但是又统一直观\n\n#### 5.3 NGUI响应事件:https://my.oschina.net/u/185335/blog/380414\n原理都在NGUI 的dll里面 \n\n\n### 6、GUIManager 界面管理\n这个界面管理也有点类似GUIClickEventReceiver 统一处理比较直观统一\n左边的图是MainScene里面的截图 包括所有的Panel 下一幅图是GUIManager里面的panel成员\n![Alt text](./1502592598574.png) ![Alt text](./1502592616992.png)\n\nshowGUI这个函数用来显示具体哪个面板的 在按钮响应分发用的挺多 点击一个按钮就打开相应的面板\n\n设置游戏UI 像分数这些：setInGameScore 金币数量：setInGameCoinCount  \n显示教程：showTutorial\n刷新分数：refreshStoreGUI\n\n### 7、InputController 输入管理\n需要了解下Unity 里面的Input\nhttp://blog.csdn.net/lingyun_blog/article/details/41451565\n\nUnity为我们预设了一些输入：\n![Alt text](./1502593455464.png) \n\n\n\n回到项目中的InputController，看到Update函数里面，用GetButtonUp判断是否点击了Jump函数 \n if (Input.GetButtonUp(\"Jump\")) {\n            playerController.jump(false);\n        }\n\n到此为止，这个类我们可以看到是怎么得到键盘鼠标的输入的 然后再这个类去把事件传给playerObeject 让它响应相应的动作\n\n\n### 8、MissionManager 关卡管理\n\n### 9、PowerUpManager 玩家buff管理类\n能力加强的管理类： DoubleCoin双倍金币, CoinMagnet金币磁铁, Invincibility无敌, SpeedIncrease加速, None\nactivatePowerUp激活哪个加强buff dataManager.getPowerUpLength(powerUpType);时间在DataManager里面配置\n用协程来实现加强buff的维持的时间\nactivatePowerUp函数激活 然后开始协程StartCoroutine(\"runPowerUp\");\nyield return new WaitForSeconds(activePowerUpData.duration);等待相应的时间 然后结束强化deactivatePowerUp();\n\n\n### 10、SocialManager社交管理\nFacebook Twitter的功能\n\n### 11、StaticData 静态数据\n在unityEditor里面设置\n\n### 12、玩家的转向跳跃\n这个要看这几个脚本PlayerController.cs InputController.cs 我们先确定一个重要的点：我们看到人物前进实际是把物体向后移动实现的，人物会相对当前位置跳跃 沿着Y轴移动\n##### 1、先看下InputController这个脚本 \n![Alt text](./1502593542093.png)\n看到 up按钮和space按钮都预设为跳\n![Alt text](./1502593562614.png)\n上面两张图是这个工程设置了按键对应的名称：Jump Slide LeftTurn\n\n下面我们分别说人物三类动作的响应函数\n这个是控制输入的\n（1）人物可以跳跃 下滑 攻击：\nInputController的Update()函数\n\n if (Input.GetButtonUp(\"Jump\")) {\n            playerController.jump(false);\n        } else if (Input.GetButtonUp(\"Slide\")) {\n            playerController.slide();\n        } else if (Input.GetButtonUp(\"Attack\")) {\n            playerController.attack();\n        }\n        \n（2）人物可以左转向 右转向\n（3）游戏中有三个轨道左中右轨道，左方向键可以向左移动到最左的轨道，右方向键可以向右移动到最右的轨道\n**（2）（3）的代码一起看**\nLeftTurn LeftSlot用的按键是同一个 都是a和左方向键 如果playerController.turn返回true就不会执行playerController.changeSlots代码了\n这里可以看出玩家左移用playerController.changeSlots代码 左转用playerController.turn\n\n\t\t\tif (Input.GetButtonUp(\"LeftTurn\")) {\n                hasTurned = playerController.turn(false, true);\n            } else if (Input.GetButtonUp(\"RightTurn\")) {\n                hasTurned = playerController.turn(true, true);\n            }\n\n            // can change slots if the player hasn't turned\n            if (!hasTurned) {\n                if (Input.GetButtonUp(\"LeftSlot\")) {\n                    playerController.changeSlots(false);\n                } else if (Input.GetButtonUp(\"RightSlot\")) {\n                    playerController.changeSlots(true);\n                }\n            }\n\n**playerController.changeSlots**\ninfiniteObjectGenerator.slotDistance这个是unity编辑器里面配置是2  两个跑道之间的距离是2\ntargetSlotValue = (int)currentSlotPosition * infiniteObjectGenerator.slotDistance;这个值就是目标的跑道的偏移\n这里更新目标位置\nupdateTargetPosition(targetRotation.eulerAngles.y);\n看下这个函数updateTargetPosition的这两句\ntargetPosition.x += targetSlotValue * Mathf.Cos(yAngle * Mathf.Deg2Rad);\n        targetPosition.z += targetSlotValue * -Mathf.Sin(yAngle * Mathf.Deg2Rad);\n把targetSlotValue 换算成左边偏倚 y轴的转向也就是人物中心轴转向 如果一开始游戏 Y转向是0度  那么Mathf.Cos(yAngle * Mathf.Deg2Rad)是1 -Mathf.Sin(yAngle * Mathf.Deg2Rad);是0 然后targetSlotValue 的偏移都是X的便宜 Z不用偏移 同理可以想像下 如果向左转了90 之后 偏移就\n\n**playerController.turn**\n1. 获取目标转向：Vector3 direction = platformObject.getTransform().right * (rightTurn ? 1 : -1);\n2. 得到目标的转向：targetRotation = Quaternion.LookRotation(direction);\n3. 然后在LateUpdate里面真正的插值转职到targetRotation\n\n        if (thisTransform.rotation != targetRotation) {\n            thisTransform.rotation = Quaternion.RotateTowards(thisTransform.rotation, targetRotation,Mathf.Lerp(slowRotationSpeed, fastRotationSpeed, Mathf.Clamp01(Quaternion.Angle(thisTransform.rotation, targetRotation) / 45)));\n        }\n        \n这里查下RotateTowards函数是旋转到目标角度 Mathf.Lerp函数是获得插值  插值就可以实现平滑的旋转\n### 13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\nMainScene里面有个Obeject叫InfiniteObject  这些无限的场景和物体都是在这个object下面\n\n![Alt text](./1502597632750.png)\n\n分成五类物体：\n（1）obstacles：障碍物 \n（2）scene：场景\n（3）powerups：强化道具\n（4）platforms：底板\n（5）coins：硬币\n\n#### 1、InfiniteObjectGenerator 生成器\n**函数入口，调用堆栈**：\n1. PlayerController::LateUpdate()\n2. InfiniteObjectGenerator::moveObjects()\n3. InfiniteObjectGenerator::spawnObjectRun()\n\n我们看下spawnObjectRun函数：\n\n有个函数在移动整个场景moveObjects  这个是被PlayerController的LateUpdate函数调用\nmoveObjects里面来调用spawnObjectRun  从而不断生成\n\n**我们看下moveObjects这个函数**\n1. for (int j = 0; j < (int)ObjectLocation.Last; ++j) {这个循环是移动所有的物体\n2. infiniteObject = infiniteObjectHistory.getTopTurnInfiniteObject(i == 0);这句获取第一个物体判断是否要销毁\n3. spawnObjectRun(true);这句调用了生成的函数\n\nspawnObjectRun这个函数的前半部分是生成路径 后半部分是生成一个转向\n\n## 附\nvs2015断调试unity项目\nhttp://www.itcast.cn/news/20151229/1437047587.shtml\n","source":"_posts/kupao.md","raw":"---\ntitle: 酷跑游戏\ndate: 2017-08-16 08:49:39\ntags: unity\nreward: true\n---\n\n\n## 一、对这个项目的初步认识：\n### 1、游戏跑起来是怎么样的：\n![Alt text](./demo.gif)\n\n<!-- more -->\n\n\n\n### 2、怎么打开这个工程\n#### 2.1工程下载：\n【附】：项目下载资料为网络搜集所得，仅供学习研究，严谨用于商业行为，请下载后于24小时之内删除。\n\n链接: http://pan.baidu.com/s/1bp5yiSn 密码: 6t4e\n\n#### 2.2怎么打开这个工程\n##### 1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:\n安装教程见我的博客：\nhttps://wlxklyh.github.io/2017/07/30/unity_study/\n\n##### 2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可 \n\n\n### 3、工程代码的结构\n![Alt text](./1502367185977.png)\n\n\n### 4、工程代码的入口\n![Alt text](./1502419665363.png)\n看到Game这个object挂载了很多的脚本组件\n![Alt text](./1502421000610.png)\n我们接下来会看这些代码，从名字来看 重点看GameManager DataManager Mission Manager GUIManager\n\n### 5、第三方库\nUI用了NGUI\n![Alt text](./1502589425321.png)\n\n## 二、阅读代码\n\n### 1、先看GameManager\n这个是游戏管理的类，从这里开始阅读，\n\n\n### 2、AudioManager音效管理\n音效的配置都在Unity编辑器里面配置这些音乐  见图片\n（看MainScene里面Game这个对象 里面挂载一个脚本组件AudioManager）\n![Alt text](./1502587224424.png)\n这个类比较脚本 提供两个接口给外部调用\nplayBackgroundMusic 播放背景音乐\nplaySoundEffect\t播放音效 这里用枚举列出了几种音效\n\n### 3、CoinGUICollection硬币收集管理的类\n\n\n### 4、DataManager数据管理\nUnity提供PlayerPrefs存储玩家的数据  \n\n### 5、GUIClickEventReceiver 点击事件的接收\n首先我们先看下项目是怎么实现事件点击的 然后看下其他的方法 然后稍微知道NGUI怎么实现点击的\n#### 5.1. 项目中响应点击\n1.这里用到了一个脚本叫做 GUIClickEventReceiver  然后项目中的所有button都挂载了这个脚本.\n![Alt text](./1502589610210.png)![Alt text](./1502589637210.png)\n2.NGUI的Button被点击了会响应这个Button挂载的脚本的OnClick函数\n3.所以，所有的button都会响应GUIClickEventReceiver  的OnClick函数  看到这个函数里面做了分发这些响应事件\n ![Alt text](./1502592120847.png)\n\n#### 5.2 NGUI响应事件的方法：http://www.xuanyusong.com/archives/2390\n这个链接里面用的事件和委托的方法就可以像观察着模式那样处理\n如果是本项目这样的就会在一个地方处理 不够解耦 但是又统一直观\n\n#### 5.3 NGUI响应事件:https://my.oschina.net/u/185335/blog/380414\n原理都在NGUI 的dll里面 \n\n\n### 6、GUIManager 界面管理\n这个界面管理也有点类似GUIClickEventReceiver 统一处理比较直观统一\n左边的图是MainScene里面的截图 包括所有的Panel 下一幅图是GUIManager里面的panel成员\n![Alt text](./1502592598574.png) ![Alt text](./1502592616992.png)\n\nshowGUI这个函数用来显示具体哪个面板的 在按钮响应分发用的挺多 点击一个按钮就打开相应的面板\n\n设置游戏UI 像分数这些：setInGameScore 金币数量：setInGameCoinCount  \n显示教程：showTutorial\n刷新分数：refreshStoreGUI\n\n### 7、InputController 输入管理\n需要了解下Unity 里面的Input\nhttp://blog.csdn.net/lingyun_blog/article/details/41451565\n\nUnity为我们预设了一些输入：\n![Alt text](./1502593455464.png) \n\n\n\n回到项目中的InputController，看到Update函数里面，用GetButtonUp判断是否点击了Jump函数 \n if (Input.GetButtonUp(\"Jump\")) {\n            playerController.jump(false);\n        }\n\n到此为止，这个类我们可以看到是怎么得到键盘鼠标的输入的 然后再这个类去把事件传给playerObeject 让它响应相应的动作\n\n\n### 8、MissionManager 关卡管理\n\n### 9、PowerUpManager 玩家buff管理类\n能力加强的管理类： DoubleCoin双倍金币, CoinMagnet金币磁铁, Invincibility无敌, SpeedIncrease加速, None\nactivatePowerUp激活哪个加强buff dataManager.getPowerUpLength(powerUpType);时间在DataManager里面配置\n用协程来实现加强buff的维持的时间\nactivatePowerUp函数激活 然后开始协程StartCoroutine(\"runPowerUp\");\nyield return new WaitForSeconds(activePowerUpData.duration);等待相应的时间 然后结束强化deactivatePowerUp();\n\n\n### 10、SocialManager社交管理\nFacebook Twitter的功能\n\n### 11、StaticData 静态数据\n在unityEditor里面设置\n\n### 12、玩家的转向跳跃\n这个要看这几个脚本PlayerController.cs InputController.cs 我们先确定一个重要的点：我们看到人物前进实际是把物体向后移动实现的，人物会相对当前位置跳跃 沿着Y轴移动\n##### 1、先看下InputController这个脚本 \n![Alt text](./1502593542093.png)\n看到 up按钮和space按钮都预设为跳\n![Alt text](./1502593562614.png)\n上面两张图是这个工程设置了按键对应的名称：Jump Slide LeftTurn\n\n下面我们分别说人物三类动作的响应函数\n这个是控制输入的\n（1）人物可以跳跃 下滑 攻击：\nInputController的Update()函数\n\n if (Input.GetButtonUp(\"Jump\")) {\n            playerController.jump(false);\n        } else if (Input.GetButtonUp(\"Slide\")) {\n            playerController.slide();\n        } else if (Input.GetButtonUp(\"Attack\")) {\n            playerController.attack();\n        }\n        \n（2）人物可以左转向 右转向\n（3）游戏中有三个轨道左中右轨道，左方向键可以向左移动到最左的轨道，右方向键可以向右移动到最右的轨道\n**（2）（3）的代码一起看**\nLeftTurn LeftSlot用的按键是同一个 都是a和左方向键 如果playerController.turn返回true就不会执行playerController.changeSlots代码了\n这里可以看出玩家左移用playerController.changeSlots代码 左转用playerController.turn\n\n\t\t\tif (Input.GetButtonUp(\"LeftTurn\")) {\n                hasTurned = playerController.turn(false, true);\n            } else if (Input.GetButtonUp(\"RightTurn\")) {\n                hasTurned = playerController.turn(true, true);\n            }\n\n            // can change slots if the player hasn't turned\n            if (!hasTurned) {\n                if (Input.GetButtonUp(\"LeftSlot\")) {\n                    playerController.changeSlots(false);\n                } else if (Input.GetButtonUp(\"RightSlot\")) {\n                    playerController.changeSlots(true);\n                }\n            }\n\n**playerController.changeSlots**\ninfiniteObjectGenerator.slotDistance这个是unity编辑器里面配置是2  两个跑道之间的距离是2\ntargetSlotValue = (int)currentSlotPosition * infiniteObjectGenerator.slotDistance;这个值就是目标的跑道的偏移\n这里更新目标位置\nupdateTargetPosition(targetRotation.eulerAngles.y);\n看下这个函数updateTargetPosition的这两句\ntargetPosition.x += targetSlotValue * Mathf.Cos(yAngle * Mathf.Deg2Rad);\n        targetPosition.z += targetSlotValue * -Mathf.Sin(yAngle * Mathf.Deg2Rad);\n把targetSlotValue 换算成左边偏倚 y轴的转向也就是人物中心轴转向 如果一开始游戏 Y转向是0度  那么Mathf.Cos(yAngle * Mathf.Deg2Rad)是1 -Mathf.Sin(yAngle * Mathf.Deg2Rad);是0 然后targetSlotValue 的偏移都是X的便宜 Z不用偏移 同理可以想像下 如果向左转了90 之后 偏移就\n\n**playerController.turn**\n1. 获取目标转向：Vector3 direction = platformObject.getTransform().right * (rightTurn ? 1 : -1);\n2. 得到目标的转向：targetRotation = Quaternion.LookRotation(direction);\n3. 然后在LateUpdate里面真正的插值转职到targetRotation\n\n        if (thisTransform.rotation != targetRotation) {\n            thisTransform.rotation = Quaternion.RotateTowards(thisTransform.rotation, targetRotation,Mathf.Lerp(slowRotationSpeed, fastRotationSpeed, Mathf.Clamp01(Quaternion.Angle(thisTransform.rotation, targetRotation) / 45)));\n        }\n        \n这里查下RotateTowards函数是旋转到目标角度 Mathf.Lerp函数是获得插值  插值就可以实现平滑的旋转\n### 13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\nMainScene里面有个Obeject叫InfiniteObject  这些无限的场景和物体都是在这个object下面\n\n![Alt text](./1502597632750.png)\n\n分成五类物体：\n（1）obstacles：障碍物 \n（2）scene：场景\n（3）powerups：强化道具\n（4）platforms：底板\n（5）coins：硬币\n\n#### 1、InfiniteObjectGenerator 生成器\n**函数入口，调用堆栈**：\n1. PlayerController::LateUpdate()\n2. InfiniteObjectGenerator::moveObjects()\n3. InfiniteObjectGenerator::spawnObjectRun()\n\n我们看下spawnObjectRun函数：\n\n有个函数在移动整个场景moveObjects  这个是被PlayerController的LateUpdate函数调用\nmoveObjects里面来调用spawnObjectRun  从而不断生成\n\n**我们看下moveObjects这个函数**\n1. for (int j = 0; j < (int)ObjectLocation.Last; ++j) {这个循环是移动所有的物体\n2. infiniteObject = infiniteObjectHistory.getTopTurnInfiniteObject(i == 0);这句获取第一个物体判断是否要销毁\n3. spawnObjectRun(true);这句调用了生成的函数\n\nspawnObjectRun这个函数的前半部分是生成路径 后半部分是生成一个转向\n\n## 附\nvs2015断调试unity项目\nhttp://www.itcast.cn/news/20151229/1437047587.shtml\n","slug":"kupao","published":1,"updated":"2018-05-11T10:13:52.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o4y0002znmjzwmze8cw","content":"<h2 id=\"一、对这个项目的初步认识：\"><a href=\"#一、对这个项目的初步认识：\" class=\"headerlink\" title=\"一、对这个项目的初步认识：\"></a>一、对这个项目的初步认识：</h2><h3 id=\"1、游戏跑起来是怎么样的：\"><a href=\"#1、游戏跑起来是怎么样的：\" class=\"headerlink\" title=\"1、游戏跑起来是怎么样的：\"></a>1、游戏跑起来是怎么样的：</h3><p><img src=\"/2017/08/16/kupao/demo.gif\" alt=\"Alt text\"></p>\n<a id=\"more\"></a>\n<h3 id=\"2、怎么打开这个工程\"><a href=\"#2、怎么打开这个工程\" class=\"headerlink\" title=\"2、怎么打开这个工程\"></a>2、怎么打开这个工程</h3><h4 id=\"2-1工程下载：\"><a href=\"#2-1工程下载：\" class=\"headerlink\" title=\"2.1工程下载：\"></a>2.1工程下载：</h4><p>【附】：项目下载资料为网络搜集所得，仅供学习研究，严谨用于商业行为，请下载后于24小时之内删除。</p>\n<p>链接: <a href=\"http://pan.baidu.com/s/1bp5yiSn\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1bp5yiSn</a> 密码: 6t4e</p>\n<h4 id=\"2-2怎么打开这个工程\"><a href=\"#2-2怎么打开这个工程\" class=\"headerlink\" title=\"2.2怎么打开这个工程\"></a>2.2怎么打开这个工程</h4><h5 id=\"1、安装unity-（mac上面打开会有问题-我在windows-unity-4-7版本打开）\"><a href=\"#1、安装unity-（mac上面打开会有问题-我在windows-unity-4-7版本打开）\" class=\"headerlink\" title=\"1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:\"></a>1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:</h5><p>安装教程见我的博客：<br><a href=\"https://wlxklyh.github.io/2017/07/30/unity_study/\" target=\"_blank\" rel=\"external\">https://wlxklyh.github.io/2017/07/30/unity_study/</a></p>\n<h5 id=\"2、新建一个工程-然后双击下载到的unitypackage就会导入-之后打开MainScene-然后点击运行即可\"><a href=\"#2、新建一个工程-然后双击下载到的unitypackage就会导入-之后打开MainScene-然后点击运行即可\" class=\"headerlink\" title=\"2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可\"></a>2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可</h5><h3 id=\"3、工程代码的结构\"><a href=\"#3、工程代码的结构\" class=\"headerlink\" title=\"3、工程代码的结构\"></a>3、工程代码的结构</h3><p><img src=\"/2017/08/16/kupao/1502367185977.png\" alt=\"Alt text\"></p>\n<h3 id=\"4、工程代码的入口\"><a href=\"#4、工程代码的入口\" class=\"headerlink\" title=\"4、工程代码的入口\"></a>4、工程代码的入口</h3><p><img src=\"/2017/08/16/kupao/1502419665363.png\" alt=\"Alt text\"><br>看到Game这个object挂载了很多的脚本组件<br><img src=\"/2017/08/16/kupao/1502421000610.png\" alt=\"Alt text\"><br>我们接下来会看这些代码，从名字来看 重点看GameManager DataManager Mission Manager GUIManager</p>\n<h3 id=\"5、第三方库\"><a href=\"#5、第三方库\" class=\"headerlink\" title=\"5、第三方库\"></a>5、第三方库</h3><p>UI用了NGUI<br><img src=\"/2017/08/16/kupao/1502589425321.png\" alt=\"Alt text\"></p>\n<h2 id=\"二、阅读代码\"><a href=\"#二、阅读代码\" class=\"headerlink\" title=\"二、阅读代码\"></a>二、阅读代码</h2><h3 id=\"1、先看GameManager\"><a href=\"#1、先看GameManager\" class=\"headerlink\" title=\"1、先看GameManager\"></a>1、先看GameManager</h3><p>这个是游戏管理的类，从这里开始阅读，</p>\n<h3 id=\"2、AudioManager音效管理\"><a href=\"#2、AudioManager音效管理\" class=\"headerlink\" title=\"2、AudioManager音效管理\"></a>2、AudioManager音效管理</h3><p>音效的配置都在Unity编辑器里面配置这些音乐  见图片<br>（看MainScene里面Game这个对象 里面挂载一个脚本组件AudioManager）<br><img src=\"/2017/08/16/kupao/1502587224424.png\" alt=\"Alt text\"><br>这个类比较脚本 提供两个接口给外部调用<br>playBackgroundMusic 播放背景音乐<br>playSoundEffect    播放音效 这里用枚举列出了几种音效</p>\n<h3 id=\"3、CoinGUICollection硬币收集管理的类\"><a href=\"#3、CoinGUICollection硬币收集管理的类\" class=\"headerlink\" title=\"3、CoinGUICollection硬币收集管理的类\"></a>3、CoinGUICollection硬币收集管理的类</h3><h3 id=\"4、DataManager数据管理\"><a href=\"#4、DataManager数据管理\" class=\"headerlink\" title=\"4、DataManager数据管理\"></a>4、DataManager数据管理</h3><p>Unity提供PlayerPrefs存储玩家的数据  </p>\n<h3 id=\"5、GUIClickEventReceiver-点击事件的接收\"><a href=\"#5、GUIClickEventReceiver-点击事件的接收\" class=\"headerlink\" title=\"5、GUIClickEventReceiver 点击事件的接收\"></a>5、GUIClickEventReceiver 点击事件的接收</h3><p>首先我们先看下项目是怎么实现事件点击的 然后看下其他的方法 然后稍微知道NGUI怎么实现点击的</p>\n<h4 id=\"5-1-项目中响应点击\"><a href=\"#5-1-项目中响应点击\" class=\"headerlink\" title=\"5.1. 项目中响应点击\"></a>5.1. 项目中响应点击</h4><p>1.这里用到了一个脚本叫做 GUIClickEventReceiver  然后项目中的所有button都挂载了这个脚本.<br><img src=\"/2017/08/16/kupao/1502589610210.png\" alt=\"Alt text\"><img src=\"/2017/08/16/kupao/1502589637210.png\" alt=\"Alt text\"><br>2.NGUI的Button被点击了会响应这个Button挂载的脚本的OnClick函数<br>3.所以，所有的button都会响应GUIClickEventReceiver  的OnClick函数  看到这个函数里面做了分发这些响应事件<br> <img src=\"/2017/08/16/kupao/1502592120847.png\" alt=\"Alt text\"></p>\n<h4 id=\"5-2-NGUI响应事件的方法：http-www-xuanyusong-com-archives-2390\"><a href=\"#5-2-NGUI响应事件的方法：http-www-xuanyusong-com-archives-2390\" class=\"headerlink\" title=\"5.2 NGUI响应事件的方法：http://www.xuanyusong.com/archives/2390\"></a>5.2 NGUI响应事件的方法：<a href=\"http://www.xuanyusong.com/archives/2390\" target=\"_blank\" rel=\"external\">http://www.xuanyusong.com/archives/2390</a></h4><p>这个链接里面用的事件和委托的方法就可以像观察着模式那样处理<br>如果是本项目这样的就会在一个地方处理 不够解耦 但是又统一直观</p>\n<h4 id=\"5-3-NGUI响应事件-https-my-oschina-net-u-185335-blog-380414\"><a href=\"#5-3-NGUI响应事件-https-my-oschina-net-u-185335-blog-380414\" class=\"headerlink\" title=\"5.3 NGUI响应事件:https://my.oschina.net/u/185335/blog/380414\"></a>5.3 NGUI响应事件:<a href=\"https://my.oschina.net/u/185335/blog/380414\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/185335/blog/380414</a></h4><p>原理都在NGUI 的dll里面 </p>\n<h3 id=\"6、GUIManager-界面管理\"><a href=\"#6、GUIManager-界面管理\" class=\"headerlink\" title=\"6、GUIManager 界面管理\"></a>6、GUIManager 界面管理</h3><p>这个界面管理也有点类似GUIClickEventReceiver 统一处理比较直观统一<br>左边的图是MainScene里面的截图 包括所有的Panel 下一幅图是GUIManager里面的panel成员<br><img src=\"/2017/08/16/kupao/1502592598574.png\" alt=\"Alt text\"> <img src=\"/2017/08/16/kupao/1502592616992.png\" alt=\"Alt text\"></p>\n<p>showGUI这个函数用来显示具体哪个面板的 在按钮响应分发用的挺多 点击一个按钮就打开相应的面板</p>\n<p>设置游戏UI 像分数这些：setInGameScore 金币数量：setInGameCoinCount<br>显示教程：showTutorial<br>刷新分数：refreshStoreGUI</p>\n<h3 id=\"7、InputController-输入管理\"><a href=\"#7、InputController-输入管理\" class=\"headerlink\" title=\"7、InputController 输入管理\"></a>7、InputController 输入管理</h3><p>需要了解下Unity 里面的Input<br><a href=\"http://blog.csdn.net/lingyun_blog/article/details/41451565\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lingyun_blog/article/details/41451565</a></p>\n<p>Unity为我们预设了一些输入：<br><img src=\"/2017/08/16/kupao/1502593455464.png\" alt=\"Alt text\"> </p>\n<p>回到项目中的InputController，看到Update函数里面，用GetButtonUp判断是否点击了Jump函数<br> if (Input.GetButtonUp(“Jump”)) {<br>            playerController.jump(false);<br>        }</p>\n<p>到此为止，这个类我们可以看到是怎么得到键盘鼠标的输入的 然后再这个类去把事件传给playerObeject 让它响应相应的动作</p>\n<h3 id=\"8、MissionManager-关卡管理\"><a href=\"#8、MissionManager-关卡管理\" class=\"headerlink\" title=\"8、MissionManager 关卡管理\"></a>8、MissionManager 关卡管理</h3><h3 id=\"9、PowerUpManager-玩家buff管理类\"><a href=\"#9、PowerUpManager-玩家buff管理类\" class=\"headerlink\" title=\"9、PowerUpManager 玩家buff管理类\"></a>9、PowerUpManager 玩家buff管理类</h3><p>能力加强的管理类： DoubleCoin双倍金币, CoinMagnet金币磁铁, Invincibility无敌, SpeedIncrease加速, None<br>activatePowerUp激活哪个加强buff dataManager.getPowerUpLength(powerUpType);时间在DataManager里面配置<br>用协程来实现加强buff的维持的时间<br>activatePowerUp函数激活 然后开始协程StartCoroutine(“runPowerUp”);<br>yield return new WaitForSeconds(activePowerUpData.duration);等待相应的时间 然后结束强化deactivatePowerUp();</p>\n<h3 id=\"10、SocialManager社交管理\"><a href=\"#10、SocialManager社交管理\" class=\"headerlink\" title=\"10、SocialManager社交管理\"></a>10、SocialManager社交管理</h3><p>Facebook Twitter的功能</p>\n<h3 id=\"11、StaticData-静态数据\"><a href=\"#11、StaticData-静态数据\" class=\"headerlink\" title=\"11、StaticData 静态数据\"></a>11、StaticData 静态数据</h3><p>在unityEditor里面设置</p>\n<h3 id=\"12、玩家的转向跳跃\"><a href=\"#12、玩家的转向跳跃\" class=\"headerlink\" title=\"12、玩家的转向跳跃\"></a>12、玩家的转向跳跃</h3><p>这个要看这几个脚本PlayerController.cs InputController.cs 我们先确定一个重要的点：我们看到人物前进实际是把物体向后移动实现的，人物会相对当前位置跳跃 沿着Y轴移动</p>\n<h5 id=\"1、先看下InputController这个脚本\"><a href=\"#1、先看下InputController这个脚本\" class=\"headerlink\" title=\"1、先看下InputController这个脚本\"></a>1、先看下InputController这个脚本</h5><p><img src=\"/2017/08/16/kupao/1502593542093.png\" alt=\"Alt text\"><br>看到 up按钮和space按钮都预设为跳<br><img src=\"/2017/08/16/kupao/1502593562614.png\" alt=\"Alt text\"><br>上面两张图是这个工程设置了按键对应的名称：Jump Slide LeftTurn</p>\n<p>下面我们分别说人物三类动作的响应函数<br>这个是控制输入的<br>（1）人物可以跳跃 下滑 攻击：<br>InputController的Update()函数</p>\n<p> if (Input.GetButtonUp(“Jump”)) {<br>            playerController.jump(false);<br>        } else if (Input.GetButtonUp(“Slide”)) {<br>            playerController.slide();<br>        } else if (Input.GetButtonUp(“Attack”)) {<br>            playerController.attack();<br>        }</p>\n<p>（2）人物可以左转向 右转向<br>（3）游戏中有三个轨道左中右轨道，左方向键可以向左移动到最左的轨道，右方向键可以向右移动到最右的轨道<br><strong>（2）（3）的代码一起看</strong><br>LeftTurn LeftSlot用的按键是同一个 都是a和左方向键 如果playerController.turn返回true就不会执行playerController.changeSlots代码了<br>这里可以看出玩家左移用playerController.changeSlots代码 左转用playerController.turn</p>\n<pre><code>if (Input.GetButtonUp(&quot;LeftTurn&quot;)) {\n    hasTurned = playerController.turn(false, true);\n} else if (Input.GetButtonUp(&quot;RightTurn&quot;)) {\n    hasTurned = playerController.turn(true, true);\n}\n\n// can change slots if the player hasn&apos;t turned\nif (!hasTurned) {\n    if (Input.GetButtonUp(&quot;LeftSlot&quot;)) {\n        playerController.changeSlots(false);\n    } else if (Input.GetButtonUp(&quot;RightSlot&quot;)) {\n        playerController.changeSlots(true);\n    }\n}\n</code></pre><p><strong>playerController.changeSlots</strong><br>infiniteObjectGenerator.slotDistance这个是unity编辑器里面配置是2  两个跑道之间的距离是2<br>targetSlotValue = (int)currentSlotPosition <em> infiniteObjectGenerator.slotDistance;这个值就是目标的跑道的偏移<br>这里更新目标位置<br>updateTargetPosition(targetRotation.eulerAngles.y);<br>看下这个函数updateTargetPosition的这两句<br>targetPosition.x += targetSlotValue </em> Mathf.Cos(yAngle <em> Mathf.Deg2Rad);<br>        targetPosition.z += targetSlotValue </em> -Mathf.Sin(yAngle <em> Mathf.Deg2Rad);<br>把targetSlotValue 换算成左边偏倚 y轴的转向也就是人物中心轴转向 如果一开始游戏 Y转向是0度  那么Mathf.Cos(yAngle </em> Mathf.Deg2Rad)是1 -Mathf.Sin(yAngle * Mathf.Deg2Rad);是0 然后targetSlotValue 的偏移都是X的便宜 Z不用偏移 同理可以想像下 如果向左转了90 之后 偏移就</p>\n<p><strong>playerController.turn</strong></p>\n<ol>\n<li>获取目标转向：Vector3 direction = platformObject.getTransform().right * (rightTurn ? 1 : -1);</li>\n<li>得到目标的转向：targetRotation = Quaternion.LookRotation(direction);</li>\n<li><p>然后在LateUpdate里面真正的插值转职到targetRotation</p>\n<pre><code>if (thisTransform.rotation != targetRotation) {\n    thisTransform.rotation = Quaternion.RotateTowards(thisTransform.rotation, targetRotation,Mathf.Lerp(slowRotationSpeed, fastRotationSpeed, Mathf.Clamp01(Quaternion.Angle(thisTransform.rotation, targetRotation) / 45)));\n}\n</code></pre></li>\n</ol>\n<p>这里查下RotateTowards函数是旋转到目标角度 Mathf.Lerp函数是获得插值  插值就可以实现平滑的旋转</p>\n<h3 id=\"13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\"><a href=\"#13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\" class=\"headerlink\" title=\"13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\"></a>13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本</h3><p>MainScene里面有个Obeject叫InfiniteObject  这些无限的场景和物体都是在这个object下面</p>\n<p><img src=\"/2017/08/16/kupao/1502597632750.png\" alt=\"Alt text\"></p>\n<p>分成五类物体：<br>（1）obstacles：障碍物<br>（2）scene：场景<br>（3）powerups：强化道具<br>（4）platforms：底板<br>（5）coins：硬币</p>\n<h4 id=\"1、InfiniteObjectGenerator-生成器\"><a href=\"#1、InfiniteObjectGenerator-生成器\" class=\"headerlink\" title=\"1、InfiniteObjectGenerator 生成器\"></a>1、InfiniteObjectGenerator 生成器</h4><p><strong>函数入口，调用堆栈</strong>：</p>\n<ol>\n<li>PlayerController::LateUpdate()</li>\n<li>InfiniteObjectGenerator::moveObjects()</li>\n<li>InfiniteObjectGenerator::spawnObjectRun()</li>\n</ol>\n<p>我们看下spawnObjectRun函数：</p>\n<p>有个函数在移动整个场景moveObjects  这个是被PlayerController的LateUpdate函数调用<br>moveObjects里面来调用spawnObjectRun  从而不断生成</p>\n<p><strong>我们看下moveObjects这个函数</strong></p>\n<ol>\n<li>for (int j = 0; j &lt; (int)ObjectLocation.Last; ++j) {这个循环是移动所有的物体</li>\n<li>infiniteObject = infiniteObjectHistory.getTopTurnInfiniteObject(i == 0);这句获取第一个物体判断是否要销毁</li>\n<li>spawnObjectRun(true);这句调用了生成的函数</li>\n</ol>\n<p>spawnObjectRun这个函数的前半部分是生成路径 后半部分是生成一个转向</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>vs2015断调试unity项目<br><a href=\"http://www.itcast.cn/news/20151229/1437047587.shtml\" target=\"_blank\" rel=\"external\">http://www.itcast.cn/news/20151229/1437047587.shtml</a></p>\n","excerpt":"<h2 id=\"一、对这个项目的初步认识：\"><a href=\"#一、对这个项目的初步认识：\" class=\"headerlink\" title=\"一、对这个项目的初步认识：\"></a>一、对这个项目的初步认识：</h2><h3 id=\"1、游戏跑起来是怎么样的：\"><a href=\"#1、游戏跑起来是怎么样的：\" class=\"headerlink\" title=\"1、游戏跑起来是怎么样的：\"></a>1、游戏跑起来是怎么样的：</h3><p><img src=\"/2017/08/16/kupao/demo.gif\" alt=\"Alt text\"></p>","more":"<h3 id=\"2、怎么打开这个工程\"><a href=\"#2、怎么打开这个工程\" class=\"headerlink\" title=\"2、怎么打开这个工程\"></a>2、怎么打开这个工程</h3><h4 id=\"2-1工程下载：\"><a href=\"#2-1工程下载：\" class=\"headerlink\" title=\"2.1工程下载：\"></a>2.1工程下载：</h4><p>【附】：项目下载资料为网络搜集所得，仅供学习研究，严谨用于商业行为，请下载后于24小时之内删除。</p>\n<p>链接: <a href=\"http://pan.baidu.com/s/1bp5yiSn\">http://pan.baidu.com/s/1bp5yiSn</a> 密码: 6t4e</p>\n<h4 id=\"2-2怎么打开这个工程\"><a href=\"#2-2怎么打开这个工程\" class=\"headerlink\" title=\"2.2怎么打开这个工程\"></a>2.2怎么打开这个工程</h4><h5 id=\"1、安装unity-（mac上面打开会有问题-我在windows-unity-4-7版本打开）\"><a href=\"#1、安装unity-（mac上面打开会有问题-我在windows-unity-4-7版本打开）\" class=\"headerlink\" title=\"1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:\"></a>1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:</h5><p>安装教程见我的博客：<br><a href=\"https://wlxklyh.github.io/2017/07/30/unity_study/\">https://wlxklyh.github.io/2017/07/30/unity_study/</a></p>\n<h5 id=\"2、新建一个工程-然后双击下载到的unitypackage就会导入-之后打开MainScene-然后点击运行即可\"><a href=\"#2、新建一个工程-然后双击下载到的unitypackage就会导入-之后打开MainScene-然后点击运行即可\" class=\"headerlink\" title=\"2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可\"></a>2、新建一个工程  然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可</h5><h3 id=\"3、工程代码的结构\"><a href=\"#3、工程代码的结构\" class=\"headerlink\" title=\"3、工程代码的结构\"></a>3、工程代码的结构</h3><p><img src=\"/2017/08/16/kupao/1502367185977.png\" alt=\"Alt text\"></p>\n<h3 id=\"4、工程代码的入口\"><a href=\"#4、工程代码的入口\" class=\"headerlink\" title=\"4、工程代码的入口\"></a>4、工程代码的入口</h3><p><img src=\"/2017/08/16/kupao/1502419665363.png\" alt=\"Alt text\"><br>看到Game这个object挂载了很多的脚本组件<br><img src=\"/2017/08/16/kupao/1502421000610.png\" alt=\"Alt text\"><br>我们接下来会看这些代码，从名字来看 重点看GameManager DataManager Mission Manager GUIManager</p>\n<h3 id=\"5、第三方库\"><a href=\"#5、第三方库\" class=\"headerlink\" title=\"5、第三方库\"></a>5、第三方库</h3><p>UI用了NGUI<br><img src=\"/2017/08/16/kupao/1502589425321.png\" alt=\"Alt text\"></p>\n<h2 id=\"二、阅读代码\"><a href=\"#二、阅读代码\" class=\"headerlink\" title=\"二、阅读代码\"></a>二、阅读代码</h2><h3 id=\"1、先看GameManager\"><a href=\"#1、先看GameManager\" class=\"headerlink\" title=\"1、先看GameManager\"></a>1、先看GameManager</h3><p>这个是游戏管理的类，从这里开始阅读，</p>\n<h3 id=\"2、AudioManager音效管理\"><a href=\"#2、AudioManager音效管理\" class=\"headerlink\" title=\"2、AudioManager音效管理\"></a>2、AudioManager音效管理</h3><p>音效的配置都在Unity编辑器里面配置这些音乐  见图片<br>（看MainScene里面Game这个对象 里面挂载一个脚本组件AudioManager）<br><img src=\"/2017/08/16/kupao/1502587224424.png\" alt=\"Alt text\"><br>这个类比较脚本 提供两个接口给外部调用<br>playBackgroundMusic 播放背景音乐<br>playSoundEffect    播放音效 这里用枚举列出了几种音效</p>\n<h3 id=\"3、CoinGUICollection硬币收集管理的类\"><a href=\"#3、CoinGUICollection硬币收集管理的类\" class=\"headerlink\" title=\"3、CoinGUICollection硬币收集管理的类\"></a>3、CoinGUICollection硬币收集管理的类</h3><h3 id=\"4、DataManager数据管理\"><a href=\"#4、DataManager数据管理\" class=\"headerlink\" title=\"4、DataManager数据管理\"></a>4、DataManager数据管理</h3><p>Unity提供PlayerPrefs存储玩家的数据  </p>\n<h3 id=\"5、GUIClickEventReceiver-点击事件的接收\"><a href=\"#5、GUIClickEventReceiver-点击事件的接收\" class=\"headerlink\" title=\"5、GUIClickEventReceiver 点击事件的接收\"></a>5、GUIClickEventReceiver 点击事件的接收</h3><p>首先我们先看下项目是怎么实现事件点击的 然后看下其他的方法 然后稍微知道NGUI怎么实现点击的</p>\n<h4 id=\"5-1-项目中响应点击\"><a href=\"#5-1-项目中响应点击\" class=\"headerlink\" title=\"5.1. 项目中响应点击\"></a>5.1. 项目中响应点击</h4><p>1.这里用到了一个脚本叫做 GUIClickEventReceiver  然后项目中的所有button都挂载了这个脚本.<br><img src=\"/2017/08/16/kupao/1502589610210.png\" alt=\"Alt text\"><img src=\"/2017/08/16/kupao/1502589637210.png\" alt=\"Alt text\"><br>2.NGUI的Button被点击了会响应这个Button挂载的脚本的OnClick函数<br>3.所以，所有的button都会响应GUIClickEventReceiver  的OnClick函数  看到这个函数里面做了分发这些响应事件<br> <img src=\"/2017/08/16/kupao/1502592120847.png\" alt=\"Alt text\"></p>\n<h4 id=\"5-2-NGUI响应事件的方法：http-www-xuanyusong-com-archives-2390\"><a href=\"#5-2-NGUI响应事件的方法：http-www-xuanyusong-com-archives-2390\" class=\"headerlink\" title=\"5.2 NGUI响应事件的方法：http://www.xuanyusong.com/archives/2390\"></a>5.2 NGUI响应事件的方法：<a href=\"http://www.xuanyusong.com/archives/2390\">http://www.xuanyusong.com/archives/2390</a></h4><p>这个链接里面用的事件和委托的方法就可以像观察着模式那样处理<br>如果是本项目这样的就会在一个地方处理 不够解耦 但是又统一直观</p>\n<h4 id=\"5-3-NGUI响应事件-https-my-oschina-net-u-185335-blog-380414\"><a href=\"#5-3-NGUI响应事件-https-my-oschina-net-u-185335-blog-380414\" class=\"headerlink\" title=\"5.3 NGUI响应事件:https://my.oschina.net/u/185335/blog/380414\"></a>5.3 NGUI响应事件:<a href=\"https://my.oschina.net/u/185335/blog/380414\">https://my.oschina.net/u/185335/blog/380414</a></h4><p>原理都在NGUI 的dll里面 </p>\n<h3 id=\"6、GUIManager-界面管理\"><a href=\"#6、GUIManager-界面管理\" class=\"headerlink\" title=\"6、GUIManager 界面管理\"></a>6、GUIManager 界面管理</h3><p>这个界面管理也有点类似GUIClickEventReceiver 统一处理比较直观统一<br>左边的图是MainScene里面的截图 包括所有的Panel 下一幅图是GUIManager里面的panel成员<br><img src=\"/2017/08/16/kupao/1502592598574.png\" alt=\"Alt text\"> <img src=\"/2017/08/16/kupao/1502592616992.png\" alt=\"Alt text\"></p>\n<p>showGUI这个函数用来显示具体哪个面板的 在按钮响应分发用的挺多 点击一个按钮就打开相应的面板</p>\n<p>设置游戏UI 像分数这些：setInGameScore 金币数量：setInGameCoinCount<br>显示教程：showTutorial<br>刷新分数：refreshStoreGUI</p>\n<h3 id=\"7、InputController-输入管理\"><a href=\"#7、InputController-输入管理\" class=\"headerlink\" title=\"7、InputController 输入管理\"></a>7、InputController 输入管理</h3><p>需要了解下Unity 里面的Input<br><a href=\"http://blog.csdn.net/lingyun_blog/article/details/41451565\">http://blog.csdn.net/lingyun_blog/article/details/41451565</a></p>\n<p>Unity为我们预设了一些输入：<br><img src=\"/2017/08/16/kupao/1502593455464.png\" alt=\"Alt text\"> </p>\n<p>回到项目中的InputController，看到Update函数里面，用GetButtonUp判断是否点击了Jump函数<br> if (Input.GetButtonUp(“Jump”)) {<br>            playerController.jump(false);<br>        }</p>\n<p>到此为止，这个类我们可以看到是怎么得到键盘鼠标的输入的 然后再这个类去把事件传给playerObeject 让它响应相应的动作</p>\n<h3 id=\"8、MissionManager-关卡管理\"><a href=\"#8、MissionManager-关卡管理\" class=\"headerlink\" title=\"8、MissionManager 关卡管理\"></a>8、MissionManager 关卡管理</h3><h3 id=\"9、PowerUpManager-玩家buff管理类\"><a href=\"#9、PowerUpManager-玩家buff管理类\" class=\"headerlink\" title=\"9、PowerUpManager 玩家buff管理类\"></a>9、PowerUpManager 玩家buff管理类</h3><p>能力加强的管理类： DoubleCoin双倍金币, CoinMagnet金币磁铁, Invincibility无敌, SpeedIncrease加速, None<br>activatePowerUp激活哪个加强buff dataManager.getPowerUpLength(powerUpType);时间在DataManager里面配置<br>用协程来实现加强buff的维持的时间<br>activatePowerUp函数激活 然后开始协程StartCoroutine(“runPowerUp”);<br>yield return new WaitForSeconds(activePowerUpData.duration);等待相应的时间 然后结束强化deactivatePowerUp();</p>\n<h3 id=\"10、SocialManager社交管理\"><a href=\"#10、SocialManager社交管理\" class=\"headerlink\" title=\"10、SocialManager社交管理\"></a>10、SocialManager社交管理</h3><p>Facebook Twitter的功能</p>\n<h3 id=\"11、StaticData-静态数据\"><a href=\"#11、StaticData-静态数据\" class=\"headerlink\" title=\"11、StaticData 静态数据\"></a>11、StaticData 静态数据</h3><p>在unityEditor里面设置</p>\n<h3 id=\"12、玩家的转向跳跃\"><a href=\"#12、玩家的转向跳跃\" class=\"headerlink\" title=\"12、玩家的转向跳跃\"></a>12、玩家的转向跳跃</h3><p>这个要看这几个脚本PlayerController.cs InputController.cs 我们先确定一个重要的点：我们看到人物前进实际是把物体向后移动实现的，人物会相对当前位置跳跃 沿着Y轴移动</p>\n<h5 id=\"1、先看下InputController这个脚本\"><a href=\"#1、先看下InputController这个脚本\" class=\"headerlink\" title=\"1、先看下InputController这个脚本\"></a>1、先看下InputController这个脚本</h5><p><img src=\"/2017/08/16/kupao/1502593542093.png\" alt=\"Alt text\"><br>看到 up按钮和space按钮都预设为跳<br><img src=\"/2017/08/16/kupao/1502593562614.png\" alt=\"Alt text\"><br>上面两张图是这个工程设置了按键对应的名称：Jump Slide LeftTurn</p>\n<p>下面我们分别说人物三类动作的响应函数<br>这个是控制输入的<br>（1）人物可以跳跃 下滑 攻击：<br>InputController的Update()函数</p>\n<p> if (Input.GetButtonUp(“Jump”)) {<br>            playerController.jump(false);<br>        } else if (Input.GetButtonUp(“Slide”)) {<br>            playerController.slide();<br>        } else if (Input.GetButtonUp(“Attack”)) {<br>            playerController.attack();<br>        }</p>\n<p>（2）人物可以左转向 右转向<br>（3）游戏中有三个轨道左中右轨道，左方向键可以向左移动到最左的轨道，右方向键可以向右移动到最右的轨道<br><strong>（2）（3）的代码一起看</strong><br>LeftTurn LeftSlot用的按键是同一个 都是a和左方向键 如果playerController.turn返回true就不会执行playerController.changeSlots代码了<br>这里可以看出玩家左移用playerController.changeSlots代码 左转用playerController.turn</p>\n<pre><code>if (Input.GetButtonUp(&quot;LeftTurn&quot;)) {\n    hasTurned = playerController.turn(false, true);\n} else if (Input.GetButtonUp(&quot;RightTurn&quot;)) {\n    hasTurned = playerController.turn(true, true);\n}\n\n// can change slots if the player hasn&apos;t turned\nif (!hasTurned) {\n    if (Input.GetButtonUp(&quot;LeftSlot&quot;)) {\n        playerController.changeSlots(false);\n    } else if (Input.GetButtonUp(&quot;RightSlot&quot;)) {\n        playerController.changeSlots(true);\n    }\n}\n</code></pre><p><strong>playerController.changeSlots</strong><br>infiniteObjectGenerator.slotDistance这个是unity编辑器里面配置是2  两个跑道之间的距离是2<br>targetSlotValue = (int)currentSlotPosition <em> infiniteObjectGenerator.slotDistance;这个值就是目标的跑道的偏移<br>这里更新目标位置<br>updateTargetPosition(targetRotation.eulerAngles.y);<br>看下这个函数updateTargetPosition的这两句<br>targetPosition.x += targetSlotValue </em> Mathf.Cos(yAngle <em> Mathf.Deg2Rad);<br>        targetPosition.z += targetSlotValue </em> -Mathf.Sin(yAngle <em> Mathf.Deg2Rad);<br>把targetSlotValue 换算成左边偏倚 y轴的转向也就是人物中心轴转向 如果一开始游戏 Y转向是0度  那么Mathf.Cos(yAngle </em> Mathf.Deg2Rad)是1 -Mathf.Sin(yAngle * Mathf.Deg2Rad);是0 然后targetSlotValue 的偏移都是X的便宜 Z不用偏移 同理可以想像下 如果向左转了90 之后 偏移就</p>\n<p><strong>playerController.turn</strong></p>\n<ol>\n<li>获取目标转向：Vector3 direction = platformObject.getTransform().right * (rightTurn ? 1 : -1);</li>\n<li>得到目标的转向：targetRotation = Quaternion.LookRotation(direction);</li>\n<li><p>然后在LateUpdate里面真正的插值转职到targetRotation</p>\n<pre><code>if (thisTransform.rotation != targetRotation) {\n    thisTransform.rotation = Quaternion.RotateTowards(thisTransform.rotation, targetRotation,Mathf.Lerp(slowRotationSpeed, fastRotationSpeed, Mathf.Clamp01(Quaternion.Angle(thisTransform.rotation, targetRotation) / 45)));\n}\n</code></pre></li>\n</ol>\n<p>这里查下RotateTowards函数是旋转到目标角度 Mathf.Lerp函数是获得插值  插值就可以实现平滑的旋转</p>\n<h3 id=\"13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\"><a href=\"#13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\" class=\"headerlink\" title=\"13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本\"></a>13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本</h3><p>MainScene里面有个Obeject叫InfiniteObject  这些无限的场景和物体都是在这个object下面</p>\n<p><img src=\"/2017/08/16/kupao/1502597632750.png\" alt=\"Alt text\"></p>\n<p>分成五类物体：<br>（1）obstacles：障碍物<br>（2）scene：场景<br>（3）powerups：强化道具<br>（4）platforms：底板<br>（5）coins：硬币</p>\n<h4 id=\"1、InfiniteObjectGenerator-生成器\"><a href=\"#1、InfiniteObjectGenerator-生成器\" class=\"headerlink\" title=\"1、InfiniteObjectGenerator 生成器\"></a>1、InfiniteObjectGenerator 生成器</h4><p><strong>函数入口，调用堆栈</strong>：</p>\n<ol>\n<li>PlayerController::LateUpdate()</li>\n<li>InfiniteObjectGenerator::moveObjects()</li>\n<li>InfiniteObjectGenerator::spawnObjectRun()</li>\n</ol>\n<p>我们看下spawnObjectRun函数：</p>\n<p>有个函数在移动整个场景moveObjects  这个是被PlayerController的LateUpdate函数调用<br>moveObjects里面来调用spawnObjectRun  从而不断生成</p>\n<p><strong>我们看下moveObjects这个函数</strong></p>\n<ol>\n<li>for (int j = 0; j &lt; (int)ObjectLocation.Last; ++j) {这个循环是移动所有的物体</li>\n<li>infiniteObject = infiniteObjectHistory.getTopTurnInfiniteObject(i == 0);这句获取第一个物体判断是否要销毁</li>\n<li>spawnObjectRun(true);这句调用了生成的函数</li>\n</ol>\n<p>spawnObjectRun这个函数的前半部分是生成路径 后半部分是生成一个转向</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>vs2015断调试unity项目<br><a href=\"http://www.itcast.cn/news/20151229/1437047587.shtml\">http://www.itcast.cn/news/20151229/1437047587.shtml</a></p>"},{"title":"手游中的文件格式和纹理格式","date":"2017-09-10T12:32:15.000Z","published":1,"reward":true,"_content":"\n\n\n> 我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，**本文就来梳理一下这些名字，作简要的解释。**\n\n### 一、首先我们来分类一下\n#### 1、文件格式：图片在硬盘中的格式\n#### 2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。\n#### 3、压缩算法：etc（本文会详细解释此算法）、pvr等 \n\n<!-- more -->\n\n### 二、稍微深入的讲解\n#### 1、文件格式：\n- 我们说的png、jpg、bmp指的是文件格式，就是图片在硬盘里面存储的格式，或者是手机的存储里面的格式，游戏的资源的格式。\n- 引用百度百科里面的话：图像格式即图像文件存放的格式，通常有JPEG、TIFF、RAW、BMP、GIF、PNG。\n**PNG：提取[《PNG文件格式详解》](http://blog.csdn.net/bisword/article/details/2777121)这篇文章的解释：**\npng文件由PNG文件标志（文件头）、3个以上的PNG的数据块（Chunk）按照特定的顺序组成\n\n| PNG文件标志|     Chunk|   ...|  Chunk|\n| :-------- | :--------| :------ |:------ |\n\n下面这个表格是数据块chunk的内容（主要的chunk）\n\n| 数据块符号|     数据块名称|   多数据块|位置限制|\n| :-------- | :--------| :------ |:------ |\n| IHDR\t|   文件头数据块|  否|第一块\n|PLTE| 调色板数据块 |\t否|\t在IDAT之前|\n|IDAT| 图像数据块 |\t是|\t与其他IDAT连续|\n|IEND| 图像结束数据 |\t否|\t最后一个数据块|\n\n\n#### 2、纹理格式\n\n| 纹理格式      |     解释|   其他|\n| :-------- | :--------| :------ |\n|RGBA8888 | RGBA 各占8位bit， 一个像素就4byte  |（1）常用地方：整个场景背景图片 大量的渐变色图片 （2）OpenGL ES生成纹理在生成纹理时大小会自动扩展成2的幂次方。不足自动向下调整 |\n|BGRA8888 | 跟RGBA8888顺序不一样  |  |\n|RGBA4444| RGBA 各占4位bit 一个像素就2byte  |  |\n|RGB888|这个相比第一种 RGBA8888 没有 alpha通道 用在没有透明度的图片 游戏背景图片。|  |\n|RGB565|这个是高品质的16位纹理  也是没有透明度|  |\n|RGBA5551|透明度只有0 和 1 没有渐变的图片|  |\n|PVRTC2 | iphone 的图片芯片 对一种称为 PVRTC 的压缩技术提供硬件支持所有颜色和透明度占2个字节(品质可能有点低)  |  |\n|PVRTC4|所有颜色和透明度占4个字节,在ios上基本都用这个格式|(iOS产品专用)|\n|PVRTC2_NOALPHA|RGB占用2个字节，没用ALPHA通道||\n|PVRTC4_NOALPHA|RGB占用4个字节，没用ALPHA通道||\n|ETC1|安卓常用的压缩格式||\n|ETC2|安卓常用的压缩格式||\n\n#### 3、压缩算法\n##### Android设备\n1. 首先，android设备一般使用ETC1压缩  一种有损的图像压缩方式：\nETC1是opengl2.0 压缩之后每个像素占用4bit  压缩之后的格式为KTX或者PKM  前者支持存储多纹理 后者只支持单纹理 \n1024的RGBA32占用内存4M 如果是etc1的压缩之后就是0.5M\nETC1的缺点是不支持Alpha通道 不支持有透明度的图片压缩\n2. ETC2解决了Alpha通道 但是它是Opengl3.0标准  考虑到2.0设备市场占用率  一般使用ETC1\n【附】止于 2017 年 8 月 8 日在[安卓开发者中心](https://developer.android.com/about/dashboards/index.html)看到\n| OpenGL ES Version|     Distribution| \n| :-------- | --------:| \n| 2.0\t| 37.6%| \n| 3.0\t| 45.6%| \n| 3.1| \t16.8%| \n\n3. 算法过程解释\n>[ETC压缩算法](https://www.khronos.org/registry/OpenGL/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt)翻译：\n>读这篇文章可以了解 用中文尽可能表达一遍\n>**1.总体了解下：**ETC的压缩单元是4x4的像素块，会把一个4x4的像素块压缩成一个64bit中。\n>\n>**2.下面介绍几张表：**  encode decode过程会使用到的\n> \n>**1）像素表（源表）**下图就是这个4x4的像素块的表 每个pixel如果用RGBA8888表示 那就是4x4x4 64字节  \n>| pixel| pixel| pixel| pixel|\n>|  :-------- | :-------- |\n>| a  |e |i| m|\n>| b  |f |j| n|\n>| c  |g |k| o|\n>| d  |h |l| p|\n>**2）压缩后表（结果表）** 下图就是压缩后的64bit 每个bit要么是0 要么是1：\n>| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit|\n>|  :-------- | :-------- |\n>|63|62|61|60|59|58|57|56|55|54|53|52|51|50|49|48|\n>| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>|47|46|45|44|43|42|41|40|39|38|37|36|35|34|33|32|\n>|  0| 0| 0| 0| 0| 0| 0| 0| table cw 1| table cw 1| table cw 1| table cw 2| table cw 2| table cw 2| diff bit| flip bit|\n>|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|\n>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|\n>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>\n>**3）下面这些表示预存储的表 就是不占文件大小 decode encode过程 调用算法使用的表**\n>3.1）像素差值表 待会会来这里索引取值\n>![Alt text](./1504488376717.png)\n>3.2）间隔表 待会也会来这里索引取值\n>![Alt text](./1504488394913.png)\n> \n>**3.下面正式介绍算法过程：**   encode过程\n>①**第32bit是flipbit**\n>**如果这个bit是0**  那么这个块分成2个2x4的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）\n>![Alt text](./1504488756715.png)\n>**如果这个bit是1** 那么这个块分成2个4x2的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）\n>![Alt text](./1504488781878.png)\n>②**分块之后计算这两个块的颜色均值**，存储颜色均值的方法有两种，用第33bit（diffbit）来表示用了哪种存储颜色均值的方法，每个subblock用12bits存储颜色均值 两个block就是24bits （均值用了24bits 用一个bit表示用了哪个存储颜色均值的方法 所以用了25bit 现在剩下38bits）\n>**如果第33bit（diffbit）是0 那么颜色均值方法如下：**\n>下图是用63到40（一共24bits）来存均值，图中标注了 63-60是给R1 55-52是给G1 47-44是给B1\n>举例子,如果 R1 = 14 =1110b, G1 = 3 = 0011b and B1 = 8 = 1000b, 那么subblock的均值的红色部分是11101110b = 238 绿色部分 00110011b = 51 蓝色部分10001000b = 136. \n>![Alt text](./1504489517922.png)\n>**如果第33bit（diffbit）是1 那么颜色均值方法如下：**\n>下图是用63到40（一共24bits）来存颜色均值，图中标注了 63-59是给R1 55-51是给G1 47-43是给B1\n>举个例子，如果 R1' = 28 = 11100b,  那么subblock的均值的红色部分是11100111b = 231. 同理绿色部分G1' = 4 = 00100b 蓝色部分B1' = 3 = 00011b, 结果是 00100001b = 33 and 00011000b = 24\n>**这里有点特殊的是第二个块** R、G、B分别只有3bits，也是举例子：如果 R1' = 28 = 11100b   R2 = 100b = -4, 那么28+(-4)=24 = 11000b, 所以第二个块的R是 11000110b = 198. 同理可得G2 B2\n>![Alt text](./1504491196164.png)\n>③**我们先看到![Alt text](./1504492132538.png)39 38 37 bit** 三个bit用于确定是用哪个像素差值表 看到2.3.1的表 有8行 刚好3个bit可以确定是哪行 如果39 38 37 bit是010 那个是2 也就是用-29 -9 9 29这行 同理36 35 34 bit\n>然后现在还有32个bit没有解释，剩下的是第31到第0bit， 我们最原始的像素是16个像素 现在每个像素只有2bit了 我们看这个表可以查询一个映射关系\n>**下面的表** 例如像素d 对应的是19bit和3bit  **举个例子** 19bit是1 3bit是0 那么合起来就是01 我们看到间隔表（2.3.2的表）\n>\n>![Alt text](./1504492579311.png)\n>\n>对应的是b  刚刚我们的像素差值行是[-29 -9 9 29] 所以**得到的值是29** 假设我们的均值颜色是**(231, 8, 16)**那个对应的颜色就是**(231+29, 8+29, 16+29)** 如果越界255 则归为255 所以是**(255, 37, 45)**\n>\n>![Alt text](./1504492407923.png)\n>\n>**上面的过程归结到流程图中**\n>```flow\n>st=>start: Start\n>e=>end\n>op1=>operation:  ①4x4的像素块是分成2个2x4的\n>还是2个4x2的 横切还是竖切？\n>op2=>operation: ②存储颜色均值是用哪种方法？\n>op3=>operation: ③使用table codeword哪个表？\n>op4=>operation: ③16个像素点的像素值跟均值的差值是多少？查表填相应数值\n>st->op1->op2->op3->op4->e\n>\n>```\n\t\n\n##### Ios设备\nios设备中采用的图像格式一般是pvr  也是有损的图像压缩方式 \npvr压缩分成 pvrtc2 pvrtc4一个是2bits 一个是4bits\n除了压缩内存的优势还可以直接被显卡读取 载入速度更快  缺点是需要PowerVR芯片支持  目前ios设备都能完美支持 \n>[pvr的格式](http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.Legacy.pdf) [算法原理](http://web.onetel.net.uk/~simonnihal/assorted3d/fenney03texcomp.pdf)\n>pvr文件分成两部分\n>| Header|     Texture Data|\n>| :-------- | --------:|\n>| 44 (pvr1) or 52 bytes(pvr2)|  大于等于0bytes |\n>算法原理比较高深 看不懂 也没有细看\n>文章中的这副图 可以看到 跟ETC有点像 也是把4x4的pixel压缩到64bits里面 16bit是Base ColourB \n>15bit是Base ColourB 还有个Mod Mode存一个bit 剩下的32bits是 Modulation Data每2bits对应一个像素点 对应关系如下：\n>![Alt text](./1504511314399.png)\n>![Alt text](./1504509740940.png)\n\n#### 4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：\n下面图片是一张图片的三个格式 png32 pvr pkm \n![Alt text](./1504516848865.png)\n![Alt text](./1504516795002.png)\n\n1. 第一个问题，理论上png32 512x512 大小应该是512x512x4bytes（1M） 但是这里显示217km?\n这个是因为png32文件也有自己的压缩，这张png32在内存里面用的是1M  但是文件格式有自己的无损压缩方法 所以小于1M\n2. pvr的是一个像素4bits  所以应该是 512x512x0.5bytes=128km  这里是129kb\n因为pvr分为 Header和Texture Data 多出的1k byte存头部\n \n\n------------\n参考引用：\npvr和png内存占用\nhttp://blog.csdn.net/kaitiren/article/details/8054856\nhttp://www.cnblogs.com/xulidong/p/5681351.html\n\n纹理格式\nhttp://blog.csdn.net/ynnmnm/article/details/44983545\n\n\n附：\n安卓设备市场份额的分布（谷歌统计）\nhttps://developer.android.com/about/dashboards/index.html\n\n\n\n\n\n","source":"_posts/picture-texture.md","raw":"---\ntitle: 手游中的文件格式和纹理格式\ndate: 2017-09-10 20:32:15\ntags: 纹理格式,手游开发\npublished: true\nreward: true\n---\n\n\n\n> 我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，**本文就来梳理一下这些名字，作简要的解释。**\n\n### 一、首先我们来分类一下\n#### 1、文件格式：图片在硬盘中的格式\n#### 2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。\n#### 3、压缩算法：etc（本文会详细解释此算法）、pvr等 \n\n<!-- more -->\n\n### 二、稍微深入的讲解\n#### 1、文件格式：\n- 我们说的png、jpg、bmp指的是文件格式，就是图片在硬盘里面存储的格式，或者是手机的存储里面的格式，游戏的资源的格式。\n- 引用百度百科里面的话：图像格式即图像文件存放的格式，通常有JPEG、TIFF、RAW、BMP、GIF、PNG。\n**PNG：提取[《PNG文件格式详解》](http://blog.csdn.net/bisword/article/details/2777121)这篇文章的解释：**\npng文件由PNG文件标志（文件头）、3个以上的PNG的数据块（Chunk）按照特定的顺序组成\n\n| PNG文件标志|     Chunk|   ...|  Chunk|\n| :-------- | :--------| :------ |:------ |\n\n下面这个表格是数据块chunk的内容（主要的chunk）\n\n| 数据块符号|     数据块名称|   多数据块|位置限制|\n| :-------- | :--------| :------ |:------ |\n| IHDR\t|   文件头数据块|  否|第一块\n|PLTE| 调色板数据块 |\t否|\t在IDAT之前|\n|IDAT| 图像数据块 |\t是|\t与其他IDAT连续|\n|IEND| 图像结束数据 |\t否|\t最后一个数据块|\n\n\n#### 2、纹理格式\n\n| 纹理格式      |     解释|   其他|\n| :-------- | :--------| :------ |\n|RGBA8888 | RGBA 各占8位bit， 一个像素就4byte  |（1）常用地方：整个场景背景图片 大量的渐变色图片 （2）OpenGL ES生成纹理在生成纹理时大小会自动扩展成2的幂次方。不足自动向下调整 |\n|BGRA8888 | 跟RGBA8888顺序不一样  |  |\n|RGBA4444| RGBA 各占4位bit 一个像素就2byte  |  |\n|RGB888|这个相比第一种 RGBA8888 没有 alpha通道 用在没有透明度的图片 游戏背景图片。|  |\n|RGB565|这个是高品质的16位纹理  也是没有透明度|  |\n|RGBA5551|透明度只有0 和 1 没有渐变的图片|  |\n|PVRTC2 | iphone 的图片芯片 对一种称为 PVRTC 的压缩技术提供硬件支持所有颜色和透明度占2个字节(品质可能有点低)  |  |\n|PVRTC4|所有颜色和透明度占4个字节,在ios上基本都用这个格式|(iOS产品专用)|\n|PVRTC2_NOALPHA|RGB占用2个字节，没用ALPHA通道||\n|PVRTC4_NOALPHA|RGB占用4个字节，没用ALPHA通道||\n|ETC1|安卓常用的压缩格式||\n|ETC2|安卓常用的压缩格式||\n\n#### 3、压缩算法\n##### Android设备\n1. 首先，android设备一般使用ETC1压缩  一种有损的图像压缩方式：\nETC1是opengl2.0 压缩之后每个像素占用4bit  压缩之后的格式为KTX或者PKM  前者支持存储多纹理 后者只支持单纹理 \n1024的RGBA32占用内存4M 如果是etc1的压缩之后就是0.5M\nETC1的缺点是不支持Alpha通道 不支持有透明度的图片压缩\n2. ETC2解决了Alpha通道 但是它是Opengl3.0标准  考虑到2.0设备市场占用率  一般使用ETC1\n【附】止于 2017 年 8 月 8 日在[安卓开发者中心](https://developer.android.com/about/dashboards/index.html)看到\n| OpenGL ES Version|     Distribution| \n| :-------- | --------:| \n| 2.0\t| 37.6%| \n| 3.0\t| 45.6%| \n| 3.1| \t16.8%| \n\n3. 算法过程解释\n>[ETC压缩算法](https://www.khronos.org/registry/OpenGL/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt)翻译：\n>读这篇文章可以了解 用中文尽可能表达一遍\n>**1.总体了解下：**ETC的压缩单元是4x4的像素块，会把一个4x4的像素块压缩成一个64bit中。\n>\n>**2.下面介绍几张表：**  encode decode过程会使用到的\n> \n>**1）像素表（源表）**下图就是这个4x4的像素块的表 每个pixel如果用RGBA8888表示 那就是4x4x4 64字节  \n>| pixel| pixel| pixel| pixel|\n>|  :-------- | :-------- |\n>| a  |e |i| m|\n>| b  |f |j| n|\n>| c  |g |k| o|\n>| d  |h |l| p|\n>**2）压缩后表（结果表）** 下图就是压缩后的64bit 每个bit要么是0 要么是1：\n>| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit|\n>|  :-------- | :-------- |\n>|63|62|61|60|59|58|57|56|55|54|53|52|51|50|49|48|\n>| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>|47|46|45|44|43|42|41|40|39|38|37|36|35|34|33|32|\n>|  0| 0| 0| 0| 0| 0| 0| 0| table cw 1| table cw 1| table cw 1| table cw 2| table cw 2| table cw 2| diff bit| flip bit|\n>|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|\n>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|\n>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\n>\n>**3）下面这些表示预存储的表 就是不占文件大小 decode encode过程 调用算法使用的表**\n>3.1）像素差值表 待会会来这里索引取值\n>![Alt text](./1504488376717.png)\n>3.2）间隔表 待会也会来这里索引取值\n>![Alt text](./1504488394913.png)\n> \n>**3.下面正式介绍算法过程：**   encode过程\n>①**第32bit是flipbit**\n>**如果这个bit是0**  那么这个块分成2个2x4的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）\n>![Alt text](./1504488756715.png)\n>**如果这个bit是1** 那么这个块分成2个4x2的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）\n>![Alt text](./1504488781878.png)\n>②**分块之后计算这两个块的颜色均值**，存储颜色均值的方法有两种，用第33bit（diffbit）来表示用了哪种存储颜色均值的方法，每个subblock用12bits存储颜色均值 两个block就是24bits （均值用了24bits 用一个bit表示用了哪个存储颜色均值的方法 所以用了25bit 现在剩下38bits）\n>**如果第33bit（diffbit）是0 那么颜色均值方法如下：**\n>下图是用63到40（一共24bits）来存均值，图中标注了 63-60是给R1 55-52是给G1 47-44是给B1\n>举例子,如果 R1 = 14 =1110b, G1 = 3 = 0011b and B1 = 8 = 1000b, 那么subblock的均值的红色部分是11101110b = 238 绿色部分 00110011b = 51 蓝色部分10001000b = 136. \n>![Alt text](./1504489517922.png)\n>**如果第33bit（diffbit）是1 那么颜色均值方法如下：**\n>下图是用63到40（一共24bits）来存颜色均值，图中标注了 63-59是给R1 55-51是给G1 47-43是给B1\n>举个例子，如果 R1' = 28 = 11100b,  那么subblock的均值的红色部分是11100111b = 231. 同理绿色部分G1' = 4 = 00100b 蓝色部分B1' = 3 = 00011b, 结果是 00100001b = 33 and 00011000b = 24\n>**这里有点特殊的是第二个块** R、G、B分别只有3bits，也是举例子：如果 R1' = 28 = 11100b   R2 = 100b = -4, 那么28+(-4)=24 = 11000b, 所以第二个块的R是 11000110b = 198. 同理可得G2 B2\n>![Alt text](./1504491196164.png)\n>③**我们先看到![Alt text](./1504492132538.png)39 38 37 bit** 三个bit用于确定是用哪个像素差值表 看到2.3.1的表 有8行 刚好3个bit可以确定是哪行 如果39 38 37 bit是010 那个是2 也就是用-29 -9 9 29这行 同理36 35 34 bit\n>然后现在还有32个bit没有解释，剩下的是第31到第0bit， 我们最原始的像素是16个像素 现在每个像素只有2bit了 我们看这个表可以查询一个映射关系\n>**下面的表** 例如像素d 对应的是19bit和3bit  **举个例子** 19bit是1 3bit是0 那么合起来就是01 我们看到间隔表（2.3.2的表）\n>\n>![Alt text](./1504492579311.png)\n>\n>对应的是b  刚刚我们的像素差值行是[-29 -9 9 29] 所以**得到的值是29** 假设我们的均值颜色是**(231, 8, 16)**那个对应的颜色就是**(231+29, 8+29, 16+29)** 如果越界255 则归为255 所以是**(255, 37, 45)**\n>\n>![Alt text](./1504492407923.png)\n>\n>**上面的过程归结到流程图中**\n>```flow\n>st=>start: Start\n>e=>end\n>op1=>operation:  ①4x4的像素块是分成2个2x4的\n>还是2个4x2的 横切还是竖切？\n>op2=>operation: ②存储颜色均值是用哪种方法？\n>op3=>operation: ③使用table codeword哪个表？\n>op4=>operation: ③16个像素点的像素值跟均值的差值是多少？查表填相应数值\n>st->op1->op2->op3->op4->e\n>\n>```\n\t\n\n##### Ios设备\nios设备中采用的图像格式一般是pvr  也是有损的图像压缩方式 \npvr压缩分成 pvrtc2 pvrtc4一个是2bits 一个是4bits\n除了压缩内存的优势还可以直接被显卡读取 载入速度更快  缺点是需要PowerVR芯片支持  目前ios设备都能完美支持 \n>[pvr的格式](http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.Legacy.pdf) [算法原理](http://web.onetel.net.uk/~simonnihal/assorted3d/fenney03texcomp.pdf)\n>pvr文件分成两部分\n>| Header|     Texture Data|\n>| :-------- | --------:|\n>| 44 (pvr1) or 52 bytes(pvr2)|  大于等于0bytes |\n>算法原理比较高深 看不懂 也没有细看\n>文章中的这副图 可以看到 跟ETC有点像 也是把4x4的pixel压缩到64bits里面 16bit是Base ColourB \n>15bit是Base ColourB 还有个Mod Mode存一个bit 剩下的32bits是 Modulation Data每2bits对应一个像素点 对应关系如下：\n>![Alt text](./1504511314399.png)\n>![Alt text](./1504509740940.png)\n\n#### 4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：\n下面图片是一张图片的三个格式 png32 pvr pkm \n![Alt text](./1504516848865.png)\n![Alt text](./1504516795002.png)\n\n1. 第一个问题，理论上png32 512x512 大小应该是512x512x4bytes（1M） 但是这里显示217km?\n这个是因为png32文件也有自己的压缩，这张png32在内存里面用的是1M  但是文件格式有自己的无损压缩方法 所以小于1M\n2. pvr的是一个像素4bits  所以应该是 512x512x0.5bytes=128km  这里是129kb\n因为pvr分为 Header和Texture Data 多出的1k byte存头部\n \n\n------------\n参考引用：\npvr和png内存占用\nhttp://blog.csdn.net/kaitiren/article/details/8054856\nhttp://www.cnblogs.com/xulidong/p/5681351.html\n\n纹理格式\nhttp://blog.csdn.net/ynnmnm/article/details/44983545\n\n\n附：\n安卓设备市场份额的分布（谷歌统计）\nhttps://developer.android.com/about/dashboards/index.html\n\n\n\n\n\n","slug":"picture-texture","updated":"2018-05-11T10:13:52.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o530003znmjz8m12msv","content":"<blockquote>\n<p>我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，<strong>本文就来梳理一下这些名字，作简要的解释。</strong></p>\n</blockquote>\n<h3 id=\"一、首先我们来分类一下\"><a href=\"#一、首先我们来分类一下\" class=\"headerlink\" title=\"一、首先我们来分类一下\"></a>一、首先我们来分类一下</h3><h4 id=\"1、文件格式：图片在硬盘中的格式\"><a href=\"#1、文件格式：图片在硬盘中的格式\" class=\"headerlink\" title=\"1、文件格式：图片在硬盘中的格式\"></a>1、文件格式：图片在硬盘中的格式</h4><h4 id=\"2、纹理格式：这里我认为是：包括了-在内存里面的格式和在传给GPU的纹理。\"><a href=\"#2、纹理格式：这里我认为是：包括了-在内存里面的格式和在传给GPU的纹理。\" class=\"headerlink\" title=\"2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。\"></a>2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。</h4><h4 id=\"3、压缩算法：etc（本文会详细解释此算法）、pvr等\"><a href=\"#3、压缩算法：etc（本文会详细解释此算法）、pvr等\" class=\"headerlink\" title=\"3、压缩算法：etc（本文会详细解释此算法）、pvr等\"></a>3、压缩算法：etc（本文会详细解释此算法）、pvr等</h4><a id=\"more\"></a>\n<h3 id=\"二、稍微深入的讲解\"><a href=\"#二、稍微深入的讲解\" class=\"headerlink\" title=\"二、稍微深入的讲解\"></a>二、稍微深入的讲解</h3><h4 id=\"1、文件格式：\"><a href=\"#1、文件格式：\" class=\"headerlink\" title=\"1、文件格式：\"></a>1、文件格式：</h4><ul>\n<li>我们说的png、jpg、bmp指的是文件格式，就是图片在硬盘里面存储的格式，或者是手机的存储里面的格式，游戏的资源的格式。</li>\n<li>引用百度百科里面的话：图像格式即图像文件存放的格式，通常有JPEG、TIFF、RAW、BMP、GIF、PNG。<br><strong>PNG：提取<a href=\"http://blog.csdn.net/bisword/article/details/2777121\" target=\"_blank\" rel=\"external\">《PNG文件格式详解》</a>这篇文章的解释：</strong><br>png文件由PNG文件标志（文件头）、3个以上的PNG的数据块（Chunk）按照特定的顺序组成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PNG文件标志</th>\n<th style=\"text-align:left\">Chunk</th>\n<th style=\"text-align:left\">…</th>\n<th style=\"text-align:left\">Chunk</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>下面这个表格是数据块chunk的内容（主要的chunk）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据块符号</th>\n<th style=\"text-align:left\">数据块名称</th>\n<th style=\"text-align:left\">多数据块</th>\n<th style=\"text-align:left\">位置限制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IHDR</td>\n<td style=\"text-align:left\">文件头数据块</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">第一块</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PLTE</td>\n<td style=\"text-align:left\">调色板数据块</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">在IDAT之前</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IDAT</td>\n<td style=\"text-align:left\">图像数据块</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">与其他IDAT连续</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IEND</td>\n<td style=\"text-align:left\">图像结束数据</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">最后一个数据块</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2、纹理格式\"><a href=\"#2、纹理格式\" class=\"headerlink\" title=\"2、纹理格式\"></a>2、纹理格式</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">纹理格式</th>\n<th style=\"text-align:left\">解释</th>\n<th style=\"text-align:left\">其他</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">RGBA8888</td>\n<td style=\"text-align:left\">RGBA 各占8位bit， 一个像素就4byte</td>\n<td style=\"text-align:left\">（1）常用地方：整个场景背景图片 大量的渐变色图片 （2）OpenGL ES生成纹理在生成纹理时大小会自动扩展成2的幂次方。不足自动向下调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BGRA8888</td>\n<td style=\"text-align:left\">跟RGBA8888顺序不一样</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGBA4444</td>\n<td style=\"text-align:left\">RGBA 各占4位bit 一个像素就2byte</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGB888</td>\n<td style=\"text-align:left\">这个相比第一种 RGBA8888 没有 alpha通道 用在没有透明度的图片 游戏背景图片。</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGB565</td>\n<td style=\"text-align:left\">这个是高品质的16位纹理  也是没有透明度</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGBA5551</td>\n<td style=\"text-align:left\">透明度只有0 和 1 没有渐变的图片</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC2</td>\n<td style=\"text-align:left\">iphone 的图片芯片 对一种称为 PVRTC 的压缩技术提供硬件支持所有颜色和透明度占2个字节(品质可能有点低)</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC4</td>\n<td style=\"text-align:left\">所有颜色和透明度占4个字节,在ios上基本都用这个格式</td>\n<td style=\"text-align:left\">(iOS产品专用)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC2_NOALPHA</td>\n<td style=\"text-align:left\">RGB占用2个字节，没用ALPHA通道</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC4_NOALPHA</td>\n<td style=\"text-align:left\">RGB占用4个字节，没用ALPHA通道</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ETC1</td>\n<td style=\"text-align:left\">安卓常用的压缩格式</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ETC2</td>\n<td style=\"text-align:left\">安卓常用的压缩格式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3、压缩算法\"><a href=\"#3、压缩算法\" class=\"headerlink\" title=\"3、压缩算法\"></a>3、压缩算法</h4><h5 id=\"Android设备\"><a href=\"#Android设备\" class=\"headerlink\" title=\"Android设备\"></a>Android设备</h5><ol>\n<li>首先，android设备一般使用ETC1压缩  一种有损的图像压缩方式：<br>ETC1是opengl2.0 压缩之后每个像素占用4bit  压缩之后的格式为KTX或者PKM  前者支持存储多纹理 后者只支持单纹理<br>1024的RGBA32占用内存4M 如果是etc1的压缩之后就是0.5M<br>ETC1的缺点是不支持Alpha通道 不支持有透明度的图片压缩</li>\n<li><p>ETC2解决了Alpha通道 但是它是Opengl3.0标准  考虑到2.0设备市场占用率  一般使用ETC1<br>【附】止于 2017 年 8 月 8 日在<a href=\"https://developer.android.com/about/dashboards/index.html\" target=\"_blank\" rel=\"external\">安卓开发者中心</a>看到<br>| OpenGL ES Version|     Distribution|<br>| :——– | ——–:|<br>| 2.0    | 37.6%|<br>| 3.0    | 45.6%|<br>| 3.1|     16.8%| </p>\n</li>\n<li><p>算法过程解释</p>\n<blockquote>\n<p><a href=\"https://www.khronos.org/registry/OpenGL/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt\" target=\"_blank\" rel=\"external\">ETC压缩算法</a>翻译：<br>读这篇文章可以了解 用中文尽可能表达一遍<br><strong>1.总体了解下：</strong>ETC的压缩单元是4x4的像素块，会把一个4x4的像素块压缩成一个64bit中。</p>\n<p><strong>2.下面介绍几张表：</strong>  encode decode过程会使用到的</p>\n<p><strong>1）像素表（源表）</strong>下图就是这个4x4的像素块的表 每个pixel如果用RGBA8888表示 那就是4x4x4 64字节<br>| pixel| pixel| pixel| pixel|<br>|  :——– | :——– |<br>| a  |e |i| m|<br>| b  |f |j| n|<br>| c  |g |k| o|<br>| d  |h |l| p|<br><strong>2）压缩后表（结果表）</strong> 下图就是压缩后的64bit 每个bit要么是0 要么是1：<br>| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit|<br>|  :——– | :——– |<br>|63|62|61|60|59|58|57|56|55|54|53|52|51|50|49|48|<br>| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|<br>|47|46|45|44|43|42|41|40|39|38|37|36|35|34|33|32|<br>|  0| 0| 0| 0| 0| 0| 0| 0| table cw 1| table cw 1| table cw 1| table cw 2| table cw 2| table cw 2| diff bit| flip bit|<br>|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|<br>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|<br>|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|<br>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|</p>\n<p><strong>3）下面这些表示预存储的表 就是不占文件大小 decode encode过程 调用算法使用的表</strong><br>3.1）像素差值表 待会会来这里索引取值<br><img src=\"/2017/09/10/picture-texture/1504488376717.png\" alt=\"Alt text\"><br>3.2）间隔表 待会也会来这里索引取值<br><img src=\"/2017/09/10/picture-texture/1504488394913.png\" alt=\"Alt text\"></p>\n<p><strong>3.下面正式介绍算法过程：</strong>   encode过程<br>①<strong>第32bit是flipbit</strong><br><strong>如果这个bit是0</strong>  那么这个块分成2个2x4的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）<br><img src=\"/2017/09/10/picture-texture/1504488756715.png\" alt=\"Alt text\"><br><strong>如果这个bit是1</strong> 那么这个块分成2个4x2的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）<br><img src=\"/2017/09/10/picture-texture/1504488781878.png\" alt=\"Alt text\"><br>②<strong>分块之后计算这两个块的颜色均值</strong>，存储颜色均值的方法有两种，用第33bit（diffbit）来表示用了哪种存储颜色均值的方法，每个subblock用12bits存储颜色均值 两个block就是24bits （均值用了24bits 用一个bit表示用了哪个存储颜色均值的方法 所以用了25bit 现在剩下38bits）<br><strong>如果第33bit（diffbit）是0 那么颜色均值方法如下：</strong><br>下图是用63到40（一共24bits）来存均值，图中标注了 63-60是给R1 55-52是给G1 47-44是给B1<br>举例子,如果 R1 = 14 =1110b, G1 = 3 = 0011b and B1 = 8 = 1000b, 那么subblock的均值的红色部分是11101110b = 238 绿色部分 00110011b = 51 蓝色部分10001000b = 136.<br><img src=\"/2017/09/10/picture-texture/1504489517922.png\" alt=\"Alt text\"><br><strong>如果第33bit（diffbit）是1 那么颜色均值方法如下：</strong><br>下图是用63到40（一共24bits）来存颜色均值，图中标注了 63-59是给R1 55-51是给G1 47-43是给B1<br>举个例子，如果 R1’ = 28 = 11100b,  那么subblock的均值的红色部分是11100111b = 231. 同理绿色部分G1’ = 4 = 00100b 蓝色部分B1’ = 3 = 00011b, 结果是 00100001b = 33 and 00011000b = 24<br><strong>这里有点特殊的是第二个块</strong> R、G、B分别只有3bits，也是举例子：如果 R1’ = 28 = 11100b   R2 = 100b = -4, 那么28+(-4)=24 = 11000b, 所以第二个块的R是 11000110b = 198. 同理可得G2 B2<br><img src=\"/2017/09/10/picture-texture/1504491196164.png\" alt=\"Alt text\"><br>③<strong>我们先看到<img src=\"/2017/09/10/picture-texture/1504492132538.png\" alt=\"Alt text\">39 38 37 bit</strong> 三个bit用于确定是用哪个像素差值表 看到2.3.1的表 有8行 刚好3个bit可以确定是哪行 如果39 38 37 bit是010 那个是2 也就是用-29 -9 9 29这行 同理36 35 34 bit<br>然后现在还有32个bit没有解释，剩下的是第31到第0bit， 我们最原始的像素是16个像素 现在每个像素只有2bit了 我们看这个表可以查询一个映射关系<br><strong>下面的表</strong> 例如像素d 对应的是19bit和3bit  <strong>举个例子</strong> 19bit是1 3bit是0 那么合起来就是01 我们看到间隔表（2.3.2的表）</p>\n<p><img src=\"/2017/09/10/picture-texture/1504492579311.png\" alt=\"Alt text\"></p>\n<p>对应的是b  刚刚我们的像素差值行是[-29 -9 9 29] 所以<strong>得到的值是29</strong> 假设我们的均值颜色是<strong>(231, 8, 16)</strong>那个对应的颜色就是<strong>(231+29, 8+29, 16+29)</strong> 如果越界255 则归为255 所以是<strong>(255, 37, 45)</strong></p>\n<p><img src=\"/2017/09/10/picture-texture/1504492407923.png\" alt=\"Alt text\"></p>\n<p><strong>上面的过程归结到流程图中</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;st=&gt;start: Start</div><div class=\"line\">&gt;e=&gt;end</div><div class=\"line\">&gt;op1=&gt;operation:  ①4x4的像素块是分成2个2x4的</div><div class=\"line\">&gt;还是2个4x2的 横切还是竖切？</div><div class=\"line\">&gt;op2=&gt;operation: ②存储颜色均值是用哪种方法？</div><div class=\"line\">&gt;op3=&gt;operation: ③使用table codeword哪个表？</div><div class=\"line\">&gt;op4=&gt;operation: ③16个像素点的像素值跟均值的差值是多少？查表填相应数值</div><div class=\"line\">&gt;st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e</div><div class=\"line\">&gt;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"Ios设备\"><a href=\"#Ios设备\" class=\"headerlink\" title=\"Ios设备\"></a>Ios设备</h5><p>ios设备中采用的图像格式一般是pvr  也是有损的图像压缩方式<br>pvr压缩分成 pvrtc2 pvrtc4一个是2bits 一个是4bits<br>除了压缩内存的优势还可以直接被显卡读取 载入速度更快  缺点是需要PowerVR芯片支持  目前ios设备都能完美支持 </p>\n<blockquote>\n<p><a href=\"http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.Legacy.pdf\" target=\"_blank\" rel=\"external\">pvr的格式</a> <a href=\"http://web.onetel.net.uk/~simonnihal/assorted3d/fenney03texcomp.pdf\" target=\"_blank\" rel=\"external\">算法原理</a><br>pvr文件分成两部分<br>| Header|     Texture Data|<br>| :——– | ——–:|<br>| 44 (pvr1) or 52 bytes(pvr2)|  大于等于0bytes |<br>算法原理比较高深 看不懂 也没有细看<br>文章中的这副图 可以看到 跟ETC有点像 也是把4x4的pixel压缩到64bits里面 16bit是Base ColourB<br>15bit是Base ColourB 还有个Mod Mode存一个bit 剩下的32bits是 Modulation Data每2bits对应一个像素点 对应关系如下：<br><img src=\"/2017/09/10/picture-texture/1504511314399.png\" alt=\"Alt text\"><br><img src=\"/2017/09/10/picture-texture/1504509740940.png\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"4、从上面的1文件格式、2纹理格式、3压缩算法-应用到一些问题上：\"><a href=\"#4、从上面的1文件格式、2纹理格式、3压缩算法-应用到一些问题上：\" class=\"headerlink\" title=\"4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：\"></a>4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：</h4><p>下面图片是一张图片的三个格式 png32 pvr pkm<br><img src=\"/2017/09/10/picture-texture/1504516848865.png\" alt=\"Alt text\"><br><img src=\"/2017/09/10/picture-texture/1504516795002.png\" alt=\"Alt text\"></p>\n<ol>\n<li>第一个问题，理论上png32 512x512 大小应该是512x512x4bytes（1M） 但是这里显示217km?<br>这个是因为png32文件也有自己的压缩，这张png32在内存里面用的是1M  但是文件格式有自己的无损压缩方法 所以小于1M</li>\n<li>pvr的是一个像素4bits  所以应该是 512x512x0.5bytes=128km  这里是129kb<br>因为pvr分为 Header和Texture Data 多出的1k byte存头部</li>\n</ol>\n<hr>\n<p>参考引用：<br>pvr和png内存占用<br><a href=\"http://blog.csdn.net/kaitiren/article/details/8054856\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/kaitiren/article/details/8054856</a><br><a href=\"http://www.cnblogs.com/xulidong/p/5681351.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/xulidong/p/5681351.html</a></p>\n<p>纹理格式<br><a href=\"http://blog.csdn.net/ynnmnm/article/details/44983545\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ynnmnm/article/details/44983545</a></p>\n<p>附：<br>安卓设备市场份额的分布（谷歌统计）<br><a href=\"https://developer.android.com/about/dashboards/index.html\" target=\"_blank\" rel=\"external\">https://developer.android.com/about/dashboards/index.html</a></p>\n","excerpt":"<blockquote>\n<p>我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，<strong>本文就来梳理一下这些名字，作简要的解释。</strong></p>\n</blockquote>\n<h3 id=\"一、首先我们来分类一下\"><a href=\"#一、首先我们来分类一下\" class=\"headerlink\" title=\"一、首先我们来分类一下\"></a>一、首先我们来分类一下</h3><h4 id=\"1、文件格式：图片在硬盘中的格式\"><a href=\"#1、文件格式：图片在硬盘中的格式\" class=\"headerlink\" title=\"1、文件格式：图片在硬盘中的格式\"></a>1、文件格式：图片在硬盘中的格式</h4><h4 id=\"2、纹理格式：这里我认为是：包括了-在内存里面的格式和在传给GPU的纹理。\"><a href=\"#2、纹理格式：这里我认为是：包括了-在内存里面的格式和在传给GPU的纹理。\" class=\"headerlink\" title=\"2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。\"></a>2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。</h4><h4 id=\"3、压缩算法：etc（本文会详细解释此算法）、pvr等\"><a href=\"#3、压缩算法：etc（本文会详细解释此算法）、pvr等\" class=\"headerlink\" title=\"3、压缩算法：etc（本文会详细解释此算法）、pvr等\"></a>3、压缩算法：etc（本文会详细解释此算法）、pvr等</h4>","more":"<h3 id=\"二、稍微深入的讲解\"><a href=\"#二、稍微深入的讲解\" class=\"headerlink\" title=\"二、稍微深入的讲解\"></a>二、稍微深入的讲解</h3><h4 id=\"1、文件格式：\"><a href=\"#1、文件格式：\" class=\"headerlink\" title=\"1、文件格式：\"></a>1、文件格式：</h4><ul>\n<li>我们说的png、jpg、bmp指的是文件格式，就是图片在硬盘里面存储的格式，或者是手机的存储里面的格式，游戏的资源的格式。</li>\n<li>引用百度百科里面的话：图像格式即图像文件存放的格式，通常有JPEG、TIFF、RAW、BMP、GIF、PNG。<br><strong>PNG：提取<a href=\"http://blog.csdn.net/bisword/article/details/2777121\">《PNG文件格式详解》</a>这篇文章的解释：</strong><br>png文件由PNG文件标志（文件头）、3个以上的PNG的数据块（Chunk）按照特定的顺序组成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">PNG文件标志</th>\n<th style=\"text-align:left\">Chunk</th>\n<th style=\"text-align:left\">…</th>\n<th style=\"text-align:left\">Chunk</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>下面这个表格是数据块chunk的内容（主要的chunk）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据块符号</th>\n<th style=\"text-align:left\">数据块名称</th>\n<th style=\"text-align:left\">多数据块</th>\n<th style=\"text-align:left\">位置限制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IHDR</td>\n<td style=\"text-align:left\">文件头数据块</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">第一块</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PLTE</td>\n<td style=\"text-align:left\">调色板数据块</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">在IDAT之前</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IDAT</td>\n<td style=\"text-align:left\">图像数据块</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">与其他IDAT连续</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IEND</td>\n<td style=\"text-align:left\">图像结束数据</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">最后一个数据块</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2、纹理格式\"><a href=\"#2、纹理格式\" class=\"headerlink\" title=\"2、纹理格式\"></a>2、纹理格式</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">纹理格式</th>\n<th style=\"text-align:left\">解释</th>\n<th style=\"text-align:left\">其他</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">RGBA8888</td>\n<td style=\"text-align:left\">RGBA 各占8位bit， 一个像素就4byte</td>\n<td style=\"text-align:left\">（1）常用地方：整个场景背景图片 大量的渐变色图片 （2）OpenGL ES生成纹理在生成纹理时大小会自动扩展成2的幂次方。不足自动向下调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BGRA8888</td>\n<td style=\"text-align:left\">跟RGBA8888顺序不一样</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGBA4444</td>\n<td style=\"text-align:left\">RGBA 各占4位bit 一个像素就2byte</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGB888</td>\n<td style=\"text-align:left\">这个相比第一种 RGBA8888 没有 alpha通道 用在没有透明度的图片 游戏背景图片。</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGB565</td>\n<td style=\"text-align:left\">这个是高品质的16位纹理  也是没有透明度</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RGBA5551</td>\n<td style=\"text-align:left\">透明度只有0 和 1 没有渐变的图片</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC2</td>\n<td style=\"text-align:left\">iphone 的图片芯片 对一种称为 PVRTC 的压缩技术提供硬件支持所有颜色和透明度占2个字节(品质可能有点低)</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC4</td>\n<td style=\"text-align:left\">所有颜色和透明度占4个字节,在ios上基本都用这个格式</td>\n<td style=\"text-align:left\">(iOS产品专用)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC2_NOALPHA</td>\n<td style=\"text-align:left\">RGB占用2个字节，没用ALPHA通道</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PVRTC4_NOALPHA</td>\n<td style=\"text-align:left\">RGB占用4个字节，没用ALPHA通道</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ETC1</td>\n<td style=\"text-align:left\">安卓常用的压缩格式</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ETC2</td>\n<td style=\"text-align:left\">安卓常用的压缩格式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3、压缩算法\"><a href=\"#3、压缩算法\" class=\"headerlink\" title=\"3、压缩算法\"></a>3、压缩算法</h4><h5 id=\"Android设备\"><a href=\"#Android设备\" class=\"headerlink\" title=\"Android设备\"></a>Android设备</h5><ol>\n<li>首先，android设备一般使用ETC1压缩  一种有损的图像压缩方式：<br>ETC1是opengl2.0 压缩之后每个像素占用4bit  压缩之后的格式为KTX或者PKM  前者支持存储多纹理 后者只支持单纹理<br>1024的RGBA32占用内存4M 如果是etc1的压缩之后就是0.5M<br>ETC1的缺点是不支持Alpha通道 不支持有透明度的图片压缩</li>\n<li><p>ETC2解决了Alpha通道 但是它是Opengl3.0标准  考虑到2.0设备市场占用率  一般使用ETC1<br>【附】止于 2017 年 8 月 8 日在<a href=\"https://developer.android.com/about/dashboards/index.html\">安卓开发者中心</a>看到<br>| OpenGL ES Version|     Distribution|<br>| :——– | ——–:|<br>| 2.0    | 37.6%|<br>| 3.0    | 45.6%|<br>| 3.1|     16.8%| </p>\n</li>\n<li><p>算法过程解释</p>\n<blockquote>\n<p><a href=\"https://www.khronos.org/registry/OpenGL/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt\">ETC压缩算法</a>翻译：<br>读这篇文章可以了解 用中文尽可能表达一遍<br><strong>1.总体了解下：</strong>ETC的压缩单元是4x4的像素块，会把一个4x4的像素块压缩成一个64bit中。</p>\n<p><strong>2.下面介绍几张表：</strong>  encode decode过程会使用到的</p>\n<p><strong>1）像素表（源表）</strong>下图就是这个4x4的像素块的表 每个pixel如果用RGBA8888表示 那就是4x4x4 64字节<br>| pixel| pixel| pixel| pixel|<br>|  :——– | :——– |<br>| a  |e |i| m|<br>| b  |f |j| n|<br>| c  |g |k| o|<br>| d  |h |l| p|<br><strong>2）压缩后表（结果表）</strong> 下图就是压缩后的64bit 每个bit要么是0 要么是1：<br>| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit|<br>|  :——– | :——– |<br>|63|62|61|60|59|58|57|56|55|54|53|52|51|50|49|48|<br>| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|<br>|47|46|45|44|43|42|41|40|39|38|37|36|35|34|33|32|<br>|  0| 0| 0| 0| 0| 0| 0| 0| table cw 1| table cw 1| table cw 1| table cw 2| table cw 2| table cw 2| diff bit| flip bit|<br>|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|<br>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|<br>|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|<br>|  0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|</p>\n<p><strong>3）下面这些表示预存储的表 就是不占文件大小 decode encode过程 调用算法使用的表</strong><br>3.1）像素差值表 待会会来这里索引取值<br><img src=\"/2017/09/10/picture-texture/1504488376717.png\" alt=\"Alt text\"><br>3.2）间隔表 待会也会来这里索引取值<br><img src=\"/2017/09/10/picture-texture/1504488394913.png\" alt=\"Alt text\"></p>\n<p><strong>3.下面正式介绍算法过程：</strong>   encode过程<br>①<strong>第32bit是flipbit</strong><br><strong>如果这个bit是0</strong>  那么这个块分成2个2x4的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）<br><img src=\"/2017/09/10/picture-texture/1504488756715.png\" alt=\"Alt text\"><br><strong>如果这个bit是1</strong> 那么这个块分成2个4x2的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）<br><img src=\"/2017/09/10/picture-texture/1504488781878.png\" alt=\"Alt text\"><br>②<strong>分块之后计算这两个块的颜色均值</strong>，存储颜色均值的方法有两种，用第33bit（diffbit）来表示用了哪种存储颜色均值的方法，每个subblock用12bits存储颜色均值 两个block就是24bits （均值用了24bits 用一个bit表示用了哪个存储颜色均值的方法 所以用了25bit 现在剩下38bits）<br><strong>如果第33bit（diffbit）是0 那么颜色均值方法如下：</strong><br>下图是用63到40（一共24bits）来存均值，图中标注了 63-60是给R1 55-52是给G1 47-44是给B1<br>举例子,如果 R1 = 14 =1110b, G1 = 3 = 0011b and B1 = 8 = 1000b, 那么subblock的均值的红色部分是11101110b = 238 绿色部分 00110011b = 51 蓝色部分10001000b = 136.<br><img src=\"/2017/09/10/picture-texture/1504489517922.png\" alt=\"Alt text\"><br><strong>如果第33bit（diffbit）是1 那么颜色均值方法如下：</strong><br>下图是用63到40（一共24bits）来存颜色均值，图中标注了 63-59是给R1 55-51是给G1 47-43是给B1<br>举个例子，如果 R1’ = 28 = 11100b,  那么subblock的均值的红色部分是11100111b = 231. 同理绿色部分G1’ = 4 = 00100b 蓝色部分B1’ = 3 = 00011b, 结果是 00100001b = 33 and 00011000b = 24<br><strong>这里有点特殊的是第二个块</strong> R、G、B分别只有3bits，也是举例子：如果 R1’ = 28 = 11100b   R2 = 100b = -4, 那么28+(-4)=24 = 11000b, 所以第二个块的R是 11000110b = 198. 同理可得G2 B2<br><img src=\"/2017/09/10/picture-texture/1504491196164.png\" alt=\"Alt text\"><br>③<strong>我们先看到<img src=\"/2017/09/10/picture-texture/1504492132538.png\" alt=\"Alt text\">39 38 37 bit</strong> 三个bit用于确定是用哪个像素差值表 看到2.3.1的表 有8行 刚好3个bit可以确定是哪行 如果39 38 37 bit是010 那个是2 也就是用-29 -9 9 29这行 同理36 35 34 bit<br>然后现在还有32个bit没有解释，剩下的是第31到第0bit， 我们最原始的像素是16个像素 现在每个像素只有2bit了 我们看这个表可以查询一个映射关系<br><strong>下面的表</strong> 例如像素d 对应的是19bit和3bit  <strong>举个例子</strong> 19bit是1 3bit是0 那么合起来就是01 我们看到间隔表（2.3.2的表）</p>\n<p><img src=\"/2017/09/10/picture-texture/1504492579311.png\" alt=\"Alt text\"></p>\n<p>对应的是b  刚刚我们的像素差值行是[-29 -9 9 29] 所以<strong>得到的值是29</strong> 假设我们的均值颜色是<strong>(231, 8, 16)</strong>那个对应的颜色就是<strong>(231+29, 8+29, 16+29)</strong> 如果越界255 则归为255 所以是<strong>(255, 37, 45)</strong></p>\n<p><img src=\"/2017/09/10/picture-texture/1504492407923.png\" alt=\"Alt text\"></p>\n<p><strong>上面的过程归结到流程图中</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;st=&gt;start: Start</div><div class=\"line\">&gt;e=&gt;end</div><div class=\"line\">&gt;op1=&gt;operation:  ①4x4的像素块是分成2个2x4的</div><div class=\"line\">&gt;还是2个4x2的 横切还是竖切？</div><div class=\"line\">&gt;op2=&gt;operation: ②存储颜色均值是用哪种方法？</div><div class=\"line\">&gt;op3=&gt;operation: ③使用table codeword哪个表？</div><div class=\"line\">&gt;op4=&gt;operation: ③16个像素点的像素值跟均值的差值是多少？查表填相应数值</div><div class=\"line\">&gt;st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e</div><div class=\"line\">&gt;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"Ios设备\"><a href=\"#Ios设备\" class=\"headerlink\" title=\"Ios设备\"></a>Ios设备</h5><p>ios设备中采用的图像格式一般是pvr  也是有损的图像压缩方式<br>pvr压缩分成 pvrtc2 pvrtc4一个是2bits 一个是4bits<br>除了压缩内存的优势还可以直接被显卡读取 载入速度更快  缺点是需要PowerVR芯片支持  目前ios设备都能完美支持 </p>\n<blockquote>\n<p><a href=\"http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.Legacy.pdf\">pvr的格式</a> <a href=\"http://web.onetel.net.uk/~simonnihal/assorted3d/fenney03texcomp.pdf\">算法原理</a><br>pvr文件分成两部分<br>| Header|     Texture Data|<br>| :——– | ——–:|<br>| 44 (pvr1) or 52 bytes(pvr2)|  大于等于0bytes |<br>算法原理比较高深 看不懂 也没有细看<br>文章中的这副图 可以看到 跟ETC有点像 也是把4x4的pixel压缩到64bits里面 16bit是Base ColourB<br>15bit是Base ColourB 还有个Mod Mode存一个bit 剩下的32bits是 Modulation Data每2bits对应一个像素点 对应关系如下：<br><img src=\"/2017/09/10/picture-texture/1504511314399.png\" alt=\"Alt text\"><br><img src=\"/2017/09/10/picture-texture/1504509740940.png\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"4、从上面的1文件格式、2纹理格式、3压缩算法-应用到一些问题上：\"><a href=\"#4、从上面的1文件格式、2纹理格式、3压缩算法-应用到一些问题上：\" class=\"headerlink\" title=\"4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：\"></a>4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：</h4><p>下面图片是一张图片的三个格式 png32 pvr pkm<br><img src=\"/2017/09/10/picture-texture/1504516848865.png\" alt=\"Alt text\"><br><img src=\"/2017/09/10/picture-texture/1504516795002.png\" alt=\"Alt text\"></p>\n<ol>\n<li>第一个问题，理论上png32 512x512 大小应该是512x512x4bytes（1M） 但是这里显示217km?<br>这个是因为png32文件也有自己的压缩，这张png32在内存里面用的是1M  但是文件格式有自己的无损压缩方法 所以小于1M</li>\n<li>pvr的是一个像素4bits  所以应该是 512x512x0.5bytes=128km  这里是129kb<br>因为pvr分为 Header和Texture Data 多出的1k byte存头部</li>\n</ol>\n<hr>\n<p>参考引用：<br>pvr和png内存占用<br><a href=\"http://blog.csdn.net/kaitiren/article/details/8054856\">http://blog.csdn.net/kaitiren/article/details/8054856</a><br><a href=\"http://www.cnblogs.com/xulidong/p/5681351.html\">http://www.cnblogs.com/xulidong/p/5681351.html</a></p>\n<p>纹理格式<br><a href=\"http://blog.csdn.net/ynnmnm/article/details/44983545\">http://blog.csdn.net/ynnmnm/article/details/44983545</a></p>\n<p>附：<br>安卓设备市场份额的分布（谷歌统计）<br><a href=\"https://developer.android.com/about/dashboards/index.html\">https://developer.android.com/about/dashboards/index.html</a></p>"},{"title":"temp","date":"2017-08-01T14:49:39.000Z","_content":"# unity 问题\n\n看网络上的问题 记录一下\n\n<!-- more -->\n\n## 1、协同程序 \n一般用于控制运动 序列以及对象的行为\n\n## 2、Unity3d中的碰撞器和触发器的区别？\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n\n## 3、物体发生碰撞的必要条件\n两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体。\n\n\n## 4、了解  动态欧拉角 造成万向锁的现象\n\n## 5、生命周期\nAwake->OnEnable->Start\nhttp://www.jianshu.com/p/8c353abb42e4\n\n## 6、点光源 聚光灯 平行光 区域光源\n\n## 7、应用阶段 -> 几何阶段 -> 光栅化阶段\n顶点着色器 几何着色器 \n\n## 8、内存优化\n1、压缩自带\n2、暂时不用的以后还需要使用的物体 隐藏起来 \n3、释放 AssetBundle 占用的资源\n4、降低模型的片面数 降低模型的骨骼数量\n5、是哟个 lod 使用 shader\n\n## 9、动态加载资源的方法\n1、 Resource.load\n2、\n\n## 10、物理更新适合放在 FixedUpdate\n\n## 11、游戏场景中放置多个 Camera会可能到混合\n\n## 12、有些有哪些动画类型\n关节动画 骨骼动画  关键帧动画\n\n## 13、diffuse 光照计算公式\ndiffuse = kd * colorlight * max(0,N*L)\n\n\n## 14、两种阴影判断的方法和工作原理\n","source":"_posts/temp.md","raw":"---\ntitle: temp\ndate: 2017-08-01 22:49:39\ntags: unity\n---\n# unity 问题\n\n看网络上的问题 记录一下\n\n<!-- more -->\n\n## 1、协同程序 \n一般用于控制运动 序列以及对象的行为\n\n## 2、Unity3d中的碰撞器和触发器的区别？\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n\n## 3、物体发生碰撞的必要条件\n两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体。\n\n\n## 4、了解  动态欧拉角 造成万向锁的现象\n\n## 5、生命周期\nAwake->OnEnable->Start\nhttp://www.jianshu.com/p/8c353abb42e4\n\n## 6、点光源 聚光灯 平行光 区域光源\n\n## 7、应用阶段 -> 几何阶段 -> 光栅化阶段\n顶点着色器 几何着色器 \n\n## 8、内存优化\n1、压缩自带\n2、暂时不用的以后还需要使用的物体 隐藏起来 \n3、释放 AssetBundle 占用的资源\n4、降低模型的片面数 降低模型的骨骼数量\n5、是哟个 lod 使用 shader\n\n## 9、动态加载资源的方法\n1、 Resource.load\n2、\n\n## 10、物理更新适合放在 FixedUpdate\n\n## 11、游戏场景中放置多个 Camera会可能到混合\n\n## 12、有些有哪些动画类型\n关节动画 骨骼动画  关键帧动画\n\n## 13、diffuse 光照计算公式\ndiffuse = kd * colorlight * max(0,N*L)\n\n\n## 14、两种阴影判断的方法和工作原理\n","slug":"temp","published":1,"updated":"2018-05-11T10:13:52.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o5d0005znmjs5kfmhto","content":"<h1 id=\"unity-问题\"><a href=\"#unity-问题\" class=\"headerlink\" title=\"unity 问题\"></a>unity 问题</h1><p>看网络上的问题 记录一下</p>\n<a id=\"more\"></a>\n<h2 id=\"1、协同程序\"><a href=\"#1、协同程序\" class=\"headerlink\" title=\"1、协同程序\"></a>1、协同程序</h2><p>一般用于控制运动 序列以及对象的行为</p>\n<h2 id=\"2、Unity3d中的碰撞器和触发器的区别？\"><a href=\"#2、Unity3d中的碰撞器和触发器的区别？\" class=\"headerlink\" title=\"2、Unity3d中的碰撞器和触发器的区别？\"></a>2、Unity3d中的碰撞器和触发器的区别？</h2><p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。<br>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；<br>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<h2 id=\"3、物体发生碰撞的必要条件\"><a href=\"#3、物体发生碰撞的必要条件\" class=\"headerlink\" title=\"3、物体发生碰撞的必要条件\"></a>3、物体发生碰撞的必要条件</h2><p>两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体。</p>\n<h2 id=\"4、了解-动态欧拉角-造成万向锁的现象\"><a href=\"#4、了解-动态欧拉角-造成万向锁的现象\" class=\"headerlink\" title=\"4、了解  动态欧拉角 造成万向锁的现象\"></a>4、了解  动态欧拉角 造成万向锁的现象</h2><h2 id=\"5、生命周期\"><a href=\"#5、生命周期\" class=\"headerlink\" title=\"5、生命周期\"></a>5、生命周期</h2><p>Awake-&gt;OnEnable-&gt;Start<br><a href=\"http://www.jianshu.com/p/8c353abb42e4\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/8c353abb42e4</a></p>\n<h2 id=\"6、点光源-聚光灯-平行光-区域光源\"><a href=\"#6、点光源-聚光灯-平行光-区域光源\" class=\"headerlink\" title=\"6、点光源 聚光灯 平行光 区域光源\"></a>6、点光源 聚光灯 平行光 区域光源</h2><h2 id=\"7、应用阶段-gt-几何阶段-gt-光栅化阶段\"><a href=\"#7、应用阶段-gt-几何阶段-gt-光栅化阶段\" class=\"headerlink\" title=\"7、应用阶段 -&gt; 几何阶段 -&gt; 光栅化阶段\"></a>7、应用阶段 -&gt; 几何阶段 -&gt; 光栅化阶段</h2><p>顶点着色器 几何着色器 </p>\n<h2 id=\"8、内存优化\"><a href=\"#8、内存优化\" class=\"headerlink\" title=\"8、内存优化\"></a>8、内存优化</h2><p>1、压缩自带<br>2、暂时不用的以后还需要使用的物体 隐藏起来<br>3、释放 AssetBundle 占用的资源<br>4、降低模型的片面数 降低模型的骨骼数量<br>5、是哟个 lod 使用 shader</p>\n<h2 id=\"9、动态加载资源的方法\"><a href=\"#9、动态加载资源的方法\" class=\"headerlink\" title=\"9、动态加载资源的方法\"></a>9、动态加载资源的方法</h2><p>1、 Resource.load<br>2、</p>\n<h2 id=\"10、物理更新适合放在-FixedUpdate\"><a href=\"#10、物理更新适合放在-FixedUpdate\" class=\"headerlink\" title=\"10、物理更新适合放在 FixedUpdate\"></a>10、物理更新适合放在 FixedUpdate</h2><h2 id=\"11、游戏场景中放置多个-Camera会可能到混合\"><a href=\"#11、游戏场景中放置多个-Camera会可能到混合\" class=\"headerlink\" title=\"11、游戏场景中放置多个 Camera会可能到混合\"></a>11、游戏场景中放置多个 Camera会可能到混合</h2><h2 id=\"12、有些有哪些动画类型\"><a href=\"#12、有些有哪些动画类型\" class=\"headerlink\" title=\"12、有些有哪些动画类型\"></a>12、有些有哪些动画类型</h2><p>关节动画 骨骼动画  关键帧动画</p>\n<h2 id=\"13、diffuse-光照计算公式\"><a href=\"#13、diffuse-光照计算公式\" class=\"headerlink\" title=\"13、diffuse 光照计算公式\"></a>13、diffuse 光照计算公式</h2><p>diffuse = kd <em> colorlight </em> max(0,N*L)</p>\n<h2 id=\"14、两种阴影判断的方法和工作原理\"><a href=\"#14、两种阴影判断的方法和工作原理\" class=\"headerlink\" title=\"14、两种阴影判断的方法和工作原理\"></a>14、两种阴影判断的方法和工作原理</h2>","excerpt":"<h1 id=\"unity-问题\"><a href=\"#unity-问题\" class=\"headerlink\" title=\"unity 问题\"></a>unity 问题</h1><p>看网络上的问题 记录一下</p>","more":"<h2 id=\"1、协同程序\"><a href=\"#1、协同程序\" class=\"headerlink\" title=\"1、协同程序\"></a>1、协同程序</h2><p>一般用于控制运动 序列以及对象的行为</p>\n<h2 id=\"2、Unity3d中的碰撞器和触发器的区别？\"><a href=\"#2、Unity3d中的碰撞器和触发器的区别？\" class=\"headerlink\" title=\"2、Unity3d中的碰撞器和触发器的区别？\"></a>2、Unity3d中的碰撞器和触发器的区别？</h2><p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。<br>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；<br>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<h2 id=\"3、物体发生碰撞的必要条件\"><a href=\"#3、物体发生碰撞的必要条件\" class=\"headerlink\" title=\"3、物体发生碰撞的必要条件\"></a>3、物体发生碰撞的必要条件</h2><p>两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体。</p>\n<h2 id=\"4、了解-动态欧拉角-造成万向锁的现象\"><a href=\"#4、了解-动态欧拉角-造成万向锁的现象\" class=\"headerlink\" title=\"4、了解  动态欧拉角 造成万向锁的现象\"></a>4、了解  动态欧拉角 造成万向锁的现象</h2><h2 id=\"5、生命周期\"><a href=\"#5、生命周期\" class=\"headerlink\" title=\"5、生命周期\"></a>5、生命周期</h2><p>Awake-&gt;OnEnable-&gt;Start<br><a href=\"http://www.jianshu.com/p/8c353abb42e4\">http://www.jianshu.com/p/8c353abb42e4</a></p>\n<h2 id=\"6、点光源-聚光灯-平行光-区域光源\"><a href=\"#6、点光源-聚光灯-平行光-区域光源\" class=\"headerlink\" title=\"6、点光源 聚光灯 平行光 区域光源\"></a>6、点光源 聚光灯 平行光 区域光源</h2><h2 id=\"7、应用阶段-gt-几何阶段-gt-光栅化阶段\"><a href=\"#7、应用阶段-gt-几何阶段-gt-光栅化阶段\" class=\"headerlink\" title=\"7、应用阶段 -&gt; 几何阶段 -&gt; 光栅化阶段\"></a>7、应用阶段 -&gt; 几何阶段 -&gt; 光栅化阶段</h2><p>顶点着色器 几何着色器 </p>\n<h2 id=\"8、内存优化\"><a href=\"#8、内存优化\" class=\"headerlink\" title=\"8、内存优化\"></a>8、内存优化</h2><p>1、压缩自带<br>2、暂时不用的以后还需要使用的物体 隐藏起来<br>3、释放 AssetBundle 占用的资源<br>4、降低模型的片面数 降低模型的骨骼数量<br>5、是哟个 lod 使用 shader</p>\n<h2 id=\"9、动态加载资源的方法\"><a href=\"#9、动态加载资源的方法\" class=\"headerlink\" title=\"9、动态加载资源的方法\"></a>9、动态加载资源的方法</h2><p>1、 Resource.load<br>2、</p>\n<h2 id=\"10、物理更新适合放在-FixedUpdate\"><a href=\"#10、物理更新适合放在-FixedUpdate\" class=\"headerlink\" title=\"10、物理更新适合放在 FixedUpdate\"></a>10、物理更新适合放在 FixedUpdate</h2><h2 id=\"11、游戏场景中放置多个-Camera会可能到混合\"><a href=\"#11、游戏场景中放置多个-Camera会可能到混合\" class=\"headerlink\" title=\"11、游戏场景中放置多个 Camera会可能到混合\"></a>11、游戏场景中放置多个 Camera会可能到混合</h2><h2 id=\"12、有些有哪些动画类型\"><a href=\"#12、有些有哪些动画类型\" class=\"headerlink\" title=\"12、有些有哪些动画类型\"></a>12、有些有哪些动画类型</h2><p>关节动画 骨骼动画  关键帧动画</p>\n<h2 id=\"13、diffuse-光照计算公式\"><a href=\"#13、diffuse-光照计算公式\" class=\"headerlink\" title=\"13、diffuse 光照计算公式\"></a>13、diffuse 光照计算公式</h2><p>diffuse = kd <em> colorlight </em> max(0,N*L)</p>\n<h2 id=\"14、两种阴影判断的方法和工作原理\"><a href=\"#14、两种阴影判断的方法和工作原理\" class=\"headerlink\" title=\"14、两种阴影判断的方法和工作原理\"></a>14、两种阴影判断的方法和工作原理</h2>"},{"title":"Unity安装->入门->工程学习->shader","date":"2017-07-30T04:49:39.000Z","reward":true,"_content":"\n\n\n## 总体的思维导图\n通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。\n![Alt text](./1496577433020.png)\n\n<!-- more -->\n\n\n\n## 一、安装\n#### 1、安装教程（windows）\nmac就比较简单 官网下载dmg就可以安装使用了\n我用下面图中的两个文件完成安装，一个是安装文件（4.7），一个是破解，然后根据下面链接完成安装\n![Alt text](./1496577678948.png)\n\nhttp://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html\n\n#### 2、需要的文件（百度网盘分享）\n\nhttp://pan.baidu.com/s/1slFHeFz\n\n- 分享的文件里的东西有：\n\t- 【安装使用】：Unity 4.7.1安装文件\n\t- 【安装使用】：Unity 4.x pro Patch.exe\n\t- 【入门使用】：《unity4.x从入门到精通》\n\t- 【入门使用】：简单的工程（微信飞机游戏）：\n\t- 【进一步了解使用】：RPG游戏的简单的工程\n\t- 【shader学习使用】：《Unity Shader入门精要》\n\t- \n#### 3、安装结果\n使用a.Unity 4.7.1安装文件 b.Unity 4.x pro Patch.exe  然后用上上面的教程链接就可以完成windows unity的安装  打开如下：\n![Alt text](./1496583208861.png)\n\n\n\n## 二、入门学习：\n#### 1、开始我找了本书看《unity4.x从入门到精通》：\n《unity4.x从入门到精通》\nhttp://pan.baidu.com/s/1slFHeFz\n\n#### 2、《unity4.x从入门到精通》读书的记录：\n##### 第一章 （可跳过）\n第一章 没什么干货 可以直接跳过\n\n##### 第二章  （重点看2.1  2.2+实操一下）\n- 刚接触的unity的可以按照第二章说的去操作一下  感受一下unity的一些功能 想贪快的就看**2.1** 、**2.2**部分即可 后面的用到再查阅\n- 快捷键部分 等到基本入门了 再来看一遍 会比较受用的感觉  \n\n##### 第三章 （粗略看）\n- 第三章看下 不用纠那么细致 \n##### 第四章 （重点看+操作）\n- 第四章书讲的是怎么写代码的 看完第四章就会输出hello world\n##### 截取两张图\n![Alt text](./1490002232972.png)\n![Alt text](./1490002240157.png)\n\n\n\n##### 后面5-17章的当作工具书看\n\n12章 到16  是针对开发的介绍\n\n17章 进阶 ： 网络\n\n\n#### 3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：\n##### 3.1、C#代码跟unity怎么关联起来？  书中13章![Alt text](./1491552037983.png)\n###### 1、C#脚本的规则\n（1）凡事需要添加到游戏对象的C#脚本类都是需要直接或者间接的继承 MonoBehaviour 如果在unity添加脚本 unity会自动填充继承MonoBehaviour的代码  如果是自己新建一个文件 然后在unity从拖拽添加component 这样是不会成功的（后面会说unity怎么添加C#文件）\n\n（2）继承了MonoBehaviour的类 都会有Start 和 Awake函数的继承  一般使用Start和Awake来初始化  不使用构造函数的原因是unity中无法确定构造函数的顺序。这里我觉得有个原因是：unity会把所有绑定在对象身上的类实例化  然后才可以GetComponent()  例如：下面的操作如果在构造函数中做 可能PlayerAttack这个没有实例化 那么获取不到  所以把初始化工作放在Start中\n![Alt text](./1491552515808.png)\n\n（3）类名和脚本文件名相同 \n\n（4）协同函数Coroutines 返回类型必须是Ienumerator\n\n（5）C#不支持自定义命名空间\n\n###### 2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）\n1、创建脚本的方法：\n![Alt text](./1491553048549.png)\n\n2、创建完之后的编辑：\n这里可以修改用MonoDevelop的编辑器 或者用Vs2012作为代码编辑\n![Alt text](./1491553152505.png)\n\n3、关联到对象去\n（3.1）添加一个gameobject \n![Alt text](./1491553612376.png)\n（3.2） 然后给gameObject添加脚本\n![Alt text](./1491553537327.png)![Alt text](./1491553548688.png)\n\n在Unity中，继承MonoBehaviour的C#脚本都被看作一个Component 游戏对象可以理解为一个容纳各种类型component的容器 游戏对象的所有component一起决定了这个对象的行为表现 这个对象被添加到scene中之后 然后点击build and run 之后这个脚本的Start函数就会被调用一起  可以在这里输出 hello world  这就算是unity的hello world\n\n\n###### 3、怎么获取别的对象以及他的component\n使用函数 GameObject.Find  null则是找不到  根据类名\n使用函数GameObject.FindWithTag\n还有在unity编辑器中拖拽\n\n查看数组的表13-6 表13-7  表13-8  表13-9 \n\n![Alt text](./1491555497064.png)\n![Alt text](./1491555396564.png)\n![Alt text](./1491555581945.png)\n![Alt text](./1491555622726.png)\n![Alt text](./1491555636221.png)\n\n\n\n## 三、工程学习：\n看了《unity4.x从入门到精通》 简单操作unity之后 我上网找几个简单的游戏demo来看下，这样我觉得会比较快上手。\n### 1、微信飞机大战\n工程下载地址：\nhttp://pan.baidu.com/s/1slFHeFz （网上找的工程）\n这个比较容易看懂   \n\n下面说明的过程：\n（1）背景移动 -->（2）敌机出生-->（3）自己的飞行\n![背景移动](./ply1.gif)==》 ![敌机出生](./ply2.gif)==》 ![自己的飞行](./ply3.gif)\n\n\n\n\n\n#### 1、初看这个工程\n只有一个场景scene\n![Alt text](./1496655674282.png)\n预制体有这些\n![Alt text](./1496663793026.png)\n脚本是这些\n![Alt text](./1496663193818.png)\n#### 2、分几个部分看\n##### 2.1、scene\n![Alt text](./1496664667730.png)\n1.里面有个 Main Camera 点击它然后看导航栏Inspector\n2.Main Camera里面有一些component组件 其中Camera 去修改size view port然后运行看下结果 \n![Alt text](./1496664752184.png)\n3.除了Main Camera 这个Scene里面还有一些飞机（hero） 背景（bg） 还一些不是UI的东西（bombManager）\n\n上面大概的了解到，在这个Scene里面拖拽了一些物件 还有一个摄像机 把这些物件投影到屏幕中，到目前为止，我们大概知道是怎么得到游戏的静态界面的，但是游戏是怎么动起来的还不知道。接下来脚本就是讲怎么动起来的。\n\n\n##### 2.2、脚本\n1. 代码入口，没有一个明确的Main函数入口  \n下面按照顺序说下（1）背景移动 （2）怎么生成敌机  （3）怎么控制自己的战机\n![Alt text](./1496665501144.png)\n（1）背景移动 \nscene里面有个object叫bg 然后再点击其中一个background查看导航栏 \n可以看到每个background都挂在了一个脚本组件 BackgroundTransform.cs  这个脚本就是控制不背景移动的\n![Alt text](./1497515757683.png)\n![Alt text](./1497515795595.png)\n\n看到BackgroundTransform这个脚本 两个背景来控制屏幕的背景交替向下移动\n```\npublic class BackgroundTransform : MonoBehaviour {\n\tpublic static float moveSpeed = 2f;\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n\t\tthis.transform.Translate( Vector3.down * moveSpeed * Time.deltaTime );\n\t\tVector3 postion = this.transform.position;\n\t\tif(postion.y<=-8.52f){\n\t\t\t//有两个背景在交替滚动  如果有一个滚动到屏幕外面则改动显示\n\t\t\tthis.transform.position = new Vector3(postion.x,postion.y+8.52f*2,postion.z );\n\t\t}\n\t}\n}\n```\n\n（2）怎么生成敌机\nscene里面有个叫spawn的东西  这个spawn十个空object 里面挂了一个spawn.cs脚本组件\n![Alt text](./1497516506138.png)\n【代码如下】：\n![Alt text](./1497516724024.png)\n\n\n地机的行为就看模型上面挂的脚本组件Enemy.cs\n\n\n（3）怎么控制自己的战机\n同样的在hero这个上面挂了Hero.cs的脚本组件  然后具体就看里面的代码\n![Alt text](./1497516894694.png)\n\n\n\n\n### 2、RPG游戏\n然后再找个复杂点的游戏工程来看\n#### 1、初看工程 \n- 工程下载地址：\nhttp://pan.baidu.com/s/1slFHeFz（网上找的工程）\n- 工程的脚本目录\n![Alt text](./1491550201008.png)\n\n#### 2、工程代码查看\n**看下怎么把这个人物控制方向运动起来的**\n![Alt text](./rpg.gif)\n\n1.打开03_play这个scene 然后拖拽一个Magician模型到scene中\n先在Prefabs文件夹中找到Magician看模型有什么挂件\n- Magician挂了Character Controller这个控制组件\n这个是角色控制器 可以对角色做移动的操作 在playermove脚本里面用到\n\n- Magician还挂了PlayerDir PlayerMove  PlayerAnimation PlayerState PlayerAttack等脚本来实现模型的行为\n看下PlayerMove的update函数\n![Alt text](./1491550243585.png)\n这里判断如果距离大于0.3f则会移动\n\n\n从Magician引发的问题：\n\n##### 2.1、移动的时候有个targetPosition 这个是怎么来的？\ntargetPosition 是PlayerDir.cs这个里面的成员\nPlayerDir.cs里面会计算鼠标点击屏幕的位置发出的射线的碰撞结果 如果是地面那么修改这个玩家的朝向 \n![Alt text](./1497532344804.png)\n\n\n##### 2.2、又引发一个问题鼠标怎么会变样？\n我们看到03_play这个scene有个object叫GameSetting 这个是一个纯粹为了挂脚本用的object \n![Alt text](./1497531965474.png)\n我们看到这个CursorManager就是我们在游戏中的鼠标的管理类\n\n##### 2.3、模型怎么会动起来呢？\n打开03_play这个scene 然后拖拽一个Magician模型到scene中 然后在菜单栏window animation打开animation窗口 然后可以选择已经做好的动作 attack1 然后点击播放 现在我们知道动作可以预先做好 然后再代码中调用 我们看下代码是怎么调用的 \n![Alt text](./1497533865288.png)\nPlayerAnimation.cs这个脚本 根据一个状态去 播放动画animation.CrossFade(animName);\n\n```\n// Update is called once per frame\n\tvoid LateUpdate () {\n        if (attack.state == PlayerState.ControlWalk) {\n            if (move.state == ControlWalkState.Moving) {\n                PlayAnim(\"Run\");\n            } else if (move.state == ControlWalkState.Idle) {\n                PlayAnim(\"Idle\");\n            }\n        } else if (attack.state == PlayerState.NormalAttack) {\n            if (attack.attack_state == AttackState.Moving) {\n                PlayAnim(\"Run\");\n            }\n        }\n\t}\n\tvoid PlayAnim(string animName) {\n        animation.CrossFade(animName);\n    }\n```\n\n这个项目的运行\n![Alt text](./1491877171720.png)\n![Alt text](./1491877201762.png)\n\n之后看下怎么改改这个项目  不懂的再google 或者再去细看unity的一些用法 或则C#的用法\n\n\n\n## 四、Unity Shader学习\n\n### A、我学习的三个点\n-----------------\n#### 1.下载源码中源码下载：\nhttps://github.com/candycat1992/Unity_Shaders_Book\n\n#### 2.学习hello world!\n**下面gif是unity shader的hello world!**\n![Alt text](./shader2.gif)\n\n#### 3.看书照着源码学习 然后实践\n\n\n\n\n\n \n  \n   \n   \n\n\n### B、学习随便记录的笔记 \n-----------------\n#### 1.第一章\n\n\n#### 2.第二章 渲染流水线\n应用阶段->几何阶段->光栅化阶段\n应用阶段把渲染图元交给几何阶段\n\n##### 2.2CPU 和 GPU 的通信\n1. 把数据加载到显存中\n2. 设置渲染状态\n3. 调用 drallcall\n\n**1.把数据加载到显存中**\n硬盘--->内存--->显存\n顶点数据 法线方向 纹理坐标\n\n**2.设置渲染状态**\nvs ps\n顶点着色器 片元着色器\n\n**3.drawcall**\n\n##### 2.3GPU 流水线\n###### 顶点着色器\n把顶点坐标转换到齐次裁剪坐标系得到归一化的设备坐标 NDC\nopengl unity的 NDC 是-1 1\n屏幕映射 转换到屏幕坐标系\n屏幕坐标系Opengl 是左下角\n\n#### 3.第三章 Unity shader基础\n##### 3.1 创建shader的常见流程\n1. 创建一个材质\n2. 创建一个unity shader 并把它赋给上一步中创建的材质\n3. 把材质赋给要渲染的对象\n4. 在材质面板上（选中材质然后查看导航栏）调整shader的属性\n\n\n##### 3.2 shader lab\nGLSL是opengl的shader语言 Directx的shader语言是HLSL   shader lab的就是 unity shader的shader语言\n可以细看下这个章节  熟悉下语法\n\n#### 4 学习 Shader 所需的数学知识\n一些基础的知识都是大概知道 可以等到要用到的时候再去复习\n一些空间 M 模型空间 W 世界空间 V 摄像机空间 NDC 归一化空间\n\n\n#### 5 开始学习 Shader\n##### 5.2 最简单的片元着色器 顶点着色器\n###### 5.2.2 unity支持的语义：\nPOSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，COLOR\n###### 5.2.3 顶点着色器和片元着色器之间的通信：\n声明一个新的结构体v2f v2f可用于定点着色器和片元着色器之间传递信息\n###### 5.3.1内置包含的文件\n在后面的学习中 总是会用到一些内置的文件\n需要include一下 类似C++的include\n\n##### 5.5 Debug技巧\n1. 把想知道的值赋值到某个颜色 通过屏幕上显示的颜色来判断一个值\n2. 还可以找到一个简单的取色脚本  ColorPicker.cs\n3. 高级的：Visual Studio Graphics Debugger\n4. Unity里面的帧调试器\n\n\n#### 6 Unity 中的基础光照\n##### 6.2 进入摄像机的光分成4个部分\n- 自发光：本身辐射量  如果没有全局光照技术 自会影响自己的辐射量\n- 高光反射：（我觉得是完全镜面反射）光源的完全镜面反射方向散射多少辐射量？？ 是镜面反射的散射？？\n- 漫反射：这个就是光源的漫反射\n- 环境光：其他所有的间接光照\n\n计算高光反射：![Alt text](./1495002356532.png)\nPhong 模型来计算高光反射部分：\n![Alt text](./1495002389507.png)\n\n\n##### 6.4 光照实现\n（1）Properties定义一个颜色值 \n（2）LightMode标签是 Pass 标签的一种 只有定义了正确的 LightMode 我们才能得到一些 Unity的内置光照变量 \nTags { \"LightMode\"=\"ForwardBase\" }\n\n（3）还是之前的 CGPROGRAM ENDCG\n\n（4）为了用到 Unity的内置变量  \n''' #include \"Lighting.cginc\"  \"'\n\n（5）逐顶点 着色器\n\n- 逐顶点漫反射：有锯齿 应该是因为处理是每个片元的顶点 所以不精细\n- 逐像素漫反射：无锯齿 但是黑面太黑 都是一个色 黑色\n- 半伯兰特模型：无锯齿 黑面有渐变\n c = c * m (0.5 (n * I) + 0.5)\n#### 7 基础纹理\n- 记住这个 ： o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n###### 7.1.2 纹理取样\nfixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;\n\n###### 7.2 凹凸映射\n不改变顶点 改变的是绘制 \n法线纹理 normal map\n\n###### 7.2.1高度纹理\n存储的是强度值   这个通过高度来计算法线 \n颜色越浅越突 反而凹\n\n###### 7.2.2法线纹理\n\n法线的向量分量是 -1 到1 \n所以 pixel = (noamal+1)/2\nnormal = (pixel * 2) - 1\n\n这种纹理称为是模型空间的法线纹理  我恩会采用另外一种坐标空间 切线空间  我们用模型顶点的切线空间来存储法线  对于每个顶点都有一个属于自己的切线空间 这个切线空间的原点就是该顶点本身 z 轴就是顶点的法线 x 轴是顶点的切线方向\n\n我们的法线纹理 存储的是 法线在各自的切线空间的向量 大部分都是浅蓝色的原因是 0 0 1映射到0 1就是0.5 0.5 1（浅蓝色） 0 0 1就是 z 轴  大部分的法线都是跟切线空间的 z 轴同方向\n\n一种是模型空间下的法线纹理 一种是切线空间下的法线纹理\n\n模型空间存储的优点：\n- 实现简单 直观。生成简单\n- 提供平滑的边界 模型空间可以生成平滑\n\n切线空间优点：\n- 自由度高 模型空间的是绝对法线信息  应用到不同网格都有合理的效果\n- 可进行 UV 动画 我们通过移动一个纹理的 UV 坐标来实现凹凸移动的效果\n- 可压缩  只此处 xy  z 可以推倒得到 \n\n######  7.2.3 实践\n- 一种在切线空间下进行光照计算 把光照方向、视角方向变换到切线空间下 ：效率比较高  在顶点着色器可以完成 光照和视角的转换  第二种要堆法线纹理取样 需要在片元着色器中变换 我觉得应该是片元的数量大于顶点的数量所以转换需要很多 \n有时我们要在世界空间下进行一些计算 例如在 Cubemap进行环境映射 需要使用世界空间下进行一些计算 （这个 cubemap 不知讲啥）\n- 另外一种是在世界坐标空间下进行光照计算 我们要把切线空间下的法线防线转换到世界空间下：\n\n\n1. 在切线空间下计算\n思路：在片元着色器中得到纹理采样的切线空间下的法线 然后再与切线空间下的视角方向 光照方向进行计算\n注：float4 texcoord : TEXCOORD0; 传入的是float4 xy 是原因的纹理 UV zw 是法线纹理 uv\n\n######  7.2.4 unity 法线纹理类型\n法线纹理会根据平台被压缩\n使用 unpackNormal 函数取解压\n普通纹理的话 是4个通道都是不能舍弃  如果是法线纹理 那么只有ag 是需呀的 br 是不需要的 用 DXT5nm 可以升内存空间。\nCreate from Grayscale 是凹凸映射的方法 高度图 \n\n##### 7.3渐变纹理\n##### 7.4遮罩纹理\n使用其中某个（或者几个）通道做乘法 如果通道为0 可以保证表面不受该属性影响 \n\n#### 8透明效果\nunity 先渲染 Background 然后渲染 Geometry 大多数的不透明物体 前面都是开启深度测试和深度写入   之后渲染 AlphaTest 这个是透明物体  需要排序 从远到近 然后进行渲染\n\n\n##### 8.3透明度测试\n用一个阀值决定\n\n##### 8.4透明度混合\nBlend 内置的混合模式命令 \nBlend off 关闭混合\nBlend SrcFactor DstFactor\nsrccolor * SrcFactor + dstcolor * DstFactor = Target\n\n###### 8.6.1 混合等式和参数\n现在有 源颜色 S 和目标颜色 D 现在想要得到输出颜色 O 就必须使用一个等式来计算，这个就是混合等式 \n我们会用两个混合等式  一个用于混合 RGB 一个混合 A 通道 每个等式要两个因子   一共四个因子。\n\n\n\n中级篇\n####9 更复杂的光照\nForward Rendering Path、Deferred Rendering Path Vertext Lit Rendering Path\n\n顶点照明渲染路径：是对硬件配置要求最好  运算性能最高的\n\n跳过。。。\n\n#### 10 高级纹理\n\n##### 10.1立方体纹理 \n立方体纹理是环境映射的一种实现方法\n包含6张图像  采样的时候是用三维的坐标 \n\n使用立方体纹理的好处 实现简单快捷 得到的效果好  缺点是 如果当场景引入了新的物体 光源 或者物体在发生移动时 我们就需要重新生成 立方体纹理  可以反射环境  但不能反射自己  \n\n\n###### 10.1.1 天空盒子\nwindows -lighting 里面设置 skybox\n\n###### 10.1.2折射\n折射 是用光照计算函数 然后用折射函数混合反射光\n\n\n\n##### 10.2渲染纹理 \n\n\n\n##### 10.2程序纹理 \n\n\n\n#### 11 让画面动起来\n\n##### 11.1 unity shader 中的内置变量\n_Time float4 场景加载开始所经过的实际\n_SinTime 正弦值\n_CosTime 余弦值\nunity_DeltaTime \n\n##### 11.2 纹理动画\n- 序列帧动画：记住 UV 纹理坐标是左下角是原点\n- 滚动的背景：修改 UV 纹理坐标 对两张纹理取样 然后混合\n\n\n","source":"_posts/unity_study.md","raw":"---\ntitle: Unity安装->入门->工程学习->shader\ndate: 2017-07-30 12:49:39\ntags: unity\nreward: true\n---\n\n\n\n## 总体的思维导图\n通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。\n![Alt text](./1496577433020.png)\n\n<!-- more -->\n\n\n\n## 一、安装\n#### 1、安装教程（windows）\nmac就比较简单 官网下载dmg就可以安装使用了\n我用下面图中的两个文件完成安装，一个是安装文件（4.7），一个是破解，然后根据下面链接完成安装\n![Alt text](./1496577678948.png)\n\nhttp://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html\n\n#### 2、需要的文件（百度网盘分享）\n\nhttp://pan.baidu.com/s/1slFHeFz\n\n- 分享的文件里的东西有：\n\t- 【安装使用】：Unity 4.7.1安装文件\n\t- 【安装使用】：Unity 4.x pro Patch.exe\n\t- 【入门使用】：《unity4.x从入门到精通》\n\t- 【入门使用】：简单的工程（微信飞机游戏）：\n\t- 【进一步了解使用】：RPG游戏的简单的工程\n\t- 【shader学习使用】：《Unity Shader入门精要》\n\t- \n#### 3、安装结果\n使用a.Unity 4.7.1安装文件 b.Unity 4.x pro Patch.exe  然后用上上面的教程链接就可以完成windows unity的安装  打开如下：\n![Alt text](./1496583208861.png)\n\n\n\n## 二、入门学习：\n#### 1、开始我找了本书看《unity4.x从入门到精通》：\n《unity4.x从入门到精通》\nhttp://pan.baidu.com/s/1slFHeFz\n\n#### 2、《unity4.x从入门到精通》读书的记录：\n##### 第一章 （可跳过）\n第一章 没什么干货 可以直接跳过\n\n##### 第二章  （重点看2.1  2.2+实操一下）\n- 刚接触的unity的可以按照第二章说的去操作一下  感受一下unity的一些功能 想贪快的就看**2.1** 、**2.2**部分即可 后面的用到再查阅\n- 快捷键部分 等到基本入门了 再来看一遍 会比较受用的感觉  \n\n##### 第三章 （粗略看）\n- 第三章看下 不用纠那么细致 \n##### 第四章 （重点看+操作）\n- 第四章书讲的是怎么写代码的 看完第四章就会输出hello world\n##### 截取两张图\n![Alt text](./1490002232972.png)\n![Alt text](./1490002240157.png)\n\n\n\n##### 后面5-17章的当作工具书看\n\n12章 到16  是针对开发的介绍\n\n17章 进阶 ： 网络\n\n\n#### 3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：\n##### 3.1、C#代码跟unity怎么关联起来？  书中13章![Alt text](./1491552037983.png)\n###### 1、C#脚本的规则\n（1）凡事需要添加到游戏对象的C#脚本类都是需要直接或者间接的继承 MonoBehaviour 如果在unity添加脚本 unity会自动填充继承MonoBehaviour的代码  如果是自己新建一个文件 然后在unity从拖拽添加component 这样是不会成功的（后面会说unity怎么添加C#文件）\n\n（2）继承了MonoBehaviour的类 都会有Start 和 Awake函数的继承  一般使用Start和Awake来初始化  不使用构造函数的原因是unity中无法确定构造函数的顺序。这里我觉得有个原因是：unity会把所有绑定在对象身上的类实例化  然后才可以GetComponent()  例如：下面的操作如果在构造函数中做 可能PlayerAttack这个没有实例化 那么获取不到  所以把初始化工作放在Start中\n![Alt text](./1491552515808.png)\n\n（3）类名和脚本文件名相同 \n\n（4）协同函数Coroutines 返回类型必须是Ienumerator\n\n（5）C#不支持自定义命名空间\n\n###### 2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）\n1、创建脚本的方法：\n![Alt text](./1491553048549.png)\n\n2、创建完之后的编辑：\n这里可以修改用MonoDevelop的编辑器 或者用Vs2012作为代码编辑\n![Alt text](./1491553152505.png)\n\n3、关联到对象去\n（3.1）添加一个gameobject \n![Alt text](./1491553612376.png)\n（3.2） 然后给gameObject添加脚本\n![Alt text](./1491553537327.png)![Alt text](./1491553548688.png)\n\n在Unity中，继承MonoBehaviour的C#脚本都被看作一个Component 游戏对象可以理解为一个容纳各种类型component的容器 游戏对象的所有component一起决定了这个对象的行为表现 这个对象被添加到scene中之后 然后点击build and run 之后这个脚本的Start函数就会被调用一起  可以在这里输出 hello world  这就算是unity的hello world\n\n\n###### 3、怎么获取别的对象以及他的component\n使用函数 GameObject.Find  null则是找不到  根据类名\n使用函数GameObject.FindWithTag\n还有在unity编辑器中拖拽\n\n查看数组的表13-6 表13-7  表13-8  表13-9 \n\n![Alt text](./1491555497064.png)\n![Alt text](./1491555396564.png)\n![Alt text](./1491555581945.png)\n![Alt text](./1491555622726.png)\n![Alt text](./1491555636221.png)\n\n\n\n## 三、工程学习：\n看了《unity4.x从入门到精通》 简单操作unity之后 我上网找几个简单的游戏demo来看下，这样我觉得会比较快上手。\n### 1、微信飞机大战\n工程下载地址：\nhttp://pan.baidu.com/s/1slFHeFz （网上找的工程）\n这个比较容易看懂   \n\n下面说明的过程：\n（1）背景移动 -->（2）敌机出生-->（3）自己的飞行\n![背景移动](./ply1.gif)==》 ![敌机出生](./ply2.gif)==》 ![自己的飞行](./ply3.gif)\n\n\n\n\n\n#### 1、初看这个工程\n只有一个场景scene\n![Alt text](./1496655674282.png)\n预制体有这些\n![Alt text](./1496663793026.png)\n脚本是这些\n![Alt text](./1496663193818.png)\n#### 2、分几个部分看\n##### 2.1、scene\n![Alt text](./1496664667730.png)\n1.里面有个 Main Camera 点击它然后看导航栏Inspector\n2.Main Camera里面有一些component组件 其中Camera 去修改size view port然后运行看下结果 \n![Alt text](./1496664752184.png)\n3.除了Main Camera 这个Scene里面还有一些飞机（hero） 背景（bg） 还一些不是UI的东西（bombManager）\n\n上面大概的了解到，在这个Scene里面拖拽了一些物件 还有一个摄像机 把这些物件投影到屏幕中，到目前为止，我们大概知道是怎么得到游戏的静态界面的，但是游戏是怎么动起来的还不知道。接下来脚本就是讲怎么动起来的。\n\n\n##### 2.2、脚本\n1. 代码入口，没有一个明确的Main函数入口  \n下面按照顺序说下（1）背景移动 （2）怎么生成敌机  （3）怎么控制自己的战机\n![Alt text](./1496665501144.png)\n（1）背景移动 \nscene里面有个object叫bg 然后再点击其中一个background查看导航栏 \n可以看到每个background都挂在了一个脚本组件 BackgroundTransform.cs  这个脚本就是控制不背景移动的\n![Alt text](./1497515757683.png)\n![Alt text](./1497515795595.png)\n\n看到BackgroundTransform这个脚本 两个背景来控制屏幕的背景交替向下移动\n```\npublic class BackgroundTransform : MonoBehaviour {\n\tpublic static float moveSpeed = 2f;\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n\t\tthis.transform.Translate( Vector3.down * moveSpeed * Time.deltaTime );\n\t\tVector3 postion = this.transform.position;\n\t\tif(postion.y<=-8.52f){\n\t\t\t//有两个背景在交替滚动  如果有一个滚动到屏幕外面则改动显示\n\t\t\tthis.transform.position = new Vector3(postion.x,postion.y+8.52f*2,postion.z );\n\t\t}\n\t}\n}\n```\n\n（2）怎么生成敌机\nscene里面有个叫spawn的东西  这个spawn十个空object 里面挂了一个spawn.cs脚本组件\n![Alt text](./1497516506138.png)\n【代码如下】：\n![Alt text](./1497516724024.png)\n\n\n地机的行为就看模型上面挂的脚本组件Enemy.cs\n\n\n（3）怎么控制自己的战机\n同样的在hero这个上面挂了Hero.cs的脚本组件  然后具体就看里面的代码\n![Alt text](./1497516894694.png)\n\n\n\n\n### 2、RPG游戏\n然后再找个复杂点的游戏工程来看\n#### 1、初看工程 \n- 工程下载地址：\nhttp://pan.baidu.com/s/1slFHeFz（网上找的工程）\n- 工程的脚本目录\n![Alt text](./1491550201008.png)\n\n#### 2、工程代码查看\n**看下怎么把这个人物控制方向运动起来的**\n![Alt text](./rpg.gif)\n\n1.打开03_play这个scene 然后拖拽一个Magician模型到scene中\n先在Prefabs文件夹中找到Magician看模型有什么挂件\n- Magician挂了Character Controller这个控制组件\n这个是角色控制器 可以对角色做移动的操作 在playermove脚本里面用到\n\n- Magician还挂了PlayerDir PlayerMove  PlayerAnimation PlayerState PlayerAttack等脚本来实现模型的行为\n看下PlayerMove的update函数\n![Alt text](./1491550243585.png)\n这里判断如果距离大于0.3f则会移动\n\n\n从Magician引发的问题：\n\n##### 2.1、移动的时候有个targetPosition 这个是怎么来的？\ntargetPosition 是PlayerDir.cs这个里面的成员\nPlayerDir.cs里面会计算鼠标点击屏幕的位置发出的射线的碰撞结果 如果是地面那么修改这个玩家的朝向 \n![Alt text](./1497532344804.png)\n\n\n##### 2.2、又引发一个问题鼠标怎么会变样？\n我们看到03_play这个scene有个object叫GameSetting 这个是一个纯粹为了挂脚本用的object \n![Alt text](./1497531965474.png)\n我们看到这个CursorManager就是我们在游戏中的鼠标的管理类\n\n##### 2.3、模型怎么会动起来呢？\n打开03_play这个scene 然后拖拽一个Magician模型到scene中 然后在菜单栏window animation打开animation窗口 然后可以选择已经做好的动作 attack1 然后点击播放 现在我们知道动作可以预先做好 然后再代码中调用 我们看下代码是怎么调用的 \n![Alt text](./1497533865288.png)\nPlayerAnimation.cs这个脚本 根据一个状态去 播放动画animation.CrossFade(animName);\n\n```\n// Update is called once per frame\n\tvoid LateUpdate () {\n        if (attack.state == PlayerState.ControlWalk) {\n            if (move.state == ControlWalkState.Moving) {\n                PlayAnim(\"Run\");\n            } else if (move.state == ControlWalkState.Idle) {\n                PlayAnim(\"Idle\");\n            }\n        } else if (attack.state == PlayerState.NormalAttack) {\n            if (attack.attack_state == AttackState.Moving) {\n                PlayAnim(\"Run\");\n            }\n        }\n\t}\n\tvoid PlayAnim(string animName) {\n        animation.CrossFade(animName);\n    }\n```\n\n这个项目的运行\n![Alt text](./1491877171720.png)\n![Alt text](./1491877201762.png)\n\n之后看下怎么改改这个项目  不懂的再google 或者再去细看unity的一些用法 或则C#的用法\n\n\n\n## 四、Unity Shader学习\n\n### A、我学习的三个点\n-----------------\n#### 1.下载源码中源码下载：\nhttps://github.com/candycat1992/Unity_Shaders_Book\n\n#### 2.学习hello world!\n**下面gif是unity shader的hello world!**\n![Alt text](./shader2.gif)\n\n#### 3.看书照着源码学习 然后实践\n\n\n\n\n\n \n  \n   \n   \n\n\n### B、学习随便记录的笔记 \n-----------------\n#### 1.第一章\n\n\n#### 2.第二章 渲染流水线\n应用阶段->几何阶段->光栅化阶段\n应用阶段把渲染图元交给几何阶段\n\n##### 2.2CPU 和 GPU 的通信\n1. 把数据加载到显存中\n2. 设置渲染状态\n3. 调用 drallcall\n\n**1.把数据加载到显存中**\n硬盘--->内存--->显存\n顶点数据 法线方向 纹理坐标\n\n**2.设置渲染状态**\nvs ps\n顶点着色器 片元着色器\n\n**3.drawcall**\n\n##### 2.3GPU 流水线\n###### 顶点着色器\n把顶点坐标转换到齐次裁剪坐标系得到归一化的设备坐标 NDC\nopengl unity的 NDC 是-1 1\n屏幕映射 转换到屏幕坐标系\n屏幕坐标系Opengl 是左下角\n\n#### 3.第三章 Unity shader基础\n##### 3.1 创建shader的常见流程\n1. 创建一个材质\n2. 创建一个unity shader 并把它赋给上一步中创建的材质\n3. 把材质赋给要渲染的对象\n4. 在材质面板上（选中材质然后查看导航栏）调整shader的属性\n\n\n##### 3.2 shader lab\nGLSL是opengl的shader语言 Directx的shader语言是HLSL   shader lab的就是 unity shader的shader语言\n可以细看下这个章节  熟悉下语法\n\n#### 4 学习 Shader 所需的数学知识\n一些基础的知识都是大概知道 可以等到要用到的时候再去复习\n一些空间 M 模型空间 W 世界空间 V 摄像机空间 NDC 归一化空间\n\n\n#### 5 开始学习 Shader\n##### 5.2 最简单的片元着色器 顶点着色器\n###### 5.2.2 unity支持的语义：\nPOSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，COLOR\n###### 5.2.3 顶点着色器和片元着色器之间的通信：\n声明一个新的结构体v2f v2f可用于定点着色器和片元着色器之间传递信息\n###### 5.3.1内置包含的文件\n在后面的学习中 总是会用到一些内置的文件\n需要include一下 类似C++的include\n\n##### 5.5 Debug技巧\n1. 把想知道的值赋值到某个颜色 通过屏幕上显示的颜色来判断一个值\n2. 还可以找到一个简单的取色脚本  ColorPicker.cs\n3. 高级的：Visual Studio Graphics Debugger\n4. Unity里面的帧调试器\n\n\n#### 6 Unity 中的基础光照\n##### 6.2 进入摄像机的光分成4个部分\n- 自发光：本身辐射量  如果没有全局光照技术 自会影响自己的辐射量\n- 高光反射：（我觉得是完全镜面反射）光源的完全镜面反射方向散射多少辐射量？？ 是镜面反射的散射？？\n- 漫反射：这个就是光源的漫反射\n- 环境光：其他所有的间接光照\n\n计算高光反射：![Alt text](./1495002356532.png)\nPhong 模型来计算高光反射部分：\n![Alt text](./1495002389507.png)\n\n\n##### 6.4 光照实现\n（1）Properties定义一个颜色值 \n（2）LightMode标签是 Pass 标签的一种 只有定义了正确的 LightMode 我们才能得到一些 Unity的内置光照变量 \nTags { \"LightMode\"=\"ForwardBase\" }\n\n（3）还是之前的 CGPROGRAM ENDCG\n\n（4）为了用到 Unity的内置变量  \n''' #include \"Lighting.cginc\"  \"'\n\n（5）逐顶点 着色器\n\n- 逐顶点漫反射：有锯齿 应该是因为处理是每个片元的顶点 所以不精细\n- 逐像素漫反射：无锯齿 但是黑面太黑 都是一个色 黑色\n- 半伯兰特模型：无锯齿 黑面有渐变\n c = c * m (0.5 (n * I) + 0.5)\n#### 7 基础纹理\n- 记住这个 ： o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n###### 7.1.2 纹理取样\nfixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;\n\n###### 7.2 凹凸映射\n不改变顶点 改变的是绘制 \n法线纹理 normal map\n\n###### 7.2.1高度纹理\n存储的是强度值   这个通过高度来计算法线 \n颜色越浅越突 反而凹\n\n###### 7.2.2法线纹理\n\n法线的向量分量是 -1 到1 \n所以 pixel = (noamal+1)/2\nnormal = (pixel * 2) - 1\n\n这种纹理称为是模型空间的法线纹理  我恩会采用另外一种坐标空间 切线空间  我们用模型顶点的切线空间来存储法线  对于每个顶点都有一个属于自己的切线空间 这个切线空间的原点就是该顶点本身 z 轴就是顶点的法线 x 轴是顶点的切线方向\n\n我们的法线纹理 存储的是 法线在各自的切线空间的向量 大部分都是浅蓝色的原因是 0 0 1映射到0 1就是0.5 0.5 1（浅蓝色） 0 0 1就是 z 轴  大部分的法线都是跟切线空间的 z 轴同方向\n\n一种是模型空间下的法线纹理 一种是切线空间下的法线纹理\n\n模型空间存储的优点：\n- 实现简单 直观。生成简单\n- 提供平滑的边界 模型空间可以生成平滑\n\n切线空间优点：\n- 自由度高 模型空间的是绝对法线信息  应用到不同网格都有合理的效果\n- 可进行 UV 动画 我们通过移动一个纹理的 UV 坐标来实现凹凸移动的效果\n- 可压缩  只此处 xy  z 可以推倒得到 \n\n######  7.2.3 实践\n- 一种在切线空间下进行光照计算 把光照方向、视角方向变换到切线空间下 ：效率比较高  在顶点着色器可以完成 光照和视角的转换  第二种要堆法线纹理取样 需要在片元着色器中变换 我觉得应该是片元的数量大于顶点的数量所以转换需要很多 \n有时我们要在世界空间下进行一些计算 例如在 Cubemap进行环境映射 需要使用世界空间下进行一些计算 （这个 cubemap 不知讲啥）\n- 另外一种是在世界坐标空间下进行光照计算 我们要把切线空间下的法线防线转换到世界空间下：\n\n\n1. 在切线空间下计算\n思路：在片元着色器中得到纹理采样的切线空间下的法线 然后再与切线空间下的视角方向 光照方向进行计算\n注：float4 texcoord : TEXCOORD0; 传入的是float4 xy 是原因的纹理 UV zw 是法线纹理 uv\n\n######  7.2.4 unity 法线纹理类型\n法线纹理会根据平台被压缩\n使用 unpackNormal 函数取解压\n普通纹理的话 是4个通道都是不能舍弃  如果是法线纹理 那么只有ag 是需呀的 br 是不需要的 用 DXT5nm 可以升内存空间。\nCreate from Grayscale 是凹凸映射的方法 高度图 \n\n##### 7.3渐变纹理\n##### 7.4遮罩纹理\n使用其中某个（或者几个）通道做乘法 如果通道为0 可以保证表面不受该属性影响 \n\n#### 8透明效果\nunity 先渲染 Background 然后渲染 Geometry 大多数的不透明物体 前面都是开启深度测试和深度写入   之后渲染 AlphaTest 这个是透明物体  需要排序 从远到近 然后进行渲染\n\n\n##### 8.3透明度测试\n用一个阀值决定\n\n##### 8.4透明度混合\nBlend 内置的混合模式命令 \nBlend off 关闭混合\nBlend SrcFactor DstFactor\nsrccolor * SrcFactor + dstcolor * DstFactor = Target\n\n###### 8.6.1 混合等式和参数\n现在有 源颜色 S 和目标颜色 D 现在想要得到输出颜色 O 就必须使用一个等式来计算，这个就是混合等式 \n我们会用两个混合等式  一个用于混合 RGB 一个混合 A 通道 每个等式要两个因子   一共四个因子。\n\n\n\n中级篇\n####9 更复杂的光照\nForward Rendering Path、Deferred Rendering Path Vertext Lit Rendering Path\n\n顶点照明渲染路径：是对硬件配置要求最好  运算性能最高的\n\n跳过。。。\n\n#### 10 高级纹理\n\n##### 10.1立方体纹理 \n立方体纹理是环境映射的一种实现方法\n包含6张图像  采样的时候是用三维的坐标 \n\n使用立方体纹理的好处 实现简单快捷 得到的效果好  缺点是 如果当场景引入了新的物体 光源 或者物体在发生移动时 我们就需要重新生成 立方体纹理  可以反射环境  但不能反射自己  \n\n\n###### 10.1.1 天空盒子\nwindows -lighting 里面设置 skybox\n\n###### 10.1.2折射\n折射 是用光照计算函数 然后用折射函数混合反射光\n\n\n\n##### 10.2渲染纹理 \n\n\n\n##### 10.2程序纹理 \n\n\n\n#### 11 让画面动起来\n\n##### 11.1 unity shader 中的内置变量\n_Time float4 场景加载开始所经过的实际\n_SinTime 正弦值\n_CosTime 余弦值\nunity_DeltaTime \n\n##### 11.2 纹理动画\n- 序列帧动画：记住 UV 纹理坐标是左下角是原点\n- 滚动的背景：修改 UV 纹理坐标 对两张纹理取样 然后混合\n\n\n","slug":"unity_study","published":1,"updated":"2018-05-11T10:13:52.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o5l0006znmjhlvrqlw1","content":"<h2 id=\"总体的思维导图\"><a href=\"#总体的思维导图\" class=\"headerlink\" title=\"总体的思维导图\"></a>总体的思维导图</h2><p>通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。<br><img src=\"/2017/07/30/unity_study/1496577433020.png\" alt=\"Alt text\"></p>\n<a id=\"more\"></a>\n<h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><h4 id=\"1、安装教程（windows）\"><a href=\"#1、安装教程（windows）\" class=\"headerlink\" title=\"1、安装教程（windows）\"></a>1、安装教程（windows）</h4><p>mac就比较简单 官网下载dmg就可以安装使用了<br>我用下面图中的两个文件完成安装，一个是安装文件（4.7），一个是破解，然后根据下面链接完成安装<br><img src=\"/2017/07/30/unity_study/1496577678948.png\" alt=\"Alt text\"></p>\n<p><a href=\"http://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html</a></p>\n<h4 id=\"2、需要的文件（百度网盘分享）\"><a href=\"#2、需要的文件（百度网盘分享）\" class=\"headerlink\" title=\"2、需要的文件（百度网盘分享）\"></a>2、需要的文件（百度网盘分享）</h4><p><a href=\"http://pan.baidu.com/s/1slFHeFz\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1slFHeFz</a></p>\n<ul>\n<li>分享的文件里的东西有：<ul>\n<li>【安装使用】：Unity 4.7.1安装文件</li>\n<li>【安装使用】：Unity 4.x pro Patch.exe</li>\n<li>【入门使用】：《unity4.x从入门到精通》</li>\n<li>【入门使用】：简单的工程（微信飞机游戏）：</li>\n<li>【进一步了解使用】：RPG游戏的简单的工程</li>\n<li>【shader学习使用】：《Unity Shader入门精要》</li>\n<li><h4 id=\"3、安装结果\"><a href=\"#3、安装结果\" class=\"headerlink\" title=\"3、安装结果\"></a>3、安装结果</h4>使用a.Unity 4.7.1安装文件 b.Unity 4.x pro Patch.exe  然后用上上面的教程链接就可以完成windows unity的安装  打开如下：<br><img src=\"/2017/07/30/unity_study/1496583208861.png\" alt=\"Alt text\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、入门学习：\"><a href=\"#二、入门学习：\" class=\"headerlink\" title=\"二、入门学习：\"></a>二、入门学习：</h2><h4 id=\"1、开始我找了本书看《unity4-x从入门到精通》：\"><a href=\"#1、开始我找了本书看《unity4-x从入门到精通》：\" class=\"headerlink\" title=\"1、开始我找了本书看《unity4.x从入门到精通》：\"></a>1、开始我找了本书看《unity4.x从入门到精通》：</h4><p>《unity4.x从入门到精通》<br><a href=\"http://pan.baidu.com/s/1slFHeFz\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1slFHeFz</a></p>\n<h4 id=\"2、《unity4-x从入门到精通》读书的记录：\"><a href=\"#2、《unity4-x从入门到精通》读书的记录：\" class=\"headerlink\" title=\"2、《unity4.x从入门到精通》读书的记录：\"></a>2、《unity4.x从入门到精通》读书的记录：</h4><h5 id=\"第一章-（可跳过）\"><a href=\"#第一章-（可跳过）\" class=\"headerlink\" title=\"第一章 （可跳过）\"></a>第一章 （可跳过）</h5><p>第一章 没什么干货 可以直接跳过</p>\n<h5 id=\"第二章-（重点看2-1-2-2-实操一下）\"><a href=\"#第二章-（重点看2-1-2-2-实操一下）\" class=\"headerlink\" title=\"第二章  （重点看2.1  2.2+实操一下）\"></a>第二章  （重点看2.1  2.2+实操一下）</h5><ul>\n<li>刚接触的unity的可以按照第二章说的去操作一下  感受一下unity的一些功能 想贪快的就看<strong>2.1</strong> 、<strong>2.2</strong>部分即可 后面的用到再查阅</li>\n<li>快捷键部分 等到基本入门了 再来看一遍 会比较受用的感觉  </li>\n</ul>\n<h5 id=\"第三章-（粗略看）\"><a href=\"#第三章-（粗略看）\" class=\"headerlink\" title=\"第三章 （粗略看）\"></a>第三章 （粗略看）</h5><ul>\n<li>第三章看下 不用纠那么细致 <h5 id=\"第四章-（重点看-操作）\"><a href=\"#第四章-（重点看-操作）\" class=\"headerlink\" title=\"第四章 （重点看+操作）\"></a>第四章 （重点看+操作）</h5></li>\n<li>第四章书讲的是怎么写代码的 看完第四章就会输出hello world<h5 id=\"截取两张图\"><a href=\"#截取两张图\" class=\"headerlink\" title=\"截取两张图\"></a>截取两张图</h5><img src=\"/2017/07/30/unity_study/1490002232972.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1490002240157.png\" alt=\"Alt text\"></li>\n</ul>\n<h5 id=\"后面5-17章的当作工具书看\"><a href=\"#后面5-17章的当作工具书看\" class=\"headerlink\" title=\"后面5-17章的当作工具书看\"></a>后面5-17章的当作工具书看</h5><p>12章 到16  是针对开发的介绍</p>\n<p>17章 进阶 ： 网络</p>\n<h4 id=\"3、大致的浏览了《unity4-x从入门到精通》-前四章之后带着几个疑问去分类学习：\"><a href=\"#3、大致的浏览了《unity4-x从入门到精通》-前四章之后带着几个疑问去分类学习：\" class=\"headerlink\" title=\"3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：\"></a>3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：</h4><h5 id=\"3-1、C-代码跟unity怎么关联起来？-书中13章\"><a href=\"#3-1、C-代码跟unity怎么关联起来？-书中13章\" class=\"headerlink\" title=\"3.1、C#代码跟unity怎么关联起来？  书中13章\"></a>3.1、C#代码跟unity怎么关联起来？  书中13章<img src=\"/2017/07/30/unity_study/1491552037983.png\" alt=\"Alt text\"></h5><h6 id=\"1、C-脚本的规则\"><a href=\"#1、C-脚本的规则\" class=\"headerlink\" title=\"1、C#脚本的规则\"></a>1、C#脚本的规则</h6><p>（1）凡事需要添加到游戏对象的C#脚本类都是需要直接或者间接的继承 MonoBehaviour 如果在unity添加脚本 unity会自动填充继承MonoBehaviour的代码  如果是自己新建一个文件 然后在unity从拖拽添加component 这样是不会成功的（后面会说unity怎么添加C#文件）</p>\n<p>（2）继承了MonoBehaviour的类 都会有Start 和 Awake函数的继承  一般使用Start和Awake来初始化  不使用构造函数的原因是unity中无法确定构造函数的顺序。这里我觉得有个原因是：unity会把所有绑定在对象身上的类实例化  然后才可以GetComponent()  例如：下面的操作如果在构造函数中做 可能PlayerAttack这个没有实例化 那么获取不到  所以把初始化工作放在Start中<br><img src=\"/2017/07/30/unity_study/1491552515808.png\" alt=\"Alt text\"></p>\n<p>（3）类名和脚本文件名相同 </p>\n<p>（4）协同函数Coroutines 返回类型必须是Ienumerator</p>\n<p>（5）C#不支持自定义命名空间</p>\n<h6 id=\"2、C-脚本在unity编辑器中关联对象（十三章有详细介绍）\"><a href=\"#2、C-脚本在unity编辑器中关联对象（十三章有详细介绍）\" class=\"headerlink\" title=\"2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）\"></a>2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）</h6><p>1、创建脚本的方法：<br><img src=\"/2017/07/30/unity_study/1491553048549.png\" alt=\"Alt text\"></p>\n<p>2、创建完之后的编辑：<br>这里可以修改用MonoDevelop的编辑器 或者用Vs2012作为代码编辑<br><img src=\"/2017/07/30/unity_study/1491553152505.png\" alt=\"Alt text\"></p>\n<p>3、关联到对象去<br>（3.1）添加一个gameobject<br><img src=\"/2017/07/30/unity_study/1491553612376.png\" alt=\"Alt text\"><br>（3.2） 然后给gameObject添加脚本<br><img src=\"/2017/07/30/unity_study/1491553537327.png\" alt=\"Alt text\"><img src=\"/2017/07/30/unity_study/1491553548688.png\" alt=\"Alt text\"></p>\n<p>在Unity中，继承MonoBehaviour的C#脚本都被看作一个Component 游戏对象可以理解为一个容纳各种类型component的容器 游戏对象的所有component一起决定了这个对象的行为表现 这个对象被添加到scene中之后 然后点击build and run 之后这个脚本的Start函数就会被调用一起  可以在这里输出 hello world  这就算是unity的hello world</p>\n<h6 id=\"3、怎么获取别的对象以及他的component\"><a href=\"#3、怎么获取别的对象以及他的component\" class=\"headerlink\" title=\"3、怎么获取别的对象以及他的component\"></a>3、怎么获取别的对象以及他的component</h6><p>使用函数 GameObject.Find  null则是找不到  根据类名<br>使用函数GameObject.FindWithTag<br>还有在unity编辑器中拖拽</p>\n<p>查看数组的表13-6 表13-7  表13-8  表13-9 </p>\n<p><img src=\"/2017/07/30/unity_study/1491555497064.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555396564.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555581945.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555622726.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555636221.png\" alt=\"Alt text\"></p>\n<h2 id=\"三、工程学习：\"><a href=\"#三、工程学习：\" class=\"headerlink\" title=\"三、工程学习：\"></a>三、工程学习：</h2><p>看了《unity4.x从入门到精通》 简单操作unity之后 我上网找几个简单的游戏demo来看下，这样我觉得会比较快上手。</p>\n<h3 id=\"1、微信飞机大战\"><a href=\"#1、微信飞机大战\" class=\"headerlink\" title=\"1、微信飞机大战\"></a>1、微信飞机大战</h3><p>工程下载地址：<br><a href=\"http://pan.baidu.com/s/1slFHeFz\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1slFHeFz</a> （网上找的工程）<br>这个比较容易看懂   </p>\n<p>下面说明的过程：<br>（1）背景移动 –&gt;（2）敌机出生–&gt;（3）自己的飞行<br><img src=\"/2017/07/30/unity_study/ply1.gif\" alt=\"背景移动\">==》 <img src=\"/2017/07/30/unity_study/ply2.gif\" alt=\"敌机出生\">==》 <img src=\"/2017/07/30/unity_study/ply3.gif\" alt=\"自己的飞行\"></p>\n<h4 id=\"1、初看这个工程\"><a href=\"#1、初看这个工程\" class=\"headerlink\" title=\"1、初看这个工程\"></a>1、初看这个工程</h4><p>只有一个场景scene<br><img src=\"/2017/07/30/unity_study/1496655674282.png\" alt=\"Alt text\"><br>预制体有这些<br><img src=\"/2017/07/30/unity_study/1496663793026.png\" alt=\"Alt text\"><br>脚本是这些<br><img src=\"/2017/07/30/unity_study/1496663193818.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、分几个部分看\"><a href=\"#2、分几个部分看\" class=\"headerlink\" title=\"2、分几个部分看\"></a>2、分几个部分看</h4><h5 id=\"2-1、scene\"><a href=\"#2-1、scene\" class=\"headerlink\" title=\"2.1、scene\"></a>2.1、scene</h5><p><img src=\"/2017/07/30/unity_study/1496664667730.png\" alt=\"Alt text\"><br>1.里面有个 Main Camera 点击它然后看导航栏Inspector<br>2.Main Camera里面有一些component组件 其中Camera 去修改size view port然后运行看下结果<br><img src=\"/2017/07/30/unity_study/1496664752184.png\" alt=\"Alt text\"><br>3.除了Main Camera 这个Scene里面还有一些飞机（hero） 背景（bg） 还一些不是UI的东西（bombManager）</p>\n<p>上面大概的了解到，在这个Scene里面拖拽了一些物件 还有一个摄像机 把这些物件投影到屏幕中，到目前为止，我们大概知道是怎么得到游戏的静态界面的，但是游戏是怎么动起来的还不知道。接下来脚本就是讲怎么动起来的。</p>\n<h5 id=\"2-2、脚本\"><a href=\"#2-2、脚本\" class=\"headerlink\" title=\"2.2、脚本\"></a>2.2、脚本</h5><ol>\n<li>代码入口，没有一个明确的Main函数入口<br>下面按照顺序说下（1）背景移动 （2）怎么生成敌机  （3）怎么控制自己的战机<br><img src=\"/2017/07/30/unity_study/1496665501144.png\" alt=\"Alt text\"><br>（1）背景移动<br>scene里面有个object叫bg 然后再点击其中一个background查看导航栏<br>可以看到每个background都挂在了一个脚本组件 BackgroundTransform.cs  这个脚本就是控制不背景移动的<br><img src=\"/2017/07/30/unity_study/1497515757683.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1497515795595.png\" alt=\"Alt text\"></li>\n</ol>\n<p>看到BackgroundTransform这个脚本 两个背景来控制屏幕的背景交替向下移动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class BackgroundTransform : MonoBehaviour &#123;</div><div class=\"line\">\tpublic static float moveSpeed = 2f;</div><div class=\"line\">\t</div><div class=\"line\">\t// Update is called once per frame</div><div class=\"line\">\tvoid Update () &#123;</div><div class=\"line\">\t\tthis.transform.Translate( Vector3.down * moveSpeed * Time.deltaTime );</div><div class=\"line\">\t\tVector3 postion = this.transform.position;</div><div class=\"line\">\t\tif(postion.y&lt;=-8.52f)&#123;</div><div class=\"line\">\t\t\t//有两个背景在交替滚动  如果有一个滚动到屏幕外面则改动显示</div><div class=\"line\">\t\t\tthis.transform.position = new Vector3(postion.x,postion.y+8.52f*2,postion.z );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（2）怎么生成敌机<br>scene里面有个叫spawn的东西  这个spawn十个空object 里面挂了一个spawn.cs脚本组件<br><img src=\"/2017/07/30/unity_study/1497516506138.png\" alt=\"Alt text\"><br>【代码如下】：<br><img src=\"/2017/07/30/unity_study/1497516724024.png\" alt=\"Alt text\"></p>\n<p>地机的行为就看模型上面挂的脚本组件Enemy.cs</p>\n<p>（3）怎么控制自己的战机<br>同样的在hero这个上面挂了Hero.cs的脚本组件  然后具体就看里面的代码<br><img src=\"/2017/07/30/unity_study/1497516894694.png\" alt=\"Alt text\"></p>\n<h3 id=\"2、RPG游戏\"><a href=\"#2、RPG游戏\" class=\"headerlink\" title=\"2、RPG游戏\"></a>2、RPG游戏</h3><p>然后再找个复杂点的游戏工程来看</p>\n<h4 id=\"1、初看工程\"><a href=\"#1、初看工程\" class=\"headerlink\" title=\"1、初看工程\"></a>1、初看工程</h4><ul>\n<li>工程下载地址：<br><a href=\"http://pan.baidu.com/s/1slFHeFz（网上找的工程）\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1slFHeFz（网上找的工程）</a></li>\n<li>工程的脚本目录<br><img src=\"/2017/07/30/unity_study/1491550201008.png\" alt=\"Alt text\"></li>\n</ul>\n<h4 id=\"2、工程代码查看\"><a href=\"#2、工程代码查看\" class=\"headerlink\" title=\"2、工程代码查看\"></a>2、工程代码查看</h4><p><strong>看下怎么把这个人物控制方向运动起来的</strong><br><img src=\"/2017/07/30/unity_study/rpg.gif\" alt=\"Alt text\"></p>\n<p>1.打开03_play这个scene 然后拖拽一个Magician模型到scene中<br>先在Prefabs文件夹中找到Magician看模型有什么挂件</p>\n<ul>\n<li><p>Magician挂了Character Controller这个控制组件<br>这个是角色控制器 可以对角色做移动的操作 在playermove脚本里面用到</p>\n</li>\n<li><p>Magician还挂了PlayerDir PlayerMove  PlayerAnimation PlayerState PlayerAttack等脚本来实现模型的行为<br>看下PlayerMove的update函数<br><img src=\"/2017/07/30/unity_study/1491550243585.png\" alt=\"Alt text\"><br>这里判断如果距离大于0.3f则会移动</p>\n</li>\n</ul>\n<p>从Magician引发的问题：</p>\n<h5 id=\"2-1、移动的时候有个targetPosition-这个是怎么来的？\"><a href=\"#2-1、移动的时候有个targetPosition-这个是怎么来的？\" class=\"headerlink\" title=\"2.1、移动的时候有个targetPosition 这个是怎么来的？\"></a>2.1、移动的时候有个targetPosition 这个是怎么来的？</h5><p>targetPosition 是PlayerDir.cs这个里面的成员<br>PlayerDir.cs里面会计算鼠标点击屏幕的位置发出的射线的碰撞结果 如果是地面那么修改这个玩家的朝向<br><img src=\"/2017/07/30/unity_study/1497532344804.png\" alt=\"Alt text\"></p>\n<h5 id=\"2-2、又引发一个问题鼠标怎么会变样？\"><a href=\"#2-2、又引发一个问题鼠标怎么会变样？\" class=\"headerlink\" title=\"2.2、又引发一个问题鼠标怎么会变样？\"></a>2.2、又引发一个问题鼠标怎么会变样？</h5><p>我们看到03_play这个scene有个object叫GameSetting 这个是一个纯粹为了挂脚本用的object<br><img src=\"/2017/07/30/unity_study/1497531965474.png\" alt=\"Alt text\"><br>我们看到这个CursorManager就是我们在游戏中的鼠标的管理类</p>\n<h5 id=\"2-3、模型怎么会动起来呢？\"><a href=\"#2-3、模型怎么会动起来呢？\" class=\"headerlink\" title=\"2.3、模型怎么会动起来呢？\"></a>2.3、模型怎么会动起来呢？</h5><p>打开03_play这个scene 然后拖拽一个Magician模型到scene中 然后在菜单栏window animation打开animation窗口 然后可以选择已经做好的动作 attack1 然后点击播放 现在我们知道动作可以预先做好 然后再代码中调用 我们看下代码是怎么调用的<br><img src=\"/2017/07/30/unity_study/1497533865288.png\" alt=\"Alt text\"><br>PlayerAnimation.cs这个脚本 根据一个状态去 播放动画animation.CrossFade(animName);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Update is called once per frame</div><div class=\"line\">\tvoid LateUpdate () &#123;</div><div class=\"line\">        if (attack.state == PlayerState.ControlWalk) &#123;</div><div class=\"line\">            if (move.state == ControlWalkState.Moving) &#123;</div><div class=\"line\">                PlayAnim(&quot;Run&quot;);</div><div class=\"line\">            &#125; else if (move.state == ControlWalkState.Idle) &#123;</div><div class=\"line\">                PlayAnim(&quot;Idle&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (attack.state == PlayerState.NormalAttack) &#123;</div><div class=\"line\">            if (attack.attack_state == AttackState.Moving) &#123;</div><div class=\"line\">                PlayAnim(&quot;Run&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvoid PlayAnim(string animName) &#123;</div><div class=\"line\">        animation.CrossFade(animName);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个项目的运行<br><img src=\"/2017/07/30/unity_study/1491877171720.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491877201762.png\" alt=\"Alt text\"></p>\n<p>之后看下怎么改改这个项目  不懂的再google 或者再去细看unity的一些用法 或则C#的用法</p>\n<h2 id=\"四、Unity-Shader学习\"><a href=\"#四、Unity-Shader学习\" class=\"headerlink\" title=\"四、Unity Shader学习\"></a>四、Unity Shader学习</h2><h3 id=\"A、我学习的三个点\"><a href=\"#A、我学习的三个点\" class=\"headerlink\" title=\"A、我学习的三个点\"></a>A、我学习的三个点</h3><hr>\n<h4 id=\"1-下载源码中源码下载：\"><a href=\"#1-下载源码中源码下载：\" class=\"headerlink\" title=\"1.下载源码中源码下载：\"></a>1.下载源码中源码下载：</h4><p><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"external\">https://github.com/candycat1992/Unity_Shaders_Book</a></p>\n<h4 id=\"2-学习hello-world\"><a href=\"#2-学习hello-world\" class=\"headerlink\" title=\"2.学习hello world!\"></a>2.学习hello world!</h4><p><strong>下面gif是unity shader的hello world!</strong><br><img src=\"/2017/07/30/unity_study/shader2.gif\" alt=\"Alt text\"></p>\n<h4 id=\"3-看书照着源码学习-然后实践\"><a href=\"#3-看书照着源码学习-然后实践\" class=\"headerlink\" title=\"3.看书照着源码学习 然后实践\"></a>3.看书照着源码学习 然后实践</h4><h3 id=\"B、学习随便记录的笔记\"><a href=\"#B、学习随便记录的笔记\" class=\"headerlink\" title=\"B、学习随便记录的笔记\"></a>B、学习随便记录的笔记</h3><hr>\n<h4 id=\"1-第一章\"><a href=\"#1-第一章\" class=\"headerlink\" title=\"1.第一章\"></a>1.第一章</h4><h4 id=\"2-第二章-渲染流水线\"><a href=\"#2-第二章-渲染流水线\" class=\"headerlink\" title=\"2.第二章 渲染流水线\"></a>2.第二章 渲染流水线</h4><p>应用阶段-&gt;几何阶段-&gt;光栅化阶段<br>应用阶段把渲染图元交给几何阶段</p>\n<h5 id=\"2-2CPU-和-GPU-的通信\"><a href=\"#2-2CPU-和-GPU-的通信\" class=\"headerlink\" title=\"2.2CPU 和 GPU 的通信\"></a>2.2CPU 和 GPU 的通信</h5><ol>\n<li>把数据加载到显存中</li>\n<li>设置渲染状态</li>\n<li>调用 drallcall</li>\n</ol>\n<p><strong>1.把数据加载到显存中</strong><br>硬盘—&gt;内存—&gt;显存<br>顶点数据 法线方向 纹理坐标</p>\n<p><strong>2.设置渲染状态</strong><br>vs ps<br>顶点着色器 片元着色器</p>\n<p><strong>3.drawcall</strong></p>\n<h5 id=\"2-3GPU-流水线\"><a href=\"#2-3GPU-流水线\" class=\"headerlink\" title=\"2.3GPU 流水线\"></a>2.3GPU 流水线</h5><h6 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h6><p>把顶点坐标转换到齐次裁剪坐标系得到归一化的设备坐标 NDC<br>opengl unity的 NDC 是-1 1<br>屏幕映射 转换到屏幕坐标系<br>屏幕坐标系Opengl 是左下角</p>\n<h4 id=\"3-第三章-Unity-shader基础\"><a href=\"#3-第三章-Unity-shader基础\" class=\"headerlink\" title=\"3.第三章 Unity shader基础\"></a>3.第三章 Unity shader基础</h4><h5 id=\"3-1-创建shader的常见流程\"><a href=\"#3-1-创建shader的常见流程\" class=\"headerlink\" title=\"3.1 创建shader的常见流程\"></a>3.1 创建shader的常见流程</h5><ol>\n<li>创建一个材质</li>\n<li>创建一个unity shader 并把它赋给上一步中创建的材质</li>\n<li>把材质赋给要渲染的对象</li>\n<li>在材质面板上（选中材质然后查看导航栏）调整shader的属性</li>\n</ol>\n<h5 id=\"3-2-shader-lab\"><a href=\"#3-2-shader-lab\" class=\"headerlink\" title=\"3.2 shader lab\"></a>3.2 shader lab</h5><p>GLSL是opengl的shader语言 Directx的shader语言是HLSL   shader lab的就是 unity shader的shader语言<br>可以细看下这个章节  熟悉下语法</p>\n<h4 id=\"4-学习-Shader-所需的数学知识\"><a href=\"#4-学习-Shader-所需的数学知识\" class=\"headerlink\" title=\"4 学习 Shader 所需的数学知识\"></a>4 学习 Shader 所需的数学知识</h4><p>一些基础的知识都是大概知道 可以等到要用到的时候再去复习<br>一些空间 M 模型空间 W 世界空间 V 摄像机空间 NDC 归一化空间</p>\n<h4 id=\"5-开始学习-Shader\"><a href=\"#5-开始学习-Shader\" class=\"headerlink\" title=\"5 开始学习 Shader\"></a>5 开始学习 Shader</h4><h5 id=\"5-2-最简单的片元着色器-顶点着色器\"><a href=\"#5-2-最简单的片元着色器-顶点着色器\" class=\"headerlink\" title=\"5.2 最简单的片元着色器 顶点着色器\"></a>5.2 最简单的片元着色器 顶点着色器</h5><h6 id=\"5-2-2-unity支持的语义：\"><a href=\"#5-2-2-unity支持的语义：\" class=\"headerlink\" title=\"5.2.2 unity支持的语义：\"></a>5.2.2 unity支持的语义：</h6><p>POSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，COLOR</p>\n<h6 id=\"5-2-3-顶点着色器和片元着色器之间的通信：\"><a href=\"#5-2-3-顶点着色器和片元着色器之间的通信：\" class=\"headerlink\" title=\"5.2.3 顶点着色器和片元着色器之间的通信：\"></a>5.2.3 顶点着色器和片元着色器之间的通信：</h6><p>声明一个新的结构体v2f v2f可用于定点着色器和片元着色器之间传递信息</p>\n<h6 id=\"5-3-1内置包含的文件\"><a href=\"#5-3-1内置包含的文件\" class=\"headerlink\" title=\"5.3.1内置包含的文件\"></a>5.3.1内置包含的文件</h6><p>在后面的学习中 总是会用到一些内置的文件<br>需要include一下 类似C++的include</p>\n<h5 id=\"5-5-Debug技巧\"><a href=\"#5-5-Debug技巧\" class=\"headerlink\" title=\"5.5 Debug技巧\"></a>5.5 Debug技巧</h5><ol>\n<li>把想知道的值赋值到某个颜色 通过屏幕上显示的颜色来判断一个值</li>\n<li>还可以找到一个简单的取色脚本  ColorPicker.cs</li>\n<li>高级的：Visual Studio Graphics Debugger</li>\n<li>Unity里面的帧调试器</li>\n</ol>\n<h4 id=\"6-Unity-中的基础光照\"><a href=\"#6-Unity-中的基础光照\" class=\"headerlink\" title=\"6 Unity 中的基础光照\"></a>6 Unity 中的基础光照</h4><h5 id=\"6-2-进入摄像机的光分成4个部分\"><a href=\"#6-2-进入摄像机的光分成4个部分\" class=\"headerlink\" title=\"6.2 进入摄像机的光分成4个部分\"></a>6.2 进入摄像机的光分成4个部分</h5><ul>\n<li>自发光：本身辐射量  如果没有全局光照技术 自会影响自己的辐射量</li>\n<li>高光反射：（我觉得是完全镜面反射）光源的完全镜面反射方向散射多少辐射量？？ 是镜面反射的散射？？</li>\n<li>漫反射：这个就是光源的漫反射</li>\n<li>环境光：其他所有的间接光照</li>\n</ul>\n<p>计算高光反射：<img src=\"/2017/07/30/unity_study/1495002356532.png\" alt=\"Alt text\"><br>Phong 模型来计算高光反射部分：<br><img src=\"/2017/07/30/unity_study/1495002389507.png\" alt=\"Alt text\"></p>\n<h5 id=\"6-4-光照实现\"><a href=\"#6-4-光照实现\" class=\"headerlink\" title=\"6.4 光照实现\"></a>6.4 光照实现</h5><p>（1）Properties定义一个颜色值<br>（2）LightMode标签是 Pass 标签的一种 只有定义了正确的 LightMode 我们才能得到一些 Unity的内置光照变量<br>Tags { “LightMode”=”ForwardBase” }</p>\n<p>（3）还是之前的 CGPROGRAM ENDCG</p>\n<p>（4）为了用到 Unity的内置变量<br>‘’’ #include “Lighting.cginc”  “‘</p>\n<p>（5）逐顶点 着色器</p>\n<ul>\n<li>逐顶点漫反射：有锯齿 应该是因为处理是每个片元的顶点 所以不精细</li>\n<li>逐像素漫反射：无锯齿 但是黑面太黑 都是一个色 黑色</li>\n<li>半伯兰特模型：无锯齿 黑面有渐变<br>c = c <em> m (0.5 (n </em> I) + 0.5)<h4 id=\"7-基础纹理\"><a href=\"#7-基础纹理\" class=\"headerlink\" title=\"7 基础纹理\"></a>7 基础纹理</h4></li>\n<li>记住这个 ： o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<h6 id=\"7-1-2-纹理取样\"><a href=\"#7-1-2-纹理取样\" class=\"headerlink\" title=\"7.1.2 纹理取样\"></a>7.1.2 纹理取样</h6>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</li>\n</ul>\n<h6 id=\"7-2-凹凸映射\"><a href=\"#7-2-凹凸映射\" class=\"headerlink\" title=\"7.2 凹凸映射\"></a>7.2 凹凸映射</h6><p>不改变顶点 改变的是绘制<br>法线纹理 normal map</p>\n<h6 id=\"7-2-1高度纹理\"><a href=\"#7-2-1高度纹理\" class=\"headerlink\" title=\"7.2.1高度纹理\"></a>7.2.1高度纹理</h6><p>存储的是强度值   这个通过高度来计算法线<br>颜色越浅越突 反而凹</p>\n<h6 id=\"7-2-2法线纹理\"><a href=\"#7-2-2法线纹理\" class=\"headerlink\" title=\"7.2.2法线纹理\"></a>7.2.2法线纹理</h6><p>法线的向量分量是 -1 到1<br>所以 pixel = (noamal+1)/2<br>normal = (pixel * 2) - 1</p>\n<p>这种纹理称为是模型空间的法线纹理  我恩会采用另外一种坐标空间 切线空间  我们用模型顶点的切线空间来存储法线  对于每个顶点都有一个属于自己的切线空间 这个切线空间的原点就是该顶点本身 z 轴就是顶点的法线 x 轴是顶点的切线方向</p>\n<p>我们的法线纹理 存储的是 法线在各自的切线空间的向量 大部分都是浅蓝色的原因是 0 0 1映射到0 1就是0.5 0.5 1（浅蓝色） 0 0 1就是 z 轴  大部分的法线都是跟切线空间的 z 轴同方向</p>\n<p>一种是模型空间下的法线纹理 一种是切线空间下的法线纹理</p>\n<p>模型空间存储的优点：</p>\n<ul>\n<li>实现简单 直观。生成简单</li>\n<li>提供平滑的边界 模型空间可以生成平滑</li>\n</ul>\n<p>切线空间优点：</p>\n<ul>\n<li>自由度高 模型空间的是绝对法线信息  应用到不同网格都有合理的效果</li>\n<li>可进行 UV 动画 我们通过移动一个纹理的 UV 坐标来实现凹凸移动的效果</li>\n<li>可压缩  只此处 xy  z 可以推倒得到 </li>\n</ul>\n<h6 id=\"7-2-3-实践\"><a href=\"#7-2-3-实践\" class=\"headerlink\" title=\"7.2.3 实践\"></a>7.2.3 实践</h6><ul>\n<li>一种在切线空间下进行光照计算 把光照方向、视角方向变换到切线空间下 ：效率比较高  在顶点着色器可以完成 光照和视角的转换  第二种要堆法线纹理取样 需要在片元着色器中变换 我觉得应该是片元的数量大于顶点的数量所以转换需要很多<br>有时我们要在世界空间下进行一些计算 例如在 Cubemap进行环境映射 需要使用世界空间下进行一些计算 （这个 cubemap 不知讲啥）</li>\n<li>另外一种是在世界坐标空间下进行光照计算 我们要把切线空间下的法线防线转换到世界空间下：</li>\n</ul>\n<ol>\n<li>在切线空间下计算<br>思路：在片元着色器中得到纹理采样的切线空间下的法线 然后再与切线空间下的视角方向 光照方向进行计算<br>注：float4 texcoord : TEXCOORD0; 传入的是float4 xy 是原因的纹理 UV zw 是法线纹理 uv</li>\n</ol>\n<h6 id=\"7-2-4-unity-法线纹理类型\"><a href=\"#7-2-4-unity-法线纹理类型\" class=\"headerlink\" title=\"7.2.4 unity 法线纹理类型\"></a>7.2.4 unity 法线纹理类型</h6><p>法线纹理会根据平台被压缩<br>使用 unpackNormal 函数取解压<br>普通纹理的话 是4个通道都是不能舍弃  如果是法线纹理 那么只有ag 是需呀的 br 是不需要的 用 DXT5nm 可以升内存空间。<br>Create from Grayscale 是凹凸映射的方法 高度图 </p>\n<h5 id=\"7-3渐变纹理\"><a href=\"#7-3渐变纹理\" class=\"headerlink\" title=\"7.3渐变纹理\"></a>7.3渐变纹理</h5><h5 id=\"7-4遮罩纹理\"><a href=\"#7-4遮罩纹理\" class=\"headerlink\" title=\"7.4遮罩纹理\"></a>7.4遮罩纹理</h5><p>使用其中某个（或者几个）通道做乘法 如果通道为0 可以保证表面不受该属性影响 </p>\n<h4 id=\"8透明效果\"><a href=\"#8透明效果\" class=\"headerlink\" title=\"8透明效果\"></a>8透明效果</h4><p>unity 先渲染 Background 然后渲染 Geometry 大多数的不透明物体 前面都是开启深度测试和深度写入   之后渲染 AlphaTest 这个是透明物体  需要排序 从远到近 然后进行渲染</p>\n<h5 id=\"8-3透明度测试\"><a href=\"#8-3透明度测试\" class=\"headerlink\" title=\"8.3透明度测试\"></a>8.3透明度测试</h5><p>用一个阀值决定</p>\n<h5 id=\"8-4透明度混合\"><a href=\"#8-4透明度混合\" class=\"headerlink\" title=\"8.4透明度混合\"></a>8.4透明度混合</h5><p>Blend 内置的混合模式命令<br>Blend off 关闭混合<br>Blend SrcFactor DstFactor<br>srccolor <em> SrcFactor + dstcolor </em> DstFactor = Target</p>\n<h6 id=\"8-6-1-混合等式和参数\"><a href=\"#8-6-1-混合等式和参数\" class=\"headerlink\" title=\"8.6.1 混合等式和参数\"></a>8.6.1 混合等式和参数</h6><p>现在有 源颜色 S 和目标颜色 D 现在想要得到输出颜色 O 就必须使用一个等式来计算，这个就是混合等式<br>我们会用两个混合等式  一个用于混合 RGB 一个混合 A 通道 每个等式要两个因子   一共四个因子。</p>\n<p>中级篇</p>\n<p>####9 更复杂的光照<br>Forward Rendering Path、Deferred Rendering Path Vertext Lit Rendering Path</p>\n<p>顶点照明渲染路径：是对硬件配置要求最好  运算性能最高的</p>\n<p>跳过。。。</p>\n<h4 id=\"10-高级纹理\"><a href=\"#10-高级纹理\" class=\"headerlink\" title=\"10 高级纹理\"></a>10 高级纹理</h4><h5 id=\"10-1立方体纹理\"><a href=\"#10-1立方体纹理\" class=\"headerlink\" title=\"10.1立方体纹理\"></a>10.1立方体纹理</h5><p>立方体纹理是环境映射的一种实现方法<br>包含6张图像  采样的时候是用三维的坐标 </p>\n<p>使用立方体纹理的好处 实现简单快捷 得到的效果好  缺点是 如果当场景引入了新的物体 光源 或者物体在发生移动时 我们就需要重新生成 立方体纹理  可以反射环境  但不能反射自己  </p>\n<h6 id=\"10-1-1-天空盒子\"><a href=\"#10-1-1-天空盒子\" class=\"headerlink\" title=\"10.1.1 天空盒子\"></a>10.1.1 天空盒子</h6><p>windows -lighting 里面设置 skybox</p>\n<h6 id=\"10-1-2折射\"><a href=\"#10-1-2折射\" class=\"headerlink\" title=\"10.1.2折射\"></a>10.1.2折射</h6><p>折射 是用光照计算函数 然后用折射函数混合反射光</p>\n<h5 id=\"10-2渲染纹理\"><a href=\"#10-2渲染纹理\" class=\"headerlink\" title=\"10.2渲染纹理\"></a>10.2渲染纹理</h5><h5 id=\"10-2程序纹理\"><a href=\"#10-2程序纹理\" class=\"headerlink\" title=\"10.2程序纹理\"></a>10.2程序纹理</h5><h4 id=\"11-让画面动起来\"><a href=\"#11-让画面动起来\" class=\"headerlink\" title=\"11 让画面动起来\"></a>11 让画面动起来</h4><h5 id=\"11-1-unity-shader-中的内置变量\"><a href=\"#11-1-unity-shader-中的内置变量\" class=\"headerlink\" title=\"11.1 unity shader 中的内置变量\"></a>11.1 unity shader 中的内置变量</h5><p>_Time float4 场景加载开始所经过的实际<br>_SinTime 正弦值<br>_CosTime 余弦值<br>unity_DeltaTime </p>\n<h5 id=\"11-2-纹理动画\"><a href=\"#11-2-纹理动画\" class=\"headerlink\" title=\"11.2 纹理动画\"></a>11.2 纹理动画</h5><ul>\n<li>序列帧动画：记住 UV 纹理坐标是左下角是原点</li>\n<li>滚动的背景：修改 UV 纹理坐标 对两张纹理取样 然后混合</li>\n</ul>\n","excerpt":"<h2 id=\"总体的思维导图\"><a href=\"#总体的思维导图\" class=\"headerlink\" title=\"总体的思维导图\"></a>总体的思维导图</h2><p>通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。<br><img src=\"/2017/07/30/unity_study/1496577433020.png\" alt=\"Alt text\"></p>","more":"<h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><h4 id=\"1、安装教程（windows）\"><a href=\"#1、安装教程（windows）\" class=\"headerlink\" title=\"1、安装教程（windows）\"></a>1、安装教程（windows）</h4><p>mac就比较简单 官网下载dmg就可以安装使用了<br>我用下面图中的两个文件完成安装，一个是安装文件（4.7），一个是破解，然后根据下面链接完成安装<br><img src=\"/2017/07/30/unity_study/1496577678948.png\" alt=\"Alt text\"></p>\n<p><a href=\"http://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html\">http://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html</a></p>\n<h4 id=\"2、需要的文件（百度网盘分享）\"><a href=\"#2、需要的文件（百度网盘分享）\" class=\"headerlink\" title=\"2、需要的文件（百度网盘分享）\"></a>2、需要的文件（百度网盘分享）</h4><p><a href=\"http://pan.baidu.com/s/1slFHeFz\">http://pan.baidu.com/s/1slFHeFz</a></p>\n<ul>\n<li>分享的文件里的东西有：<ul>\n<li>【安装使用】：Unity 4.7.1安装文件</li>\n<li>【安装使用】：Unity 4.x pro Patch.exe</li>\n<li>【入门使用】：《unity4.x从入门到精通》</li>\n<li>【入门使用】：简单的工程（微信飞机游戏）：</li>\n<li>【进一步了解使用】：RPG游戏的简单的工程</li>\n<li>【shader学习使用】：《Unity Shader入门精要》</li>\n<li><h4 id=\"3、安装结果\"><a href=\"#3、安装结果\" class=\"headerlink\" title=\"3、安装结果\"></a>3、安装结果</h4>使用a.Unity 4.7.1安装文件 b.Unity 4.x pro Patch.exe  然后用上上面的教程链接就可以完成windows unity的安装  打开如下：<br><img src=\"/2017/07/30/unity_study/1496583208861.png\" alt=\"Alt text\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、入门学习：\"><a href=\"#二、入门学习：\" class=\"headerlink\" title=\"二、入门学习：\"></a>二、入门学习：</h2><h4 id=\"1、开始我找了本书看《unity4-x从入门到精通》：\"><a href=\"#1、开始我找了本书看《unity4-x从入门到精通》：\" class=\"headerlink\" title=\"1、开始我找了本书看《unity4.x从入门到精通》：\"></a>1、开始我找了本书看《unity4.x从入门到精通》：</h4><p>《unity4.x从入门到精通》<br><a href=\"http://pan.baidu.com/s/1slFHeFz\">http://pan.baidu.com/s/1slFHeFz</a></p>\n<h4 id=\"2、《unity4-x从入门到精通》读书的记录：\"><a href=\"#2、《unity4-x从入门到精通》读书的记录：\" class=\"headerlink\" title=\"2、《unity4.x从入门到精通》读书的记录：\"></a>2、《unity4.x从入门到精通》读书的记录：</h4><h5 id=\"第一章-（可跳过）\"><a href=\"#第一章-（可跳过）\" class=\"headerlink\" title=\"第一章 （可跳过）\"></a>第一章 （可跳过）</h5><p>第一章 没什么干货 可以直接跳过</p>\n<h5 id=\"第二章-（重点看2-1-2-2-实操一下）\"><a href=\"#第二章-（重点看2-1-2-2-实操一下）\" class=\"headerlink\" title=\"第二章  （重点看2.1  2.2+实操一下）\"></a>第二章  （重点看2.1  2.2+实操一下）</h5><ul>\n<li>刚接触的unity的可以按照第二章说的去操作一下  感受一下unity的一些功能 想贪快的就看<strong>2.1</strong> 、<strong>2.2</strong>部分即可 后面的用到再查阅</li>\n<li>快捷键部分 等到基本入门了 再来看一遍 会比较受用的感觉  </li>\n</ul>\n<h5 id=\"第三章-（粗略看）\"><a href=\"#第三章-（粗略看）\" class=\"headerlink\" title=\"第三章 （粗略看）\"></a>第三章 （粗略看）</h5><ul>\n<li>第三章看下 不用纠那么细致 <h5 id=\"第四章-（重点看-操作）\"><a href=\"#第四章-（重点看-操作）\" class=\"headerlink\" title=\"第四章 （重点看+操作）\"></a>第四章 （重点看+操作）</h5></li>\n<li>第四章书讲的是怎么写代码的 看完第四章就会输出hello world<h5 id=\"截取两张图\"><a href=\"#截取两张图\" class=\"headerlink\" title=\"截取两张图\"></a>截取两张图</h5><img src=\"/2017/07/30/unity_study/1490002232972.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1490002240157.png\" alt=\"Alt text\"></li>\n</ul>\n<h5 id=\"后面5-17章的当作工具书看\"><a href=\"#后面5-17章的当作工具书看\" class=\"headerlink\" title=\"后面5-17章的当作工具书看\"></a>后面5-17章的当作工具书看</h5><p>12章 到16  是针对开发的介绍</p>\n<p>17章 进阶 ： 网络</p>\n<h4 id=\"3、大致的浏览了《unity4-x从入门到精通》-前四章之后带着几个疑问去分类学习：\"><a href=\"#3、大致的浏览了《unity4-x从入门到精通》-前四章之后带着几个疑问去分类学习：\" class=\"headerlink\" title=\"3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：\"></a>3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：</h4><h5 id=\"3-1、C-代码跟unity怎么关联起来？-书中13章\"><a href=\"#3-1、C-代码跟unity怎么关联起来？-书中13章\" class=\"headerlink\" title=\"3.1、C#代码跟unity怎么关联起来？  书中13章\"></a>3.1、C#代码跟unity怎么关联起来？  书中13章<img src=\"/2017/07/30/unity_study/1491552037983.png\" alt=\"Alt text\"></h5><h6 id=\"1、C-脚本的规则\"><a href=\"#1、C-脚本的规则\" class=\"headerlink\" title=\"1、C#脚本的规则\"></a>1、C#脚本的规则</h6><p>（1）凡事需要添加到游戏对象的C#脚本类都是需要直接或者间接的继承 MonoBehaviour 如果在unity添加脚本 unity会自动填充继承MonoBehaviour的代码  如果是自己新建一个文件 然后在unity从拖拽添加component 这样是不会成功的（后面会说unity怎么添加C#文件）</p>\n<p>（2）继承了MonoBehaviour的类 都会有Start 和 Awake函数的继承  一般使用Start和Awake来初始化  不使用构造函数的原因是unity中无法确定构造函数的顺序。这里我觉得有个原因是：unity会把所有绑定在对象身上的类实例化  然后才可以GetComponent()  例如：下面的操作如果在构造函数中做 可能PlayerAttack这个没有实例化 那么获取不到  所以把初始化工作放在Start中<br><img src=\"/2017/07/30/unity_study/1491552515808.png\" alt=\"Alt text\"></p>\n<p>（3）类名和脚本文件名相同 </p>\n<p>（4）协同函数Coroutines 返回类型必须是Ienumerator</p>\n<p>（5）C#不支持自定义命名空间</p>\n<h6 id=\"2、C-脚本在unity编辑器中关联对象（十三章有详细介绍）\"><a href=\"#2、C-脚本在unity编辑器中关联对象（十三章有详细介绍）\" class=\"headerlink\" title=\"2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）\"></a>2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）</h6><p>1、创建脚本的方法：<br><img src=\"/2017/07/30/unity_study/1491553048549.png\" alt=\"Alt text\"></p>\n<p>2、创建完之后的编辑：<br>这里可以修改用MonoDevelop的编辑器 或者用Vs2012作为代码编辑<br><img src=\"/2017/07/30/unity_study/1491553152505.png\" alt=\"Alt text\"></p>\n<p>3、关联到对象去<br>（3.1）添加一个gameobject<br><img src=\"/2017/07/30/unity_study/1491553612376.png\" alt=\"Alt text\"><br>（3.2） 然后给gameObject添加脚本<br><img src=\"/2017/07/30/unity_study/1491553537327.png\" alt=\"Alt text\"><img src=\"/2017/07/30/unity_study/1491553548688.png\" alt=\"Alt text\"></p>\n<p>在Unity中，继承MonoBehaviour的C#脚本都被看作一个Component 游戏对象可以理解为一个容纳各种类型component的容器 游戏对象的所有component一起决定了这个对象的行为表现 这个对象被添加到scene中之后 然后点击build and run 之后这个脚本的Start函数就会被调用一起  可以在这里输出 hello world  这就算是unity的hello world</p>\n<h6 id=\"3、怎么获取别的对象以及他的component\"><a href=\"#3、怎么获取别的对象以及他的component\" class=\"headerlink\" title=\"3、怎么获取别的对象以及他的component\"></a>3、怎么获取别的对象以及他的component</h6><p>使用函数 GameObject.Find  null则是找不到  根据类名<br>使用函数GameObject.FindWithTag<br>还有在unity编辑器中拖拽</p>\n<p>查看数组的表13-6 表13-7  表13-8  表13-9 </p>\n<p><img src=\"/2017/07/30/unity_study/1491555497064.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555396564.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555581945.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555622726.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491555636221.png\" alt=\"Alt text\"></p>\n<h2 id=\"三、工程学习：\"><a href=\"#三、工程学习：\" class=\"headerlink\" title=\"三、工程学习：\"></a>三、工程学习：</h2><p>看了《unity4.x从入门到精通》 简单操作unity之后 我上网找几个简单的游戏demo来看下，这样我觉得会比较快上手。</p>\n<h3 id=\"1、微信飞机大战\"><a href=\"#1、微信飞机大战\" class=\"headerlink\" title=\"1、微信飞机大战\"></a>1、微信飞机大战</h3><p>工程下载地址：<br><a href=\"http://pan.baidu.com/s/1slFHeFz\">http://pan.baidu.com/s/1slFHeFz</a> （网上找的工程）<br>这个比较容易看懂   </p>\n<p>下面说明的过程：<br>（1）背景移动 –&gt;（2）敌机出生–&gt;（3）自己的飞行<br><img src=\"/2017/07/30/unity_study/ply1.gif\" alt=\"背景移动\">==》 <img src=\"/2017/07/30/unity_study/ply2.gif\" alt=\"敌机出生\">==》 <img src=\"/2017/07/30/unity_study/ply3.gif\" alt=\"自己的飞行\"></p>\n<h4 id=\"1、初看这个工程\"><a href=\"#1、初看这个工程\" class=\"headerlink\" title=\"1、初看这个工程\"></a>1、初看这个工程</h4><p>只有一个场景scene<br><img src=\"/2017/07/30/unity_study/1496655674282.png\" alt=\"Alt text\"><br>预制体有这些<br><img src=\"/2017/07/30/unity_study/1496663793026.png\" alt=\"Alt text\"><br>脚本是这些<br><img src=\"/2017/07/30/unity_study/1496663193818.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、分几个部分看\"><a href=\"#2、分几个部分看\" class=\"headerlink\" title=\"2、分几个部分看\"></a>2、分几个部分看</h4><h5 id=\"2-1、scene\"><a href=\"#2-1、scene\" class=\"headerlink\" title=\"2.1、scene\"></a>2.1、scene</h5><p><img src=\"/2017/07/30/unity_study/1496664667730.png\" alt=\"Alt text\"><br>1.里面有个 Main Camera 点击它然后看导航栏Inspector<br>2.Main Camera里面有一些component组件 其中Camera 去修改size view port然后运行看下结果<br><img src=\"/2017/07/30/unity_study/1496664752184.png\" alt=\"Alt text\"><br>3.除了Main Camera 这个Scene里面还有一些飞机（hero） 背景（bg） 还一些不是UI的东西（bombManager）</p>\n<p>上面大概的了解到，在这个Scene里面拖拽了一些物件 还有一个摄像机 把这些物件投影到屏幕中，到目前为止，我们大概知道是怎么得到游戏的静态界面的，但是游戏是怎么动起来的还不知道。接下来脚本就是讲怎么动起来的。</p>\n<h5 id=\"2-2、脚本\"><a href=\"#2-2、脚本\" class=\"headerlink\" title=\"2.2、脚本\"></a>2.2、脚本</h5><ol>\n<li>代码入口，没有一个明确的Main函数入口<br>下面按照顺序说下（1）背景移动 （2）怎么生成敌机  （3）怎么控制自己的战机<br><img src=\"/2017/07/30/unity_study/1496665501144.png\" alt=\"Alt text\"><br>（1）背景移动<br>scene里面有个object叫bg 然后再点击其中一个background查看导航栏<br>可以看到每个background都挂在了一个脚本组件 BackgroundTransform.cs  这个脚本就是控制不背景移动的<br><img src=\"/2017/07/30/unity_study/1497515757683.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1497515795595.png\" alt=\"Alt text\"></li>\n</ol>\n<p>看到BackgroundTransform这个脚本 两个背景来控制屏幕的背景交替向下移动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class BackgroundTransform : MonoBehaviour &#123;</div><div class=\"line\">\tpublic static float moveSpeed = 2f;</div><div class=\"line\">\t</div><div class=\"line\">\t// Update is called once per frame</div><div class=\"line\">\tvoid Update () &#123;</div><div class=\"line\">\t\tthis.transform.Translate( Vector3.down * moveSpeed * Time.deltaTime );</div><div class=\"line\">\t\tVector3 postion = this.transform.position;</div><div class=\"line\">\t\tif(postion.y&lt;=-8.52f)&#123;</div><div class=\"line\">\t\t\t//有两个背景在交替滚动  如果有一个滚动到屏幕外面则改动显示</div><div class=\"line\">\t\t\tthis.transform.position = new Vector3(postion.x,postion.y+8.52f*2,postion.z );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（2）怎么生成敌机<br>scene里面有个叫spawn的东西  这个spawn十个空object 里面挂了一个spawn.cs脚本组件<br><img src=\"/2017/07/30/unity_study/1497516506138.png\" alt=\"Alt text\"><br>【代码如下】：<br><img src=\"/2017/07/30/unity_study/1497516724024.png\" alt=\"Alt text\"></p>\n<p>地机的行为就看模型上面挂的脚本组件Enemy.cs</p>\n<p>（3）怎么控制自己的战机<br>同样的在hero这个上面挂了Hero.cs的脚本组件  然后具体就看里面的代码<br><img src=\"/2017/07/30/unity_study/1497516894694.png\" alt=\"Alt text\"></p>\n<h3 id=\"2、RPG游戏\"><a href=\"#2、RPG游戏\" class=\"headerlink\" title=\"2、RPG游戏\"></a>2、RPG游戏</h3><p>然后再找个复杂点的游戏工程来看</p>\n<h4 id=\"1、初看工程\"><a href=\"#1、初看工程\" class=\"headerlink\" title=\"1、初看工程\"></a>1、初看工程</h4><ul>\n<li>工程下载地址：<br><a href=\"http://pan.baidu.com/s/1slFHeFz（网上找的工程）\">http://pan.baidu.com/s/1slFHeFz（网上找的工程）</a></li>\n<li>工程的脚本目录<br><img src=\"/2017/07/30/unity_study/1491550201008.png\" alt=\"Alt text\"></li>\n</ul>\n<h4 id=\"2、工程代码查看\"><a href=\"#2、工程代码查看\" class=\"headerlink\" title=\"2、工程代码查看\"></a>2、工程代码查看</h4><p><strong>看下怎么把这个人物控制方向运动起来的</strong><br><img src=\"/2017/07/30/unity_study/rpg.gif\" alt=\"Alt text\"></p>\n<p>1.打开03_play这个scene 然后拖拽一个Magician模型到scene中<br>先在Prefabs文件夹中找到Magician看模型有什么挂件</p>\n<ul>\n<li><p>Magician挂了Character Controller这个控制组件<br>这个是角色控制器 可以对角色做移动的操作 在playermove脚本里面用到</p>\n</li>\n<li><p>Magician还挂了PlayerDir PlayerMove  PlayerAnimation PlayerState PlayerAttack等脚本来实现模型的行为<br>看下PlayerMove的update函数<br><img src=\"/2017/07/30/unity_study/1491550243585.png\" alt=\"Alt text\"><br>这里判断如果距离大于0.3f则会移动</p>\n</li>\n</ul>\n<p>从Magician引发的问题：</p>\n<h5 id=\"2-1、移动的时候有个targetPosition-这个是怎么来的？\"><a href=\"#2-1、移动的时候有个targetPosition-这个是怎么来的？\" class=\"headerlink\" title=\"2.1、移动的时候有个targetPosition 这个是怎么来的？\"></a>2.1、移动的时候有个targetPosition 这个是怎么来的？</h5><p>targetPosition 是PlayerDir.cs这个里面的成员<br>PlayerDir.cs里面会计算鼠标点击屏幕的位置发出的射线的碰撞结果 如果是地面那么修改这个玩家的朝向<br><img src=\"/2017/07/30/unity_study/1497532344804.png\" alt=\"Alt text\"></p>\n<h5 id=\"2-2、又引发一个问题鼠标怎么会变样？\"><a href=\"#2-2、又引发一个问题鼠标怎么会变样？\" class=\"headerlink\" title=\"2.2、又引发一个问题鼠标怎么会变样？\"></a>2.2、又引发一个问题鼠标怎么会变样？</h5><p>我们看到03_play这个scene有个object叫GameSetting 这个是一个纯粹为了挂脚本用的object<br><img src=\"/2017/07/30/unity_study/1497531965474.png\" alt=\"Alt text\"><br>我们看到这个CursorManager就是我们在游戏中的鼠标的管理类</p>\n<h5 id=\"2-3、模型怎么会动起来呢？\"><a href=\"#2-3、模型怎么会动起来呢？\" class=\"headerlink\" title=\"2.3、模型怎么会动起来呢？\"></a>2.3、模型怎么会动起来呢？</h5><p>打开03_play这个scene 然后拖拽一个Magician模型到scene中 然后在菜单栏window animation打开animation窗口 然后可以选择已经做好的动作 attack1 然后点击播放 现在我们知道动作可以预先做好 然后再代码中调用 我们看下代码是怎么调用的<br><img src=\"/2017/07/30/unity_study/1497533865288.png\" alt=\"Alt text\"><br>PlayerAnimation.cs这个脚本 根据一个状态去 播放动画animation.CrossFade(animName);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Update is called once per frame</div><div class=\"line\">\tvoid LateUpdate () &#123;</div><div class=\"line\">        if (attack.state == PlayerState.ControlWalk) &#123;</div><div class=\"line\">            if (move.state == ControlWalkState.Moving) &#123;</div><div class=\"line\">                PlayAnim(&quot;Run&quot;);</div><div class=\"line\">            &#125; else if (move.state == ControlWalkState.Idle) &#123;</div><div class=\"line\">                PlayAnim(&quot;Idle&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (attack.state == PlayerState.NormalAttack) &#123;</div><div class=\"line\">            if (attack.attack_state == AttackState.Moving) &#123;</div><div class=\"line\">                PlayAnim(&quot;Run&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvoid PlayAnim(string animName) &#123;</div><div class=\"line\">        animation.CrossFade(animName);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个项目的运行<br><img src=\"/2017/07/30/unity_study/1491877171720.png\" alt=\"Alt text\"><br><img src=\"/2017/07/30/unity_study/1491877201762.png\" alt=\"Alt text\"></p>\n<p>之后看下怎么改改这个项目  不懂的再google 或者再去细看unity的一些用法 或则C#的用法</p>\n<h2 id=\"四、Unity-Shader学习\"><a href=\"#四、Unity-Shader学习\" class=\"headerlink\" title=\"四、Unity Shader学习\"></a>四、Unity Shader学习</h2><h3 id=\"A、我学习的三个点\"><a href=\"#A、我学习的三个点\" class=\"headerlink\" title=\"A、我学习的三个点\"></a>A、我学习的三个点</h3><hr>\n<h4 id=\"1-下载源码中源码下载：\"><a href=\"#1-下载源码中源码下载：\" class=\"headerlink\" title=\"1.下载源码中源码下载：\"></a>1.下载源码中源码下载：</h4><p><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a></p>\n<h4 id=\"2-学习hello-world\"><a href=\"#2-学习hello-world\" class=\"headerlink\" title=\"2.学习hello world!\"></a>2.学习hello world!</h4><p><strong>下面gif是unity shader的hello world!</strong><br><img src=\"/2017/07/30/unity_study/shader2.gif\" alt=\"Alt text\"></p>\n<h4 id=\"3-看书照着源码学习-然后实践\"><a href=\"#3-看书照着源码学习-然后实践\" class=\"headerlink\" title=\"3.看书照着源码学习 然后实践\"></a>3.看书照着源码学习 然后实践</h4><h3 id=\"B、学习随便记录的笔记\"><a href=\"#B、学习随便记录的笔记\" class=\"headerlink\" title=\"B、学习随便记录的笔记\"></a>B、学习随便记录的笔记</h3><hr>\n<h4 id=\"1-第一章\"><a href=\"#1-第一章\" class=\"headerlink\" title=\"1.第一章\"></a>1.第一章</h4><h4 id=\"2-第二章-渲染流水线\"><a href=\"#2-第二章-渲染流水线\" class=\"headerlink\" title=\"2.第二章 渲染流水线\"></a>2.第二章 渲染流水线</h4><p>应用阶段-&gt;几何阶段-&gt;光栅化阶段<br>应用阶段把渲染图元交给几何阶段</p>\n<h5 id=\"2-2CPU-和-GPU-的通信\"><a href=\"#2-2CPU-和-GPU-的通信\" class=\"headerlink\" title=\"2.2CPU 和 GPU 的通信\"></a>2.2CPU 和 GPU 的通信</h5><ol>\n<li>把数据加载到显存中</li>\n<li>设置渲染状态</li>\n<li>调用 drallcall</li>\n</ol>\n<p><strong>1.把数据加载到显存中</strong><br>硬盘—&gt;内存—&gt;显存<br>顶点数据 法线方向 纹理坐标</p>\n<p><strong>2.设置渲染状态</strong><br>vs ps<br>顶点着色器 片元着色器</p>\n<p><strong>3.drawcall</strong></p>\n<h5 id=\"2-3GPU-流水线\"><a href=\"#2-3GPU-流水线\" class=\"headerlink\" title=\"2.3GPU 流水线\"></a>2.3GPU 流水线</h5><h6 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h6><p>把顶点坐标转换到齐次裁剪坐标系得到归一化的设备坐标 NDC<br>opengl unity的 NDC 是-1 1<br>屏幕映射 转换到屏幕坐标系<br>屏幕坐标系Opengl 是左下角</p>\n<h4 id=\"3-第三章-Unity-shader基础\"><a href=\"#3-第三章-Unity-shader基础\" class=\"headerlink\" title=\"3.第三章 Unity shader基础\"></a>3.第三章 Unity shader基础</h4><h5 id=\"3-1-创建shader的常见流程\"><a href=\"#3-1-创建shader的常见流程\" class=\"headerlink\" title=\"3.1 创建shader的常见流程\"></a>3.1 创建shader的常见流程</h5><ol>\n<li>创建一个材质</li>\n<li>创建一个unity shader 并把它赋给上一步中创建的材质</li>\n<li>把材质赋给要渲染的对象</li>\n<li>在材质面板上（选中材质然后查看导航栏）调整shader的属性</li>\n</ol>\n<h5 id=\"3-2-shader-lab\"><a href=\"#3-2-shader-lab\" class=\"headerlink\" title=\"3.2 shader lab\"></a>3.2 shader lab</h5><p>GLSL是opengl的shader语言 Directx的shader语言是HLSL   shader lab的就是 unity shader的shader语言<br>可以细看下这个章节  熟悉下语法</p>\n<h4 id=\"4-学习-Shader-所需的数学知识\"><a href=\"#4-学习-Shader-所需的数学知识\" class=\"headerlink\" title=\"4 学习 Shader 所需的数学知识\"></a>4 学习 Shader 所需的数学知识</h4><p>一些基础的知识都是大概知道 可以等到要用到的时候再去复习<br>一些空间 M 模型空间 W 世界空间 V 摄像机空间 NDC 归一化空间</p>\n<h4 id=\"5-开始学习-Shader\"><a href=\"#5-开始学习-Shader\" class=\"headerlink\" title=\"5 开始学习 Shader\"></a>5 开始学习 Shader</h4><h5 id=\"5-2-最简单的片元着色器-顶点着色器\"><a href=\"#5-2-最简单的片元着色器-顶点着色器\" class=\"headerlink\" title=\"5.2 最简单的片元着色器 顶点着色器\"></a>5.2 最简单的片元着色器 顶点着色器</h5><h6 id=\"5-2-2-unity支持的语义：\"><a href=\"#5-2-2-unity支持的语义：\" class=\"headerlink\" title=\"5.2.2 unity支持的语义：\"></a>5.2.2 unity支持的语义：</h6><p>POSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，COLOR</p>\n<h6 id=\"5-2-3-顶点着色器和片元着色器之间的通信：\"><a href=\"#5-2-3-顶点着色器和片元着色器之间的通信：\" class=\"headerlink\" title=\"5.2.3 顶点着色器和片元着色器之间的通信：\"></a>5.2.3 顶点着色器和片元着色器之间的通信：</h6><p>声明一个新的结构体v2f v2f可用于定点着色器和片元着色器之间传递信息</p>\n<h6 id=\"5-3-1内置包含的文件\"><a href=\"#5-3-1内置包含的文件\" class=\"headerlink\" title=\"5.3.1内置包含的文件\"></a>5.3.1内置包含的文件</h6><p>在后面的学习中 总是会用到一些内置的文件<br>需要include一下 类似C++的include</p>\n<h5 id=\"5-5-Debug技巧\"><a href=\"#5-5-Debug技巧\" class=\"headerlink\" title=\"5.5 Debug技巧\"></a>5.5 Debug技巧</h5><ol>\n<li>把想知道的值赋值到某个颜色 通过屏幕上显示的颜色来判断一个值</li>\n<li>还可以找到一个简单的取色脚本  ColorPicker.cs</li>\n<li>高级的：Visual Studio Graphics Debugger</li>\n<li>Unity里面的帧调试器</li>\n</ol>\n<h4 id=\"6-Unity-中的基础光照\"><a href=\"#6-Unity-中的基础光照\" class=\"headerlink\" title=\"6 Unity 中的基础光照\"></a>6 Unity 中的基础光照</h4><h5 id=\"6-2-进入摄像机的光分成4个部分\"><a href=\"#6-2-进入摄像机的光分成4个部分\" class=\"headerlink\" title=\"6.2 进入摄像机的光分成4个部分\"></a>6.2 进入摄像机的光分成4个部分</h5><ul>\n<li>自发光：本身辐射量  如果没有全局光照技术 自会影响自己的辐射量</li>\n<li>高光反射：（我觉得是完全镜面反射）光源的完全镜面反射方向散射多少辐射量？？ 是镜面反射的散射？？</li>\n<li>漫反射：这个就是光源的漫反射</li>\n<li>环境光：其他所有的间接光照</li>\n</ul>\n<p>计算高光反射：<img src=\"/2017/07/30/unity_study/1495002356532.png\" alt=\"Alt text\"><br>Phong 模型来计算高光反射部分：<br><img src=\"/2017/07/30/unity_study/1495002389507.png\" alt=\"Alt text\"></p>\n<h5 id=\"6-4-光照实现\"><a href=\"#6-4-光照实现\" class=\"headerlink\" title=\"6.4 光照实现\"></a>6.4 光照实现</h5><p>（1）Properties定义一个颜色值<br>（2）LightMode标签是 Pass 标签的一种 只有定义了正确的 LightMode 我们才能得到一些 Unity的内置光照变量<br>Tags { “LightMode”=”ForwardBase” }</p>\n<p>（3）还是之前的 CGPROGRAM ENDCG</p>\n<p>（4）为了用到 Unity的内置变量<br>‘’’ #include “Lighting.cginc”  “‘</p>\n<p>（5）逐顶点 着色器</p>\n<ul>\n<li>逐顶点漫反射：有锯齿 应该是因为处理是每个片元的顶点 所以不精细</li>\n<li>逐像素漫反射：无锯齿 但是黑面太黑 都是一个色 黑色</li>\n<li>半伯兰特模型：无锯齿 黑面有渐变<br>c = c <em> m (0.5 (n </em> I) + 0.5)<h4 id=\"7-基础纹理\"><a href=\"#7-基础纹理\" class=\"headerlink\" title=\"7 基础纹理\"></a>7 基础纹理</h4></li>\n<li>记住这个 ： o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<h6 id=\"7-1-2-纹理取样\"><a href=\"#7-1-2-纹理取样\" class=\"headerlink\" title=\"7.1.2 纹理取样\"></a>7.1.2 纹理取样</h6>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</li>\n</ul>\n<h6 id=\"7-2-凹凸映射\"><a href=\"#7-2-凹凸映射\" class=\"headerlink\" title=\"7.2 凹凸映射\"></a>7.2 凹凸映射</h6><p>不改变顶点 改变的是绘制<br>法线纹理 normal map</p>\n<h6 id=\"7-2-1高度纹理\"><a href=\"#7-2-1高度纹理\" class=\"headerlink\" title=\"7.2.1高度纹理\"></a>7.2.1高度纹理</h6><p>存储的是强度值   这个通过高度来计算法线<br>颜色越浅越突 反而凹</p>\n<h6 id=\"7-2-2法线纹理\"><a href=\"#7-2-2法线纹理\" class=\"headerlink\" title=\"7.2.2法线纹理\"></a>7.2.2法线纹理</h6><p>法线的向量分量是 -1 到1<br>所以 pixel = (noamal+1)/2<br>normal = (pixel * 2) - 1</p>\n<p>这种纹理称为是模型空间的法线纹理  我恩会采用另外一种坐标空间 切线空间  我们用模型顶点的切线空间来存储法线  对于每个顶点都有一个属于自己的切线空间 这个切线空间的原点就是该顶点本身 z 轴就是顶点的法线 x 轴是顶点的切线方向</p>\n<p>我们的法线纹理 存储的是 法线在各自的切线空间的向量 大部分都是浅蓝色的原因是 0 0 1映射到0 1就是0.5 0.5 1（浅蓝色） 0 0 1就是 z 轴  大部分的法线都是跟切线空间的 z 轴同方向</p>\n<p>一种是模型空间下的法线纹理 一种是切线空间下的法线纹理</p>\n<p>模型空间存储的优点：</p>\n<ul>\n<li>实现简单 直观。生成简单</li>\n<li>提供平滑的边界 模型空间可以生成平滑</li>\n</ul>\n<p>切线空间优点：</p>\n<ul>\n<li>自由度高 模型空间的是绝对法线信息  应用到不同网格都有合理的效果</li>\n<li>可进行 UV 动画 我们通过移动一个纹理的 UV 坐标来实现凹凸移动的效果</li>\n<li>可压缩  只此处 xy  z 可以推倒得到 </li>\n</ul>\n<h6 id=\"7-2-3-实践\"><a href=\"#7-2-3-实践\" class=\"headerlink\" title=\"7.2.3 实践\"></a>7.2.3 实践</h6><ul>\n<li>一种在切线空间下进行光照计算 把光照方向、视角方向变换到切线空间下 ：效率比较高  在顶点着色器可以完成 光照和视角的转换  第二种要堆法线纹理取样 需要在片元着色器中变换 我觉得应该是片元的数量大于顶点的数量所以转换需要很多<br>有时我们要在世界空间下进行一些计算 例如在 Cubemap进行环境映射 需要使用世界空间下进行一些计算 （这个 cubemap 不知讲啥）</li>\n<li>另外一种是在世界坐标空间下进行光照计算 我们要把切线空间下的法线防线转换到世界空间下：</li>\n</ul>\n<ol>\n<li>在切线空间下计算<br>思路：在片元着色器中得到纹理采样的切线空间下的法线 然后再与切线空间下的视角方向 光照方向进行计算<br>注：float4 texcoord : TEXCOORD0; 传入的是float4 xy 是原因的纹理 UV zw 是法线纹理 uv</li>\n</ol>\n<h6 id=\"7-2-4-unity-法线纹理类型\"><a href=\"#7-2-4-unity-法线纹理类型\" class=\"headerlink\" title=\"7.2.4 unity 法线纹理类型\"></a>7.2.4 unity 法线纹理类型</h6><p>法线纹理会根据平台被压缩<br>使用 unpackNormal 函数取解压<br>普通纹理的话 是4个通道都是不能舍弃  如果是法线纹理 那么只有ag 是需呀的 br 是不需要的 用 DXT5nm 可以升内存空间。<br>Create from Grayscale 是凹凸映射的方法 高度图 </p>\n<h5 id=\"7-3渐变纹理\"><a href=\"#7-3渐变纹理\" class=\"headerlink\" title=\"7.3渐变纹理\"></a>7.3渐变纹理</h5><h5 id=\"7-4遮罩纹理\"><a href=\"#7-4遮罩纹理\" class=\"headerlink\" title=\"7.4遮罩纹理\"></a>7.4遮罩纹理</h5><p>使用其中某个（或者几个）通道做乘法 如果通道为0 可以保证表面不受该属性影响 </p>\n<h4 id=\"8透明效果\"><a href=\"#8透明效果\" class=\"headerlink\" title=\"8透明效果\"></a>8透明效果</h4><p>unity 先渲染 Background 然后渲染 Geometry 大多数的不透明物体 前面都是开启深度测试和深度写入   之后渲染 AlphaTest 这个是透明物体  需要排序 从远到近 然后进行渲染</p>\n<h5 id=\"8-3透明度测试\"><a href=\"#8-3透明度测试\" class=\"headerlink\" title=\"8.3透明度测试\"></a>8.3透明度测试</h5><p>用一个阀值决定</p>\n<h5 id=\"8-4透明度混合\"><a href=\"#8-4透明度混合\" class=\"headerlink\" title=\"8.4透明度混合\"></a>8.4透明度混合</h5><p>Blend 内置的混合模式命令<br>Blend off 关闭混合<br>Blend SrcFactor DstFactor<br>srccolor <em> SrcFactor + dstcolor </em> DstFactor = Target</p>\n<h6 id=\"8-6-1-混合等式和参数\"><a href=\"#8-6-1-混合等式和参数\" class=\"headerlink\" title=\"8.6.1 混合等式和参数\"></a>8.6.1 混合等式和参数</h6><p>现在有 源颜色 S 和目标颜色 D 现在想要得到输出颜色 O 就必须使用一个等式来计算，这个就是混合等式<br>我们会用两个混合等式  一个用于混合 RGB 一个混合 A 通道 每个等式要两个因子   一共四个因子。</p>\n<p>中级篇</p>\n<p>####9 更复杂的光照<br>Forward Rendering Path、Deferred Rendering Path Vertext Lit Rendering Path</p>\n<p>顶点照明渲染路径：是对硬件配置要求最好  运算性能最高的</p>\n<p>跳过。。。</p>\n<h4 id=\"10-高级纹理\"><a href=\"#10-高级纹理\" class=\"headerlink\" title=\"10 高级纹理\"></a>10 高级纹理</h4><h5 id=\"10-1立方体纹理\"><a href=\"#10-1立方体纹理\" class=\"headerlink\" title=\"10.1立方体纹理\"></a>10.1立方体纹理</h5><p>立方体纹理是环境映射的一种实现方法<br>包含6张图像  采样的时候是用三维的坐标 </p>\n<p>使用立方体纹理的好处 实现简单快捷 得到的效果好  缺点是 如果当场景引入了新的物体 光源 或者物体在发生移动时 我们就需要重新生成 立方体纹理  可以反射环境  但不能反射自己  </p>\n<h6 id=\"10-1-1-天空盒子\"><a href=\"#10-1-1-天空盒子\" class=\"headerlink\" title=\"10.1.1 天空盒子\"></a>10.1.1 天空盒子</h6><p>windows -lighting 里面设置 skybox</p>\n<h6 id=\"10-1-2折射\"><a href=\"#10-1-2折射\" class=\"headerlink\" title=\"10.1.2折射\"></a>10.1.2折射</h6><p>折射 是用光照计算函数 然后用折射函数混合反射光</p>\n<h5 id=\"10-2渲染纹理\"><a href=\"#10-2渲染纹理\" class=\"headerlink\" title=\"10.2渲染纹理\"></a>10.2渲染纹理</h5><h5 id=\"10-2程序纹理\"><a href=\"#10-2程序纹理\" class=\"headerlink\" title=\"10.2程序纹理\"></a>10.2程序纹理</h5><h4 id=\"11-让画面动起来\"><a href=\"#11-让画面动起来\" class=\"headerlink\" title=\"11 让画面动起来\"></a>11 让画面动起来</h4><h5 id=\"11-1-unity-shader-中的内置变量\"><a href=\"#11-1-unity-shader-中的内置变量\" class=\"headerlink\" title=\"11.1 unity shader 中的内置变量\"></a>11.1 unity shader 中的内置变量</h5><p>_Time float4 场景加载开始所经过的实际<br>_SinTime 正弦值<br>_CosTime 余弦值<br>unity_DeltaTime </p>\n<h5 id=\"11-2-纹理动画\"><a href=\"#11-2-纹理动画\" class=\"headerlink\" title=\"11.2 纹理动画\"></a>11.2 纹理动画</h5><ul>\n<li>序列帧动画：记住 UV 纹理坐标是左下角是原点</li>\n<li>滚动的背景：修改 UV 纹理坐标 对两张纹理取样 然后混合</li>\n</ul>"},{"title":"首次用gitpage","date":"2016-08-09T14:49:39.000Z","_content":"# 总体上感觉不错\n* 十分的方便，可以在多个平台使用 发布方便\n* 因为用markdown所以格式不用担心  而且在什么平台都可以编写  写完上传github  之后用我的macbook 更新下编写的markdown 之后在macbook上面发布即可\n* 有些格式macdown看到是可以的 但是html又不可以了\n","source":"_posts/首次使用gitpage.md","raw":"---\ntitle: 首次用gitpage\ndate: 2016-08-09 22:49:39\ntags: 随笔\n---\n# 总体上感觉不错\n* 十分的方便，可以在多个平台使用 发布方便\n* 因为用markdown所以格式不用担心  而且在什么平台都可以编写  写完上传github  之后用我的macbook 更新下编写的markdown 之后在macbook上面发布即可\n* 有些格式macdown看到是可以的 但是html又不可以了\n","slug":"首次使用gitpage","published":1,"updated":"2018-05-11T10:13:52.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o5n0008znmjdtqolyt4","content":"<h1 id=\"总体上感觉不错\"><a href=\"#总体上感觉不错\" class=\"headerlink\" title=\"总体上感觉不错\"></a>总体上感觉不错</h1><ul>\n<li>十分的方便，可以在多个平台使用 发布方便</li>\n<li>因为用markdown所以格式不用担心  而且在什么平台都可以编写  写完上传github  之后用我的macbook 更新下编写的markdown 之后在macbook上面发布即可</li>\n<li>有些格式macdown看到是可以的 但是html又不可以了</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"总体上感觉不错\"><a href=\"#总体上感觉不错\" class=\"headerlink\" title=\"总体上感觉不错\"></a>总体上感觉不错</h1><ul>\n<li>十分的方便，可以在多个平台使用 发布方便</li>\n<li>因为用markdown所以格式不用担心  而且在什么平台都可以编写  写完上传github  之后用我的macbook 更新下编写的markdown 之后在macbook上面发布即可</li>\n<li>有些格式macdown看到是可以的 但是html又不可以了</li>\n</ul>\n"},{"title":"unity镜头控制脚本","date":"2017-08-09T16:00:00.000Z","published":1,"reward":true,"_content":"学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面：\n\n<!-- more -->\n看代码即可：\n\nusing UnityEngine;\nusing System.Collections;\n\npublic class CameraController : MonoBehaviour {\n//  【使用说明】：参考了网上代码\n//  1、拖拽到摄像头 作为摄像头的组件\n//  2、运行的时候：\n//      （1）镜头旋转 右键点击着屏幕 然后移动鼠标 即可旋转屏幕\n//      （2）镜头缩放 滚轮控制缩放镜头\n//      （3）手型工具 就像scene里面的手型工具一样 滚轮点击着拖拽屏幕\n//      （4）镜头复原 空格键就会复用镜头\n\n    ///【1】用于计算的变量\n    //旋转变量;\n    private float m_deltX = 0f;\n    private float m_deltY = 0f;\n    //摄像机原始位置 和 旋转角度  给复原使用\n    private Vector3 m_vecOriPosition;\n    private Quaternion m_vecOriRotation;\n    //手型工具：上次点击屏幕的位置\n    private Vector3 m_vecLasMouseClickPosition;\n\n    ///【2】用于控制幅度的变量\n    //缩放幅度;\n    public float m_fScalingSpeed = 10f;\n    //镜头旋转幅度;\n    public float m_fRotateSpeed = 5f;\n    //手型工具幅度;\n    public float m_fHandToolSpeed = -0.005f;\n\n    void Start()\n    {\n        m_vecOriRotation = camera.transform.rotation;\n        m_vecOriPosition = camera.transform.position;\n    }\n\n    void Update () {\n        //（1）旋转镜头 鼠标右键点下控制相机旋转;\n        if (Input.GetMouseButton(1))\n        {\n            m_deltX += Input.GetAxis(\"Mouse X\") * m_fRotateSpeed;\n            m_deltY -= Input.GetAxis(\"Mouse Y\") * m_fRotateSpeed;\n            m_deltX = ClampAngle(m_deltX, -360, 360);\n            m_deltY = ClampAngle(m_deltY, -70, 70);\n            camera.transform.rotation = Quaternion.Euler(m_deltY, m_deltX, 0);\n        }\n\n        //（2）镜头缩放\n        //鼠标中键点下场景缩放;\n        if (Input.GetAxis(\"Mouse ScrollWheel\") != 0)\n        {\n            //自由缩放方式;\n            m_fScalingSpeed = Input.GetAxis(\"Mouse ScrollWheel\") * 10f;\n            camera.transform.localPosition = camera.transform.position + camera.transform.forward * m_fScalingSpeed;\n        }\n\n        //（3）手型工具\n        if (Input.GetMouseButtonDown (2)) {\n            m_vecLasMouseClickPosition = Input.mousePosition;\n        }\n        else if (Input.GetMouseButton (2)) {\n            Vector3 NowHitPosition = Input.mousePosition;\n            Vector3 offsetVec = NowHitPosition - m_vecLasMouseClickPosition;\n            offsetVec = camera.transform.rotation * offsetVec;\n            camera.transform.localPosition = camera.transform.localPosition + offsetVec * (m_fHandToolSpeed);\n            m_vecLasMouseClickPosition = Input.mousePosition;\n        }\n\n        //(4)相机复位远点;\n        if (Input.GetKey(KeyCode.Space))\n        {\n            m_deltX = 0f;\n            m_deltY = 0f;\n            m_deltX = ClampAngle(m_deltX, -360, 360);\n            m_deltY = ClampAngle(m_deltY, -70, 70);\n            m_fScalingSpeed = 10.0f;\n            camera.transform.rotation = m_vecOriRotation;\n            camera.transform.localPosition = m_vecOriPosition;\n        }\n    }\n\n    //规划角度;\n    float ClampAngle(float angle, float minAngle, float maxAgnle)\n    {\n        if (angle <= -360)\n            angle += 360;\n        if (angle >= 360)\n            angle -= 360;\n\n        return Mathf.Clamp(angle, minAngle, maxAgnle);\n    }\n}\n","source":"_posts/unity镜头控制脚本.md","raw":"---\ntitle: unity镜头控制脚本\ndate: 2017-08-10T00:00:00.000Z\ntags: null\npublished: true\nreward: true\n---\n学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面：\n\n<!-- more -->\n看代码即可：\n\nusing UnityEngine;\nusing System.Collections;\n\npublic class CameraController : MonoBehaviour {\n//  【使用说明】：参考了网上代码\n//  1、拖拽到摄像头 作为摄像头的组件\n//  2、运行的时候：\n//      （1）镜头旋转 右键点击着屏幕 然后移动鼠标 即可旋转屏幕\n//      （2）镜头缩放 滚轮控制缩放镜头\n//      （3）手型工具 就像scene里面的手型工具一样 滚轮点击着拖拽屏幕\n//      （4）镜头复原 空格键就会复用镜头\n\n    ///【1】用于计算的变量\n    //旋转变量;\n    private float m_deltX = 0f;\n    private float m_deltY = 0f;\n    //摄像机原始位置 和 旋转角度  给复原使用\n    private Vector3 m_vecOriPosition;\n    private Quaternion m_vecOriRotation;\n    //手型工具：上次点击屏幕的位置\n    private Vector3 m_vecLasMouseClickPosition;\n\n    ///【2】用于控制幅度的变量\n    //缩放幅度;\n    public float m_fScalingSpeed = 10f;\n    //镜头旋转幅度;\n    public float m_fRotateSpeed = 5f;\n    //手型工具幅度;\n    public float m_fHandToolSpeed = -0.005f;\n\n    void Start()\n    {\n        m_vecOriRotation = camera.transform.rotation;\n        m_vecOriPosition = camera.transform.position;\n    }\n\n    void Update () {\n        //（1）旋转镜头 鼠标右键点下控制相机旋转;\n        if (Input.GetMouseButton(1))\n        {\n            m_deltX += Input.GetAxis(\"Mouse X\") * m_fRotateSpeed;\n            m_deltY -= Input.GetAxis(\"Mouse Y\") * m_fRotateSpeed;\n            m_deltX = ClampAngle(m_deltX, -360, 360);\n            m_deltY = ClampAngle(m_deltY, -70, 70);\n            camera.transform.rotation = Quaternion.Euler(m_deltY, m_deltX, 0);\n        }\n\n        //（2）镜头缩放\n        //鼠标中键点下场景缩放;\n        if (Input.GetAxis(\"Mouse ScrollWheel\") != 0)\n        {\n            //自由缩放方式;\n            m_fScalingSpeed = Input.GetAxis(\"Mouse ScrollWheel\") * 10f;\n            camera.transform.localPosition = camera.transform.position + camera.transform.forward * m_fScalingSpeed;\n        }\n\n        //（3）手型工具\n        if (Input.GetMouseButtonDown (2)) {\n            m_vecLasMouseClickPosition = Input.mousePosition;\n        }\n        else if (Input.GetMouseButton (2)) {\n            Vector3 NowHitPosition = Input.mousePosition;\n            Vector3 offsetVec = NowHitPosition - m_vecLasMouseClickPosition;\n            offsetVec = camera.transform.rotation * offsetVec;\n            camera.transform.localPosition = camera.transform.localPosition + offsetVec * (m_fHandToolSpeed);\n            m_vecLasMouseClickPosition = Input.mousePosition;\n        }\n\n        //(4)相机复位远点;\n        if (Input.GetKey(KeyCode.Space))\n        {\n            m_deltX = 0f;\n            m_deltY = 0f;\n            m_deltX = ClampAngle(m_deltX, -360, 360);\n            m_deltY = ClampAngle(m_deltY, -70, 70);\n            m_fScalingSpeed = 10.0f;\n            camera.transform.rotation = m_vecOriRotation;\n            camera.transform.localPosition = m_vecOriPosition;\n        }\n    }\n\n    //规划角度;\n    float ClampAngle(float angle, float minAngle, float maxAgnle)\n    {\n        if (angle <= -360)\n            angle += 360;\n        if (angle >= 360)\n            angle -= 360;\n\n        return Mathf.Clamp(angle, minAngle, maxAgnle);\n    }\n}\n","slug":"unity镜头控制脚本","updated":"2018-05-11T10:13:52.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o5p000aznmjxxt2x8bl","content":"<p>学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面：</p>\n<a id=\"more\"></a>\n<p>看代码即可：</p>\n<p>using UnityEngine;<br>using System.Collections;</p>\n<p>public class CameraController : MonoBehaviour {<br>//  【使用说明】：参考了网上代码<br>//  1、拖拽到摄像头 作为摄像头的组件<br>//  2、运行的时候：<br>//      （1）镜头旋转 右键点击着屏幕 然后移动鼠标 即可旋转屏幕<br>//      （2）镜头缩放 滚轮控制缩放镜头<br>//      （3）手型工具 就像scene里面的手型工具一样 滚轮点击着拖拽屏幕<br>//      （4）镜头复原 空格键就会复用镜头</p>\n<pre><code>///【1】用于计算的变量\n//旋转变量;\nprivate float m_deltX = 0f;\nprivate float m_deltY = 0f;\n//摄像机原始位置 和 旋转角度  给复原使用\nprivate Vector3 m_vecOriPosition;\nprivate Quaternion m_vecOriRotation;\n//手型工具：上次点击屏幕的位置\nprivate Vector3 m_vecLasMouseClickPosition;\n\n///【2】用于控制幅度的变量\n//缩放幅度;\npublic float m_fScalingSpeed = 10f;\n//镜头旋转幅度;\npublic float m_fRotateSpeed = 5f;\n//手型工具幅度;\npublic float m_fHandToolSpeed = -0.005f;\n\nvoid Start()\n{\n    m_vecOriRotation = camera.transform.rotation;\n    m_vecOriPosition = camera.transform.position;\n}\n\nvoid Update () {\n    //（1）旋转镜头 鼠标右键点下控制相机旋转;\n    if (Input.GetMouseButton(1))\n    {\n        m_deltX += Input.GetAxis(&quot;Mouse X&quot;) * m_fRotateSpeed;\n        m_deltY -= Input.GetAxis(&quot;Mouse Y&quot;) * m_fRotateSpeed;\n        m_deltX = ClampAngle(m_deltX, -360, 360);\n        m_deltY = ClampAngle(m_deltY, -70, 70);\n        camera.transform.rotation = Quaternion.Euler(m_deltY, m_deltX, 0);\n    }\n\n    //（2）镜头缩放\n    //鼠标中键点下场景缩放;\n    if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) != 0)\n    {\n        //自由缩放方式;\n        m_fScalingSpeed = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * 10f;\n        camera.transform.localPosition = camera.transform.position + camera.transform.forward * m_fScalingSpeed;\n    }\n\n    //（3）手型工具\n    if (Input.GetMouseButtonDown (2)) {\n        m_vecLasMouseClickPosition = Input.mousePosition;\n    }\n    else if (Input.GetMouseButton (2)) {\n        Vector3 NowHitPosition = Input.mousePosition;\n        Vector3 offsetVec = NowHitPosition - m_vecLasMouseClickPosition;\n        offsetVec = camera.transform.rotation * offsetVec;\n        camera.transform.localPosition = camera.transform.localPosition + offsetVec * (m_fHandToolSpeed);\n        m_vecLasMouseClickPosition = Input.mousePosition;\n    }\n\n    //(4)相机复位远点;\n    if (Input.GetKey(KeyCode.Space))\n    {\n        m_deltX = 0f;\n        m_deltY = 0f;\n        m_deltX = ClampAngle(m_deltX, -360, 360);\n        m_deltY = ClampAngle(m_deltY, -70, 70);\n        m_fScalingSpeed = 10.0f;\n        camera.transform.rotation = m_vecOriRotation;\n        camera.transform.localPosition = m_vecOriPosition;\n    }\n}\n\n//规划角度;\nfloat ClampAngle(float angle, float minAngle, float maxAgnle)\n{\n    if (angle &lt;= -360)\n        angle += 360;\n    if (angle &gt;= 360)\n        angle -= 360;\n\n    return Mathf.Clamp(angle, minAngle, maxAgnle);\n}\n</code></pre><p>}</p>\n","excerpt":"<p>学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面：</p>","more":"<p>看代码即可：</p>\n<p>using UnityEngine;<br>using System.Collections;</p>\n<p>public class CameraController : MonoBehaviour {<br>//  【使用说明】：参考了网上代码<br>//  1、拖拽到摄像头 作为摄像头的组件<br>//  2、运行的时候：<br>//      （1）镜头旋转 右键点击着屏幕 然后移动鼠标 即可旋转屏幕<br>//      （2）镜头缩放 滚轮控制缩放镜头<br>//      （3）手型工具 就像scene里面的手型工具一样 滚轮点击着拖拽屏幕<br>//      （4）镜头复原 空格键就会复用镜头</p>\n<pre><code>///【1】用于计算的变量\n//旋转变量;\nprivate float m_deltX = 0f;\nprivate float m_deltY = 0f;\n//摄像机原始位置 和 旋转角度  给复原使用\nprivate Vector3 m_vecOriPosition;\nprivate Quaternion m_vecOriRotation;\n//手型工具：上次点击屏幕的位置\nprivate Vector3 m_vecLasMouseClickPosition;\n\n///【2】用于控制幅度的变量\n//缩放幅度;\npublic float m_fScalingSpeed = 10f;\n//镜头旋转幅度;\npublic float m_fRotateSpeed = 5f;\n//手型工具幅度;\npublic float m_fHandToolSpeed = -0.005f;\n\nvoid Start()\n{\n    m_vecOriRotation = camera.transform.rotation;\n    m_vecOriPosition = camera.transform.position;\n}\n\nvoid Update () {\n    //（1）旋转镜头 鼠标右键点下控制相机旋转;\n    if (Input.GetMouseButton(1))\n    {\n        m_deltX += Input.GetAxis(&quot;Mouse X&quot;) * m_fRotateSpeed;\n        m_deltY -= Input.GetAxis(&quot;Mouse Y&quot;) * m_fRotateSpeed;\n        m_deltX = ClampAngle(m_deltX, -360, 360);\n        m_deltY = ClampAngle(m_deltY, -70, 70);\n        camera.transform.rotation = Quaternion.Euler(m_deltY, m_deltX, 0);\n    }\n\n    //（2）镜头缩放\n    //鼠标中键点下场景缩放;\n    if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) != 0)\n    {\n        //自由缩放方式;\n        m_fScalingSpeed = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * 10f;\n        camera.transform.localPosition = camera.transform.position + camera.transform.forward * m_fScalingSpeed;\n    }\n\n    //（3）手型工具\n    if (Input.GetMouseButtonDown (2)) {\n        m_vecLasMouseClickPosition = Input.mousePosition;\n    }\n    else if (Input.GetMouseButton (2)) {\n        Vector3 NowHitPosition = Input.mousePosition;\n        Vector3 offsetVec = NowHitPosition - m_vecLasMouseClickPosition;\n        offsetVec = camera.transform.rotation * offsetVec;\n        camera.transform.localPosition = camera.transform.localPosition + offsetVec * (m_fHandToolSpeed);\n        m_vecLasMouseClickPosition = Input.mousePosition;\n    }\n\n    //(4)相机复位远点;\n    if (Input.GetKey(KeyCode.Space))\n    {\n        m_deltX = 0f;\n        m_deltY = 0f;\n        m_deltX = ClampAngle(m_deltX, -360, 360);\n        m_deltY = ClampAngle(m_deltY, -70, 70);\n        m_fScalingSpeed = 10.0f;\n        camera.transform.rotation = m_vecOriRotation;\n        camera.transform.localPosition = m_vecOriPosition;\n    }\n}\n\n//规划角度;\nfloat ClampAngle(float angle, float minAngle, float maxAgnle)\n{\n    if (angle &lt;= -360)\n        angle += 360;\n    if (angle &gt;= 360)\n        angle -= 360;\n\n    return Mathf.Clamp(angle, minAngle, maxAgnle);\n}\n</code></pre><p>}</p>"},{"_content":"# 广告图适配方案\n@(Gwgo学习笔记)\n\n[toc]\n\n\n\n## 一、效果方案\n#### 0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\n\n#### 1、适配机型的依据：\n![Alt text](./1525588861883.png)\nhttp://nb.oa.com/AdaptionData/index/\n\n\n#### 2、适配方案如下：\n出图是出iphonex的图，全屏图是473*1024\n![Alt text](./1525595273245.png)\n\n\n\n#### 3、全屏图的换算公式：\n\n （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域\n![Alt text](./1525598195085.png)\n\n（2）把2436*1125 等比例缩放成 1024*473（有0.1的细微拉升 基本无感知）\n\n\n（3）把其他屏幕换算,\n等比拉升：deviceH/deviceW = deviceHScale/473\n所以deviceHScale = 设备高宽比*473\n![Alt text](./1525598487988.png)\n\n（4）算出上限 下限\n![Alt text](./1525598533911.png)\n\n\n（5）选线，告诉美术这些线的意义：\n1. iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例\n2. 第二条是需要适配的安卓机的**最小比例**\n3. 第三条线就是iphone4的比例\n\n总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。\n![Alt text](./1525598656780.png)\n\n#### 4、活动图的换算公式：\n了解个概念：matchWidthOrHeight  \n等于1的时候：缩放宽度\n等于0的时候：缩放高度\n 我们只有0、1情况\n\n![Alt text](./1525599459607.png)\n![Alt text](./1525599029998.png)\n\n代码中会动态改变这个值 所以换算公式也需要\n```\n\t\t\tif (Screen.width / this.m_canvasScaler.referenceResolution.x > Screen.height /             this.m_canvasScaler.referenceResolution.y)\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 1.0f;\n            }\n            else\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 0f;\n            }\n```\n\n![Alt text](./1525599300970.png)\n\n（1）算出在设备里面的广告图高度  \n（2）类似全屏图计算\n\n## 三、转PVR、ETC\n#### 1、目前的比例是按照高度是1024来做的  \n后续如果为了省内存或者是省流量 \npvr就可以做成这样，左边是原图右边是Alpha通道\npvr右侧取得是r g b其中一个值\n\n除了广告图可以左右拆分alpha 其他图集也是可以这样做的。\n![Alt text](./1525597015723.png)\n\n\n\n\n\n\n#### 2、需要这些工作\n（1）代码中是把www.bytes转RGBA32  存储宽高信息\n需要知道 原来的宽高  全屏则是473*1024 \n（2）分平台下载 etc pvr\n（3）修改材质  shader 需要修改uv \n（4）给美术使用的转图工具\n（5）给策划使用的上传工具","source":"_posts/unityAdsAdapter/广告图适配方案.md","raw":"# 广告图适配方案\n@(Gwgo学习笔记)\n\n[toc]\n\n\n\n## 一、效果方案\n#### 0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\n\n#### 1、适配机型的依据：\n![Alt text](./1525588861883.png)\nhttp://nb.oa.com/AdaptionData/index/\n\n\n#### 2、适配方案如下：\n出图是出iphonex的图，全屏图是473*1024\n![Alt text](./1525595273245.png)\n\n\n\n#### 3、全屏图的换算公式：\n\n （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域\n![Alt text](./1525598195085.png)\n\n（2）把2436*1125 等比例缩放成 1024*473（有0.1的细微拉升 基本无感知）\n\n\n（3）把其他屏幕换算,\n等比拉升：deviceH/deviceW = deviceHScale/473\n所以deviceHScale = 设备高宽比*473\n![Alt text](./1525598487988.png)\n\n（4）算出上限 下限\n![Alt text](./1525598533911.png)\n\n\n（5）选线，告诉美术这些线的意义：\n1. iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例\n2. 第二条是需要适配的安卓机的**最小比例**\n3. 第三条线就是iphone4的比例\n\n总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。\n![Alt text](./1525598656780.png)\n\n#### 4、活动图的换算公式：\n了解个概念：matchWidthOrHeight  \n等于1的时候：缩放宽度\n等于0的时候：缩放高度\n 我们只有0、1情况\n\n![Alt text](./1525599459607.png)\n![Alt text](./1525599029998.png)\n\n代码中会动态改变这个值 所以换算公式也需要\n```\n\t\t\tif (Screen.width / this.m_canvasScaler.referenceResolution.x > Screen.height /             this.m_canvasScaler.referenceResolution.y)\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 1.0f;\n            }\n            else\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 0f;\n            }\n```\n\n![Alt text](./1525599300970.png)\n\n（1）算出在设备里面的广告图高度  \n（2）类似全屏图计算\n\n## 三、转PVR、ETC\n#### 1、目前的比例是按照高度是1024来做的  \n后续如果为了省内存或者是省流量 \npvr就可以做成这样，左边是原图右边是Alpha通道\npvr右侧取得是r g b其中一个值\n\n除了广告图可以左右拆分alpha 其他图集也是可以这样做的。\n![Alt text](./1525597015723.png)\n\n\n\n\n\n\n#### 2、需要这些工作\n（1）代码中是把www.bytes转RGBA32  存储宽高信息\n需要知道 原来的宽高  全屏则是473*1024 \n（2）分平台下载 etc pvr\n（3）修改材质  shader 需要修改uv \n（4）给美术使用的转图工具\n（5）给策划使用的上传工具","slug":"unityAdsAdapter/广告图适配方案","published":1,"date":"2018-05-11T12:07:52.000Z","updated":"2018-05-11T12:07:52.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh1x7o6z000hznmjwjhwz2hr","content":"<h1 id=\"广告图适配方案\"><a href=\"#广告图适配方案\" class=\"headerlink\" title=\"广告图适配方案\"></a>广告图适配方案</h1><p>@(Gwgo学习笔记)</p>\n<p>[toc]</p>\n<h2 id=\"一、效果方案\"><a href=\"#一、效果方案\" class=\"headerlink\" title=\"一、效果方案\"></a>一、效果方案</h2><h4 id=\"0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"><a href=\"#0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\" class=\"headerlink\" title=\"0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"></a>0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。</h4><h4 id=\"1、适配机型的依据：\"><a href=\"#1、适配机型的依据：\" class=\"headerlink\" title=\"1、适配机型的依据：\"></a>1、适配机型的依据：</h4><p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525588861883.png\" alt=\"Alt text\"><br><a href=\"http://nb.oa.com/AdaptionData/index/\" target=\"_blank\" rel=\"external\">http://nb.oa.com/AdaptionData/index/</a></p>\n<h4 id=\"2、适配方案如下：\"><a href=\"#2、适配方案如下：\" class=\"headerlink\" title=\"2、适配方案如下：\"></a>2、适配方案如下：</h4><p>出图是出iphonex的图，全屏图是473*1024<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525595273245.png\" alt=\"Alt text\"></p>\n<h4 id=\"3、全屏图的换算公式：\"><a href=\"#3、全屏图的换算公式：\" class=\"headerlink\" title=\"3、全屏图的换算公式：\"></a>3、全屏图的换算公式：</h4><p> （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598195085.png\" alt=\"Alt text\"></p>\n<p>（2）把2436<em>1125 等比例缩放成 1024</em>473（有0.1的细微拉升 基本无感知）</p>\n<p>（3）把其他屏幕换算,<br>等比拉升：deviceH/deviceW = deviceHScale/473<br>所以deviceHScale = 设备高宽比*473<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598487988.png\" alt=\"Alt text\"></p>\n<p>（4）算出上限 下限<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598533911.png\" alt=\"Alt text\"></p>\n<p>（5）选线，告诉美术这些线的意义：</p>\n<ol>\n<li>iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例</li>\n<li>第二条是需要适配的安卓机的<strong>最小比例</strong></li>\n<li>第三条线就是iphone4的比例</li>\n</ol>\n<p>总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598656780.png\" alt=\"Alt text\"></p>\n<h4 id=\"4、活动图的换算公式：\"><a href=\"#4、活动图的换算公式：\" class=\"headerlink\" title=\"4、活动图的换算公式：\"></a>4、活动图的换算公式：</h4><p>了解个概念：matchWidthOrHeight<br>等于1的时候：缩放宽度<br>等于0的时候：缩放高度<br> 我们只有0、1情况</p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599459607.png\" alt=\"Alt text\"><br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599029998.png\" alt=\"Alt text\"></p>\n<p>代码中会动态改变这个值 所以换算公式也需要<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Screen.width / this.m_canvasScaler.referenceResolution.x &gt; Screen.height /             this.m_canvasScaler.referenceResolution.y)</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 1.0f;</div><div class=\"line\">         &#125;</div><div class=\"line\">         else</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 0f;</div><div class=\"line\">         &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599300970.png\" alt=\"Alt text\"></p>\n<p>（1）算出在设备里面的广告图高度<br>（2）类似全屏图计算</p>\n<h2 id=\"三、转PVR、ETC\"><a href=\"#三、转PVR、ETC\" class=\"headerlink\" title=\"三、转PVR、ETC\"></a>三、转PVR、ETC</h2><h4 id=\"1、目前的比例是按照高度是1024来做的\"><a href=\"#1、目前的比例是按照高度是1024来做的\" class=\"headerlink\" title=\"1、目前的比例是按照高度是1024来做的\"></a>1、目前的比例是按照高度是1024来做的</h4><p>后续如果为了省内存或者是省流量<br>pvr就可以做成这样，左边是原图右边是Alpha通道<br>pvr右侧取得是r g b其中一个值</p>\n<p>除了广告图可以左右拆分alpha 其他图集也是可以这样做的。<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525597015723.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、需要这些工作\"><a href=\"#2、需要这些工作\" class=\"headerlink\" title=\"2、需要这些工作\"></a>2、需要这些工作</h4><p>（1）代码中是把www.bytes转RGBA32  存储宽高信息<br>需要知道 原来的宽高  全屏则是473*1024<br>（2）分平台下载 etc pvr<br>（3）修改材质  shader 需要修改uv<br>（4）给美术使用的转图工具<br>（5）给策划使用的上传工具</p>\n","excerpt":"","more":"<h1 id=\"广告图适配方案\"><a href=\"#广告图适配方案\" class=\"headerlink\" title=\"广告图适配方案\"></a>广告图适配方案</h1><p>@(Gwgo学习笔记)</p>\n<p>[toc]</p>\n<h2 id=\"一、效果方案\"><a href=\"#一、效果方案\" class=\"headerlink\" title=\"一、效果方案\"></a>一、效果方案</h2><h4 id=\"0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"><a href=\"#0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\" class=\"headerlink\" title=\"0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"></a>0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。</h4><h4 id=\"1、适配机型的依据：\"><a href=\"#1、适配机型的依据：\" class=\"headerlink\" title=\"1、适配机型的依据：\"></a>1、适配机型的依据：</h4><p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525588861883.png\" alt=\"Alt text\"><br><a href=\"http://nb.oa.com/AdaptionData/index/\">http://nb.oa.com/AdaptionData/index/</a></p>\n<h4 id=\"2、适配方案如下：\"><a href=\"#2、适配方案如下：\" class=\"headerlink\" title=\"2、适配方案如下：\"></a>2、适配方案如下：</h4><p>出图是出iphonex的图，全屏图是473*1024<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525595273245.png\" alt=\"Alt text\"></p>\n<h4 id=\"3、全屏图的换算公式：\"><a href=\"#3、全屏图的换算公式：\" class=\"headerlink\" title=\"3、全屏图的换算公式：\"></a>3、全屏图的换算公式：</h4><p> （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598195085.png\" alt=\"Alt text\"></p>\n<p>（2）把2436<em>1125 等比例缩放成 1024</em>473（有0.1的细微拉升 基本无感知）</p>\n<p>（3）把其他屏幕换算,<br>等比拉升：deviceH/deviceW = deviceHScale/473<br>所以deviceHScale = 设备高宽比*473<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598487988.png\" alt=\"Alt text\"></p>\n<p>（4）算出上限 下限<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598533911.png\" alt=\"Alt text\"></p>\n<p>（5）选线，告诉美术这些线的意义：</p>\n<ol>\n<li>iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例</li>\n<li>第二条是需要适配的安卓机的<strong>最小比例</strong></li>\n<li>第三条线就是iphone4的比例</li>\n</ol>\n<p>总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525598656780.png\" alt=\"Alt text\"></p>\n<h4 id=\"4、活动图的换算公式：\"><a href=\"#4、活动图的换算公式：\" class=\"headerlink\" title=\"4、活动图的换算公式：\"></a>4、活动图的换算公式：</h4><p>了解个概念：matchWidthOrHeight<br>等于1的时候：缩放宽度<br>等于0的时候：缩放高度<br> 我们只有0、1情况</p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599459607.png\" alt=\"Alt text\"><br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599029998.png\" alt=\"Alt text\"></p>\n<p>代码中会动态改变这个值 所以换算公式也需要<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Screen.width / this.m_canvasScaler.referenceResolution.x &gt; Screen.height /             this.m_canvasScaler.referenceResolution.y)</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 1.0f;</div><div class=\"line\">         &#125;</div><div class=\"line\">         else</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 0f;</div><div class=\"line\">         &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525599300970.png\" alt=\"Alt text\"></p>\n<p>（1）算出在设备里面的广告图高度<br>（2）类似全屏图计算</p>\n<h2 id=\"三、转PVR、ETC\"><a href=\"#三、转PVR、ETC\" class=\"headerlink\" title=\"三、转PVR、ETC\"></a>三、转PVR、ETC</h2><h4 id=\"1、目前的比例是按照高度是1024来做的\"><a href=\"#1、目前的比例是按照高度是1024来做的\" class=\"headerlink\" title=\"1、目前的比例是按照高度是1024来做的\"></a>1、目前的比例是按照高度是1024来做的</h4><p>后续如果为了省内存或者是省流量<br>pvr就可以做成这样，左边是原图右边是Alpha通道<br>pvr右侧取得是r g b其中一个值</p>\n<p>除了广告图可以左右拆分alpha 其他图集也是可以这样做的。<br><img src=\"/2018/05/11/unityAdsAdapter/广告图适配方案/1525597015723.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、需要这些工作\"><a href=\"#2、需要这些工作\" class=\"headerlink\" title=\"2、需要这些工作\"></a>2、需要这些工作</h4><p>（1）代码中是把www.bytes转RGBA32  存储宽高信息<br>需要知道 原来的宽高  全屏则是473*1024<br>（2）分平台下载 etc pvr<br>（3）修改材质  shader 需要修改uv<br>（4）给美术使用的转图工具<br>（5）给策划使用的上传工具</p>\n"},{"title":"unityAdsAdapter","date":"2018-05-11T12:07:05.000Z","published":1,"reward":true,"_content":"\n\n\n## 一、效果方案\n#### 0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\n\n<!-- more -->\n\n\n\n#### 1、适配机型的依据：\n![Alt text](./1525588861883.png)\nhttp://nb.oa.com/AdaptionData/index/\n\n\n#### 2、适配方案如下：\n出图是出iphonex的图，全屏图是473*1024\n![Alt text](./1525595273245.png)\n\n\n\n#### 3、全屏图的换算公式：\n\n （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域\n![Alt text](./1525598195085.png)\n\n（2）把2436*1125 等比例缩放成 1024*473（有0.1的细微拉升 基本无感知）\n\n\n（3）把其他屏幕换算,\n等比拉升：deviceH/deviceW = deviceHScale/473\n所以deviceHScale = 设备高宽比*473\n![Alt text](./1525598487988.png)\n\n（4）算出上限 下限\n![Alt text](./1525598533911.png)\n\n\n（5）选线，告诉美术这些线的意义：\n1. iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例\n2. 第二条是需要适配的安卓机的**最小比例**\n3. 第三条线就是iphone4的比例\n\n总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。\n![Alt text](./1525598656780.png)\n\n#### 4、活动图的换算公式：\n了解个概念：matchWidthOrHeight  \n等于1的时候：缩放宽度\n等于0的时候：缩放高度\n 我们只有0、1情况\n\n![Alt text](./1525599459607.png)\n![Alt text](./1525599029998.png)\n\n代码中会动态改变这个值 所以换算公式也需要\n```\n\t\t\tif (Screen.width / this.m_canvasScaler.referenceResolution.x > Screen.height /             this.m_canvasScaler.referenceResolution.y)\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 1.0f;\n            }\n            else\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 0f;\n            }\n```\n\n![Alt text](./1525599300970.png)\n\n（1）算出在设备里面的广告图高度  \n（2）类似全屏图计算\n\n## 三、转PVR、ETC\n#### 1、目前的比例是按照高度是1024来做的  \n后续如果为了省内存或者是省流量 \npvr就可以做成这样，左边是原图右边是Alpha通道\npvr右侧取得是r g b其中一个值\n\n除了广告图可以左右拆分alpha 其他图集也是可以这样做的。\n![Alt text](./1525597015723.png)\n\n\n\n\n\n\n#### 2、需要这些工作\n（1）代码中是把www.bytes转RGBA32  存储宽高信息\n需要知道 原来的宽高  全屏则是473*1024 \n（2）分平台下载 etc pvr\n（3）修改材质  shader 需要修改uv \n（4）给美术使用的转图工具\n（5）给策划使用的上传工具","source":"_posts/unityAdsAdapter.md","raw":"---\ntitle: unityAdsAdapter\ndate: 2018-05-11 20:07:05\ntags: null\npublished: true\nreward: true\n---\n\n\n\n## 一、效果方案\n#### 0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\n\n<!-- more -->\n\n\n\n#### 1、适配机型的依据：\n![Alt text](./1525588861883.png)\nhttp://nb.oa.com/AdaptionData/index/\n\n\n#### 2、适配方案如下：\n出图是出iphonex的图，全屏图是473*1024\n![Alt text](./1525595273245.png)\n\n\n\n#### 3、全屏图的换算公式：\n\n （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域\n![Alt text](./1525598195085.png)\n\n（2）把2436*1125 等比例缩放成 1024*473（有0.1的细微拉升 基本无感知）\n\n\n（3）把其他屏幕换算,\n等比拉升：deviceH/deviceW = deviceHScale/473\n所以deviceHScale = 设备高宽比*473\n![Alt text](./1525598487988.png)\n\n（4）算出上限 下限\n![Alt text](./1525598533911.png)\n\n\n（5）选线，告诉美术这些线的意义：\n1. iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例\n2. 第二条是需要适配的安卓机的**最小比例**\n3. 第三条线就是iphone4的比例\n\n总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。\n![Alt text](./1525598656780.png)\n\n#### 4、活动图的换算公式：\n了解个概念：matchWidthOrHeight  \n等于1的时候：缩放宽度\n等于0的时候：缩放高度\n 我们只有0、1情况\n\n![Alt text](./1525599459607.png)\n![Alt text](./1525599029998.png)\n\n代码中会动态改变这个值 所以换算公式也需要\n```\n\t\t\tif (Screen.width / this.m_canvasScaler.referenceResolution.x > Screen.height /             this.m_canvasScaler.referenceResolution.y)\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 1.0f;\n            }\n            else\n            {\n                this.m_canvasScaler.matchWidthOrHeight = 0f;\n            }\n```\n\n![Alt text](./1525599300970.png)\n\n（1）算出在设备里面的广告图高度  \n（2）类似全屏图计算\n\n## 三、转PVR、ETC\n#### 1、目前的比例是按照高度是1024来做的  \n后续如果为了省内存或者是省流量 \npvr就可以做成这样，左边是原图右边是Alpha通道\npvr右侧取得是r g b其中一个值\n\n除了广告图可以左右拆分alpha 其他图集也是可以这样做的。\n![Alt text](./1525597015723.png)\n\n\n\n\n\n\n#### 2、需要这些工作\n（1）代码中是把www.bytes转RGBA32  存储宽高信息\n需要知道 原来的宽高  全屏则是473*1024 \n（2）分平台下载 etc pvr\n（3）修改材质  shader 需要修改uv \n（4）给美术使用的转图工具\n（5）给策划使用的上传工具","slug":"unityAdsAdapter","updated":"2018-05-11T12:16:54.812Z","_id":"cjh1xbyh10000k0mjlkorel7u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、效果方案\"><a href=\"#一、效果方案\" class=\"headerlink\" title=\"一、效果方案\"></a>一、效果方案</h2><h4 id=\"0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"><a href=\"#0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\" class=\"headerlink\" title=\"0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"></a>0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。</h4><a id=\"more\"></a>\n<h4 id=\"1、适配机型的依据：\"><a href=\"#1、适配机型的依据：\" class=\"headerlink\" title=\"1、适配机型的依据：\"></a>1、适配机型的依据：</h4><p><img src=\"/2018/05/11/unityAdsAdapter/1525588861883.png\" alt=\"Alt text\"><br><a href=\"http://nb.oa.com/AdaptionData/index/\" target=\"_blank\" rel=\"external\">http://nb.oa.com/AdaptionData/index/</a></p>\n<h4 id=\"2、适配方案如下：\"><a href=\"#2、适配方案如下：\" class=\"headerlink\" title=\"2、适配方案如下：\"></a>2、适配方案如下：</h4><p>出图是出iphonex的图，全屏图是473*1024<br><img src=\"/2018/05/11/unityAdsAdapter/1525595273245.png\" alt=\"Alt text\"></p>\n<h4 id=\"3、全屏图的换算公式：\"><a href=\"#3、全屏图的换算公式：\" class=\"headerlink\" title=\"3、全屏图的换算公式：\"></a>3、全屏图的换算公式：</h4><p> （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域<br><img src=\"/2018/05/11/unityAdsAdapter/1525598195085.png\" alt=\"Alt text\"></p>\n<p>（2）把2436<em>1125 等比例缩放成 1024</em>473（有0.1的细微拉升 基本无感知）</p>\n<p>（3）把其他屏幕换算,<br>等比拉升：deviceH/deviceW = deviceHScale/473<br>所以deviceHScale = 设备高宽比*473<br><img src=\"/2018/05/11/unityAdsAdapter/1525598487988.png\" alt=\"Alt text\"></p>\n<p>（4）算出上限 下限<br><img src=\"/2018/05/11/unityAdsAdapter/1525598533911.png\" alt=\"Alt text\"></p>\n<p>（5）选线，告诉美术这些线的意义：</p>\n<ol>\n<li>iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例</li>\n<li>第二条是需要适配的安卓机的<strong>最小比例</strong></li>\n<li>第三条线就是iphone4的比例</li>\n</ol>\n<p>总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。<br><img src=\"/2018/05/11/unityAdsAdapter/1525598656780.png\" alt=\"Alt text\"></p>\n<h4 id=\"4、活动图的换算公式：\"><a href=\"#4、活动图的换算公式：\" class=\"headerlink\" title=\"4、活动图的换算公式：\"></a>4、活动图的换算公式：</h4><p>了解个概念：matchWidthOrHeight<br>等于1的时候：缩放宽度<br>等于0的时候：缩放高度<br> 我们只有0、1情况</p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/1525599459607.png\" alt=\"Alt text\"><br><img src=\"/2018/05/11/unityAdsAdapter/1525599029998.png\" alt=\"Alt text\"></p>\n<p>代码中会动态改变这个值 所以换算公式也需要<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Screen.width / this.m_canvasScaler.referenceResolution.x &gt; Screen.height /             this.m_canvasScaler.referenceResolution.y)</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 1.0f;</div><div class=\"line\">         &#125;</div><div class=\"line\">         else</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 0f;</div><div class=\"line\">         &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/1525599300970.png\" alt=\"Alt text\"></p>\n<p>（1）算出在设备里面的广告图高度<br>（2）类似全屏图计算</p>\n<h2 id=\"三、转PVR、ETC\"><a href=\"#三、转PVR、ETC\" class=\"headerlink\" title=\"三、转PVR、ETC\"></a>三、转PVR、ETC</h2><h4 id=\"1、目前的比例是按照高度是1024来做的\"><a href=\"#1、目前的比例是按照高度是1024来做的\" class=\"headerlink\" title=\"1、目前的比例是按照高度是1024来做的\"></a>1、目前的比例是按照高度是1024来做的</h4><p>后续如果为了省内存或者是省流量<br>pvr就可以做成这样，左边是原图右边是Alpha通道<br>pvr右侧取得是r g b其中一个值</p>\n<p>除了广告图可以左右拆分alpha 其他图集也是可以这样做的。<br><img src=\"/2018/05/11/unityAdsAdapter/1525597015723.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、需要这些工作\"><a href=\"#2、需要这些工作\" class=\"headerlink\" title=\"2、需要这些工作\"></a>2、需要这些工作</h4><p>（1）代码中是把www.bytes转RGBA32  存储宽高信息<br>需要知道 原来的宽高  全屏则是473*1024<br>（2）分平台下载 etc pvr<br>（3）修改材质  shader 需要修改uv<br>（4）给美术使用的转图工具<br>（5）给策划使用的上传工具</p>\n","excerpt":"<h2 id=\"一、效果方案\"><a href=\"#一、效果方案\" class=\"headerlink\" title=\"一、效果方案\"></a>一、效果方案</h2><h4 id=\"0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"><a href=\"#0、适配方案就是让美术出一张图-然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\" class=\"headerlink\" title=\"0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。\"></a>0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。</h4>","more":"<h4 id=\"1、适配机型的依据：\"><a href=\"#1、适配机型的依据：\" class=\"headerlink\" title=\"1、适配机型的依据：\"></a>1、适配机型的依据：</h4><p><img src=\"/2018/05/11/unityAdsAdapter/1525588861883.png\" alt=\"Alt text\"><br><a href=\"http://nb.oa.com/AdaptionData/index/\">http://nb.oa.com/AdaptionData/index/</a></p>\n<h4 id=\"2、适配方案如下：\"><a href=\"#2、适配方案如下：\" class=\"headerlink\" title=\"2、适配方案如下：\"></a>2、适配方案如下：</h4><p>出图是出iphonex的图，全屏图是473*1024<br><img src=\"/2018/05/11/unityAdsAdapter/1525595273245.png\" alt=\"Alt text\"></p>\n<h4 id=\"3、全屏图的换算公式：\"><a href=\"#3、全屏图的换算公式：\" class=\"headerlink\" title=\"3、全屏图的换算公式：\"></a>3、全屏图的换算公式：</h4><p> （1）如果我们考虑最长的屏幕是iphonex  确定好以这个来出图  其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域<br><img src=\"/2018/05/11/unityAdsAdapter/1525598195085.png\" alt=\"Alt text\"></p>\n<p>（2）把2436<em>1125 等比例缩放成 1024</em>473（有0.1的细微拉升 基本无感知）</p>\n<p>（3）把其他屏幕换算,<br>等比拉升：deviceH/deviceW = deviceHScale/473<br>所以deviceHScale = 设备高宽比*473<br><img src=\"/2018/05/11/unityAdsAdapter/1525598487988.png\" alt=\"Alt text\"></p>\n<p>（4）算出上限 下限<br><img src=\"/2018/05/11/unityAdsAdapter/1525598533911.png\" alt=\"Alt text\"></p>\n<p>（5）选线，告诉美术这些线的意义：</p>\n<ol>\n<li>iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例</li>\n<li>第二条是需要适配的安卓机的<strong>最小比例</strong></li>\n<li>第三条线就是iphone4的比例</li>\n</ol>\n<p>总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。<br><img src=\"/2018/05/11/unityAdsAdapter/1525598656780.png\" alt=\"Alt text\"></p>\n<h4 id=\"4、活动图的换算公式：\"><a href=\"#4、活动图的换算公式：\" class=\"headerlink\" title=\"4、活动图的换算公式：\"></a>4、活动图的换算公式：</h4><p>了解个概念：matchWidthOrHeight<br>等于1的时候：缩放宽度<br>等于0的时候：缩放高度<br> 我们只有0、1情况</p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/1525599459607.png\" alt=\"Alt text\"><br><img src=\"/2018/05/11/unityAdsAdapter/1525599029998.png\" alt=\"Alt text\"></p>\n<p>代码中会动态改变这个值 所以换算公式也需要<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Screen.width / this.m_canvasScaler.referenceResolution.x &gt; Screen.height /             this.m_canvasScaler.referenceResolution.y)</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 1.0f;</div><div class=\"line\">         &#125;</div><div class=\"line\">         else</div><div class=\"line\">         &#123;</div><div class=\"line\">             this.m_canvasScaler.matchWidthOrHeight = 0f;</div><div class=\"line\">         &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/unityAdsAdapter/1525599300970.png\" alt=\"Alt text\"></p>\n<p>（1）算出在设备里面的广告图高度<br>（2）类似全屏图计算</p>\n<h2 id=\"三、转PVR、ETC\"><a href=\"#三、转PVR、ETC\" class=\"headerlink\" title=\"三、转PVR、ETC\"></a>三、转PVR、ETC</h2><h4 id=\"1、目前的比例是按照高度是1024来做的\"><a href=\"#1、目前的比例是按照高度是1024来做的\" class=\"headerlink\" title=\"1、目前的比例是按照高度是1024来做的\"></a>1、目前的比例是按照高度是1024来做的</h4><p>后续如果为了省内存或者是省流量<br>pvr就可以做成这样，左边是原图右边是Alpha通道<br>pvr右侧取得是r g b其中一个值</p>\n<p>除了广告图可以左右拆分alpha 其他图集也是可以这样做的。<br><img src=\"/2018/05/11/unityAdsAdapter/1525597015723.png\" alt=\"Alt text\"></p>\n<h4 id=\"2、需要这些工作\"><a href=\"#2、需要这些工作\" class=\"headerlink\" title=\"2、需要这些工作\"></a>2、需要这些工作</h4><p>（1）代码中是把www.bytes转RGBA32  存储宽高信息<br>需要知道 原来的宽高  全屏则是473*1024<br>（2）分平台下载 etc pvr<br>（3）修改材质  shader 需要修改uv<br>（4）给美术使用的转图工具<br>（5）给策划使用的上传工具</p>"}],"PostAsset":[{"_id":"source/_posts/unity_study/1496583208861.png","slug":"1496583208861.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491555497064.png","slug":"1491555497064.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/temp/1490002232972.png","slug":"1490002232972.png","post":"cjh1x7o5d0005znmjs5kfmhto","modified":0,"renderable":0},{"_id":"source/_posts/unity镜头控制脚本/1490002232972.png","slug":"1490002232972.png","post":"cjh1x7o5p000aznmjxxt2x8bl","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491555396564.png","slug":"1491555396564.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504488376717.png","slug":"1504488376717.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504488394913.png","slug":"1504488394913.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504488756715.png","slug":"1504488756715.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504488781878.png","slug":"1504488781878.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504489517922.png","slug":"1504489517922.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504491196164.png","slug":"1504491196164.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504492132538.png","slug":"1504492132538.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504492407923.png","slug":"1504492407923.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504492579311.png","slug":"1504492579311.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504509740940.png","slug":"1504509740940.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504511314399.png","slug":"1504511314399.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504516795002.png","slug":"1504516795002.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/picture-texture/1504516848865.png","slug":"1504516848865.png","post":"cjh1x7o530003znmjz8m12msv","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502367185977.png","slug":"1502367185977.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502419665363.png","slug":"1502419665363.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502421000610.png","slug":"1502421000610.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502587224424.png","slug":"1502587224424.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502589425321.png","slug":"1502589425321.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502589610210.png","slug":"1502589610210.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502589637210.png","slug":"1502589637210.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502592120847.png","slug":"1502592120847.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502592598574.png","slug":"1502592598574.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502592616992.png","slug":"1502592616992.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502593455464.png","slug":"1502593455464.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502593542093.png","slug":"1502593542093.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502593562614.png","slug":"1502593562614.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/1502597632750.png","slug":"1502597632750.png","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/kupao/demo.gif","slug":"demo.gif","post":"cjh1x7o4y0002znmjzwmze8cw","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1490002232972.png","slug":"1490002232972.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1490002240157.png","slug":"1490002240157.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491550201008.png","slug":"1491550201008.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491550243585.png","slug":"1491550243585.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491552037983.png","slug":"1491552037983.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491552515808.png","slug":"1491552515808.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491553048549.png","slug":"1491553048549.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491553152505.png","slug":"1491553152505.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491553537327.png","slug":"1491553537327.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491553548688.png","slug":"1491553548688.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491553612376.png","slug":"1491553612376.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491555581945.png","slug":"1491555581945.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491555622726.png","slug":"1491555622726.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491555636221.png","slug":"1491555636221.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491877171720.png","slug":"1491877171720.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1491877201762.png","slug":"1491877201762.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1495002356532.png","slug":"1495002356532.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1495002389507.png","slug":"1495002389507.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496577433020.png","slug":"1496577433020.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496577678948.png","slug":"1496577678948.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496655674282.png","slug":"1496655674282.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496663193818.png","slug":"1496663193818.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496663793026.png","slug":"1496663793026.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496664667730.png","slug":"1496664667730.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496664752184.png","slug":"1496664752184.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1496665501144.png","slug":"1496665501144.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497515757683.png","slug":"1497515757683.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497515795595.png","slug":"1497515795595.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497516506138.png","slug":"1497516506138.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497516724024.png","slug":"1497516724024.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497516894694.png","slug":"1497516894694.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497531965474.png","slug":"1497531965474.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497532344804.png","slug":"1497532344804.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/1497533865288.png","slug":"1497533865288.png","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/ply1.gif","slug":"ply1.gif","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/ply2.gif","slug":"ply2.gif","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/ply3.gif","slug":"ply3.gif","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/rpg.gif","slug":"rpg.gif","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unity_study/shader2.gif","slug":"shader2.gif","post":"cjh1x7o5l0006znmjhlvrqlw1","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525588861883.png","slug":"1525588861883.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525595273245.png","slug":"1525595273245.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525597015723.png","slug":"1525597015723.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525598195085.png","slug":"1525598195085.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525598487988.png","slug":"1525598487988.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525598533911.png","slug":"1525598533911.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525598656780.png","slug":"1525598656780.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525599029998.png","slug":"1525599029998.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525599300970.png","slug":"1525599300970.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/1525599459607.png","slug":"1525599459607.png","post":"cjh1xbyh10000k0mjlkorel7u","modified":0,"renderable":0},{"_id":"source/_posts/unityAdsAdapter/广告图适配方案.md","post":"cjh1xbyh10000k0mjlkorel7u","slug":"广告图适配方案.md","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjh1x7o5l0006znmjhlvrqlw1","tag_id":"cjh1x7o5b0004znmjwekrdwef","_id":"cjh1x7o5o0009znmjpulskp90"},{"post_id":"cjh1x7o4y0002znmjzwmze8cw","tag_id":"cjh1x7o5b0004znmjwekrdwef","_id":"cjh1x7o5q000bznmjee3g0m9b"},{"post_id":"cjh1x7o530003znmjz8m12msv","tag_id":"cjh1x7o5m0007znmj79hisbii","_id":"cjh1x7o5r000dznmjadt2dzdf"},{"post_id":"cjh1x7o5d0005znmjs5kfmhto","tag_id":"cjh1x7o5b0004znmjwekrdwef","_id":"cjh1x7o5s000fznmjtjcjede6"},{"post_id":"cjh1x7o5n0008znmjdtqolyt4","tag_id":"cjh1x7o5s000eznmjvq08i4sh","_id":"cjh1x7o5t000gznmj31vcdn88"}],"Tag":[{"name":"unity","_id":"cjh1x7o5b0004znmjwekrdwef"},{"name":"纹理格式,手游开发","_id":"cjh1x7o5m0007znmj79hisbii"},{"name":"随笔","_id":"cjh1x7o5s000eznmjvq08i4sh"}]}}